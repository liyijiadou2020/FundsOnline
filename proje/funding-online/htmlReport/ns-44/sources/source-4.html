


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=GBK"> 
  <title>Coverage Report > ReflectionUtils</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.junit.platform.commons.util</a>
</div>

<h1>Coverage Summary for Class: ReflectionUtils (org.junit.platform.commons.util)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">ReflectionUtils</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (8/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (46/46)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;//
&nbsp;// Source code recreated from a .class file by IntelliJ IDEA
&nbsp;// (powered by FernFlower decompiler)
&nbsp;//
&nbsp;
&nbsp;package org.junit.platform.commons.util;
&nbsp;
&nbsp;import java.io.File;
&nbsp;import java.lang.reflect.AccessibleObject;
&nbsp;import java.lang.reflect.Array;
&nbsp;import java.lang.reflect.Constructor;
&nbsp;import java.lang.reflect.Field;
&nbsp;import java.lang.reflect.GenericArrayType;
&nbsp;import java.lang.reflect.InvocationTargetException;
&nbsp;import java.lang.reflect.Member;
&nbsp;import java.lang.reflect.Method;
&nbsp;import java.lang.reflect.Modifier;
&nbsp;import java.lang.reflect.Type;
&nbsp;import java.lang.reflect.TypeVariable;
&nbsp;import java.net.URI;
&nbsp;import java.nio.file.Files;
&nbsp;import java.nio.file.LinkOption;
&nbsp;import java.nio.file.Path;
&nbsp;import java.nio.file.Paths;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Collection;
&nbsp;import java.util.Collections;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.IdentityHashMap;
&nbsp;import java.util.Iterator;
&nbsp;import java.util.LinkedHashSet;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Objects;
&nbsp;import java.util.Optional;
&nbsp;import java.util.Set;
&nbsp;import java.util.concurrent.ConcurrentHashMap;
&nbsp;import java.util.function.Predicate;
&nbsp;import java.util.regex.Matcher;
&nbsp;import java.util.regex.Pattern;
&nbsp;import java.util.stream.Collectors;
&nbsp;import java.util.stream.Stream;
&nbsp;import org.apiguardian.api.API;
&nbsp;import org.apiguardian.api.API.Status;
&nbsp;import org.junit.platform.commons.JUnitException;
&nbsp;import org.junit.platform.commons.function.Try;
&nbsp;import org.junit.platform.commons.logging.Logger;
&nbsp;import org.junit.platform.commons.logging.LoggerFactory;
&nbsp;
&nbsp;@API(
&nbsp;    status = Status.INTERNAL,
&nbsp;    since = &quot;1.0&quot;
&nbsp;)
&nbsp;public final class ReflectionUtils {
&nbsp;    private static final Logger logger = LoggerFactory.getLogger(ReflectionUtils.class);
&nbsp;    private static final Pattern VM_INTERNAL_OBJECT_ARRAY_PATTERN = Pattern.compile(&quot;^(\\[+)L(.+);$&quot;);
&nbsp;    private static final Pattern VM_INTERNAL_PRIMITIVE_ARRAY_PATTERN = Pattern.compile(&quot;^(\\[+)(\\[[ZBCDFIJS])$&quot;);
&nbsp;    private static final Pattern SOURCE_CODE_SYNTAX_ARRAY_PATTERN = Pattern.compile(&quot;^([^\\[\\]]+)((\\[\\])+)+$&quot;);
&nbsp;    private static final Class&lt;?&gt;[] EMPTY_CLASS_ARRAY = new Class[0];
&nbsp;    private static final ClasspathScanner classpathScanner = new ClasspathScanner(ClassLoaderUtils::getDefaultClassLoader, ReflectionUtils::tryToLoadClass);
&nbsp;    private static final Set&lt;String&gt; noCyclesDetectedCache = ConcurrentHashMap.newKeySet();
&nbsp;    private static final Map&lt;String, Class&lt;?&gt;&gt; classNameToTypeMap;
&nbsp;    private static final Map&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt; primitiveToWrapperMap;
&nbsp;
&nbsp;    private ReflectionUtils() {
&nbsp;    }
&nbsp;
&nbsp;    public static boolean isPublic(Class&lt;?&gt; clazz) {
&nbsp;        Preconditions.notNull(clazz, &quot;Class must not be null&quot;);
&nbsp;        return Modifier.isPublic(clazz.getModifiers());
&nbsp;    }
&nbsp;
&nbsp;    public static boolean isPublic(Member member) {
&nbsp;        Preconditions.notNull(member, &quot;Member must not be null&quot;);
&nbsp;        return Modifier.isPublic(member.getModifiers());
&nbsp;    }
&nbsp;
&nbsp;    public static boolean isPrivate(Class&lt;?&gt; clazz) {
&nbsp;        Preconditions.notNull(clazz, &quot;Class must not be null&quot;);
&nbsp;        return Modifier.isPrivate(clazz.getModifiers());
&nbsp;    }
&nbsp;
&nbsp;    public static boolean isPrivate(Member member) {
&nbsp;        Preconditions.notNull(member, &quot;Member must not be null&quot;);
&nbsp;        return Modifier.isPrivate(member.getModifiers());
&nbsp;    }
&nbsp;
&nbsp;    @API(
&nbsp;        status = Status.INTERNAL,
&nbsp;        since = &quot;1.4&quot;
&nbsp;    )
&nbsp;    public static boolean isNotPrivate(Class&lt;?&gt; clazz) {
&nbsp;        return !isPrivate(clazz);
&nbsp;    }
&nbsp;
&nbsp;    @API(
&nbsp;        status = Status.INTERNAL,
&nbsp;        since = &quot;1.1&quot;
&nbsp;    )
&nbsp;    public static boolean isNotPrivate(Member member) {
&nbsp;        return !isPrivate(member);
&nbsp;    }
&nbsp;
&nbsp;    public static boolean isAbstract(Class&lt;?&gt; clazz) {
&nbsp;        Preconditions.notNull(clazz, &quot;Class must not be null&quot;);
&nbsp;        return Modifier.isAbstract(clazz.getModifiers());
&nbsp;    }
&nbsp;
&nbsp;    public static boolean isAbstract(Member member) {
&nbsp;        Preconditions.notNull(member, &quot;Member must not be null&quot;);
&nbsp;        return Modifier.isAbstract(member.getModifiers());
&nbsp;    }
&nbsp;
&nbsp;    public static boolean isStatic(Class&lt;?&gt; clazz) {
&nbsp;        Preconditions.notNull(clazz, &quot;Class must not be null&quot;);
&nbsp;        return Modifier.isStatic(clazz.getModifiers());
&nbsp;    }
&nbsp;
&nbsp;    @API(
&nbsp;        status = Status.INTERNAL,
&nbsp;        since = &quot;1.4&quot;
&nbsp;    )
&nbsp;    public static boolean isNotStatic(Class&lt;?&gt; clazz) {
&nbsp;        return !isStatic(clazz);
&nbsp;    }
&nbsp;
&nbsp;    public static boolean isStatic(Member member) {
&nbsp;        Preconditions.notNull(member, &quot;Member must not be null&quot;);
&nbsp;        return Modifier.isStatic(member.getModifiers());
&nbsp;    }
&nbsp;
&nbsp;    @API(
&nbsp;        status = Status.INTERNAL,
&nbsp;        since = &quot;1.1&quot;
&nbsp;    )
&nbsp;    public static boolean isNotStatic(Member member) {
&nbsp;        return !isStatic(member);
&nbsp;    }
&nbsp;
&nbsp;    @API(
&nbsp;        status = Status.INTERNAL,
&nbsp;        since = &quot;1.5&quot;
&nbsp;    )
&nbsp;    public static boolean isFinal(Class&lt;?&gt; clazz) {
&nbsp;        Preconditions.notNull(clazz, &quot;Class must not be null&quot;);
&nbsp;        return Modifier.isFinal(clazz.getModifiers());
&nbsp;    }
&nbsp;
&nbsp;    @API(
&nbsp;        status = Status.INTERNAL,
&nbsp;        since = &quot;1.5&quot;
&nbsp;    )
&nbsp;    public static boolean isNotFinal(Class&lt;?&gt; clazz) {
&nbsp;        return !isFinal(clazz);
&nbsp;    }
&nbsp;
&nbsp;    @API(
&nbsp;        status = Status.INTERNAL,
&nbsp;        since = &quot;1.5&quot;
&nbsp;    )
&nbsp;    public static boolean isFinal(Member member) {
&nbsp;        Preconditions.notNull(member, &quot;Member must not be null&quot;);
&nbsp;        return Modifier.isFinal(member.getModifiers());
&nbsp;    }
&nbsp;
&nbsp;    @API(
&nbsp;        status = Status.INTERNAL,
&nbsp;        since = &quot;1.5&quot;
&nbsp;    )
&nbsp;    public static boolean isNotFinal(Member member) {
&nbsp;        return !isFinal(member);
&nbsp;    }
&nbsp;
&nbsp;    public static boolean isInnerClass(Class&lt;?&gt; clazz) {
&nbsp;        Preconditions.notNull(clazz, &quot;Class must not be null&quot;);
&nbsp;        return !isStatic(clazz) &amp;&amp; clazz.isMemberClass();
&nbsp;    }
&nbsp;
&nbsp;    public static boolean returnsVoid(Method method) {
&nbsp;        return method.getReturnType().equals(Void.TYPE);
&nbsp;    }
&nbsp;
&nbsp;    public static boolean isArray(Object obj) {
&nbsp;        return obj != null &amp;&amp; obj.getClass().isArray();
&nbsp;    }
&nbsp;
&nbsp;    @API(
&nbsp;        status = Status.INTERNAL,
&nbsp;        since = &quot;1.3.2&quot;
&nbsp;    )
&nbsp;    public static boolean isMultidimensionalArray(Object obj) {
&nbsp;        return obj != null &amp;&amp; obj.getClass().isArray() &amp;&amp; obj.getClass().getComponentType().isArray();
&nbsp;    }
&nbsp;
&nbsp;    public static boolean isAssignableTo(Class&lt;?&gt; sourceType, Class&lt;?&gt; targetType) {
&nbsp;        Preconditions.notNull(sourceType, &quot;source type must not be null&quot;);
&nbsp;        Preconditions.condition(!sourceType.isPrimitive(), &quot;source type must not be a primitive type&quot;);
&nbsp;        Preconditions.notNull(targetType, &quot;target type must not be null&quot;);
&nbsp;        if (targetType.isAssignableFrom(sourceType)) {
&nbsp;            return true;
&nbsp;        } else if (!targetType.isPrimitive()) {
&nbsp;            return false;
&nbsp;        } else {
&nbsp;            return sourceType == primitiveToWrapperMap.get(targetType) || isWideningConversion(sourceType, targetType);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static boolean isAssignableTo(Object obj, Class&lt;?&gt; targetType) {
&nbsp;        Preconditions.notNull(targetType, &quot;target type must not be null&quot;);
&nbsp;        if (obj == null) {
&nbsp;            return !targetType.isPrimitive();
&nbsp;        } else if (targetType.isInstance(obj)) {
&nbsp;            return true;
&nbsp;        } else if (!targetType.isPrimitive()) {
&nbsp;            return false;
&nbsp;        } else {
&nbsp;            Class&lt;?&gt; sourceType = obj.getClass();
&nbsp;            return sourceType == primitiveToWrapperMap.get(targetType) || isWideningConversion(sourceType, targetType);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    static boolean isWideningConversion(Class&lt;?&gt; sourceType, Class&lt;?&gt; targetType) {
&nbsp;        Preconditions.condition(targetType.isPrimitive(), &quot;targetType must be primitive&quot;);
&nbsp;        boolean isPrimitive = sourceType.isPrimitive();
&nbsp;        boolean isWrapper = primitiveToWrapperMap.containsValue(sourceType);
&nbsp;        if (!isPrimitive &amp;&amp; !isWrapper) {
&nbsp;            return false;
&nbsp;        } else {
&nbsp;            if (isPrimitive) {
&nbsp;                sourceType = (Class)primitiveToWrapperMap.get(sourceType);
&nbsp;            }
&nbsp;
&nbsp;            if (sourceType == Byte.class) {
&nbsp;                return targetType == Short.TYPE || targetType == Integer.TYPE || targetType == Long.TYPE || targetType == Float.TYPE || targetType == Double.TYPE;
&nbsp;            } else if (sourceType != Short.class &amp;&amp; sourceType != Character.class) {
&nbsp;                if (sourceType == Integer.class) {
&nbsp;                    return targetType == Long.TYPE || targetType == Float.TYPE || targetType == Double.TYPE;
&nbsp;                } else if (sourceType != Long.class) {
&nbsp;                    if (sourceType == Float.class) {
&nbsp;                        return targetType == Double.TYPE;
&nbsp;                    } else {
&nbsp;                        return false;
&nbsp;                    }
&nbsp;                } else {
&nbsp;                    return targetType == Float.TYPE || targetType == Double.TYPE;
&nbsp;                }
&nbsp;            } else {
&nbsp;                return targetType == Integer.TYPE || targetType == Long.TYPE || targetType == Float.TYPE || targetType == Double.TYPE;
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static Class&lt;?&gt; getWrapperType(Class&lt;?&gt; type) {
&nbsp;        return (Class)primitiveToWrapperMap.get(type);
&nbsp;    }
&nbsp;
&nbsp;    public static &lt;T&gt; T newInstance(Class&lt;T&gt; clazz, Object... args) {
&nbsp;        Preconditions.notNull(clazz, &quot;Class must not be null&quot;);
&nbsp;        Preconditions.notNull(args, &quot;Argument array must not be null&quot;);
&nbsp;        Preconditions.containsNoNullElements(args, &quot;Individual arguments must not be null&quot;);
&nbsp;
&nbsp;        try {
&nbsp;            Class&lt;?&gt;[] parameterTypes = (Class[])Arrays.stream(args).map(Object::getClass).toArray((x$0) -&gt; {
&nbsp;                return new Class[x$0];
&nbsp;            });
&nbsp;            return newInstance(clazz.getDeclaredConstructor(parameterTypes), args);
&nbsp;        } catch (Throwable var3) {
&nbsp;            throw ExceptionUtils.throwAsUncheckedException(getUnderlyingCause(var3));
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static &lt;T&gt; T newInstance(Constructor&lt;T&gt; constructor, Object... args) {
&nbsp;        Preconditions.notNull(constructor, &quot;Constructor must not be null&quot;);
&nbsp;
&nbsp;        try {
&nbsp;            return ((Constructor)makeAccessible(constructor)).newInstance(args);
&nbsp;        } catch (Throwable var3) {
&nbsp;            throw ExceptionUtils.throwAsUncheckedException(getUnderlyingCause(var3));
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /** @deprecated */
&nbsp;    @API(
&nbsp;        status = Status.DEPRECATED,
&nbsp;        since = &quot;1.4&quot;
&nbsp;    )
&nbsp;    @Deprecated
&nbsp;    public static &lt;T&gt; Optional&lt;Object&gt; readFieldValue(Class&lt;T&gt; clazz, String fieldName, T instance) {
&nbsp;        return tryToReadFieldValue(clazz, fieldName, instance).toOptional();
&nbsp;    }
&nbsp;
&nbsp;    @API(
&nbsp;        status = Status.INTERNAL,
&nbsp;        since = &quot;1.4&quot;
&nbsp;    )
&nbsp;    public static &lt;T&gt; Try&lt;Object&gt; tryToReadFieldValue(Class&lt;T&gt; clazz, String fieldName, T instance) {
&nbsp;        Preconditions.notNull(clazz, &quot;Class must not be null&quot;);
&nbsp;        Preconditions.notBlank(fieldName, &quot;Field name must not be null or blank&quot;);
&nbsp;        return Try.call(() -&gt; {
&nbsp;            return clazz.getDeclaredField(fieldName);
&nbsp;        }).andThen((field) -&gt; {
&nbsp;            return tryToReadFieldValue(field, instance);
&nbsp;        });
&nbsp;    }
&nbsp;
&nbsp;    /** @deprecated */
&nbsp;    @API(
&nbsp;        status = Status.DEPRECATED,
&nbsp;        since = &quot;1.4&quot;
&nbsp;    )
&nbsp;    @Deprecated
&nbsp;    public static Optional&lt;Object&gt; readFieldValue(Field field) {
&nbsp;        return tryToReadFieldValue(field).toOptional();
&nbsp;    }
&nbsp;
&nbsp;    @API(
&nbsp;        status = Status.INTERNAL,
&nbsp;        since = &quot;1.4&quot;
&nbsp;    )
&nbsp;    public static Try&lt;Object&gt; tryToReadFieldValue(Field field) {
&nbsp;        return tryToReadFieldValue(field, (Object)null);
&nbsp;    }
&nbsp;
&nbsp;    /** @deprecated */
&nbsp;    @API(
&nbsp;        status = Status.DEPRECATED,
&nbsp;        since = &quot;1.4&quot;
&nbsp;    )
&nbsp;    @Deprecated
&nbsp;    public static Optional&lt;Object&gt; readFieldValue(Field field, Object instance) {
&nbsp;        return tryToReadFieldValue(field, instance).toOptional();
&nbsp;    }
&nbsp;
&nbsp;    @API(
&nbsp;        status = Status.INTERNAL,
&nbsp;        since = &quot;1.4&quot;
&nbsp;    )
&nbsp;    public static Try&lt;Object&gt; tryToReadFieldValue(Field field, Object instance) {
&nbsp;        Preconditions.notNull(field, &quot;Field must not be null&quot;);
&nbsp;        Preconditions.condition(instance != null || isStatic((Member)field), () -&gt; {
&nbsp;            return String.format(&quot;Cannot read non-static field [%s] on a null instance.&quot;, field);
&nbsp;        });
&nbsp;        return Try.call(() -&gt; {
&nbsp;            return ((Field)makeAccessible(field)).get(instance);
&nbsp;        });
&nbsp;    }
&nbsp;
&nbsp;    public static List&lt;Object&gt; readFieldValues(List&lt;Field&gt; fields, Object instance) {
&nbsp;        return readFieldValues(fields, instance, (field) -&gt; {
&nbsp;            return true;
&nbsp;        });
&nbsp;    }
&nbsp;
&nbsp;    public static List&lt;Object&gt; readFieldValues(List&lt;Field&gt; fields, Object instance, Predicate&lt;Field&gt; predicate) {
&nbsp;        Preconditions.notNull(fields, &quot;fields list must not be null&quot;);
&nbsp;        Preconditions.notNull(predicate, &quot;Predicate must not be null&quot;);
&nbsp;        return (List)fields.stream().filter(predicate).map((field) -&gt; {
&nbsp;            return tryToReadFieldValue(field, instance).getOrThrow(ExceptionUtils::throwAsUncheckedException);
&nbsp;        }).collect(CollectionUtils.toUnmodifiableList());
&nbsp;    }
&nbsp;
&nbsp;    public static Object invokeMethod(Method method, Object target, Object... args) {
&nbsp;        Preconditions.notNull(method, &quot;Method must not be null&quot;);
&nbsp;        Preconditions.condition(target != null || isStatic((Member)method), () -&gt; {
&nbsp;            return String.format(&quot;Cannot invoke non-static method [%s] on a null target.&quot;, method.toGenericString());
&nbsp;        });
&nbsp;
&nbsp;        try {
&nbsp;            return ((Method)makeAccessible(method)).invoke(target, args);
&nbsp;        } catch (Throwable var4) {
&nbsp;            throw ExceptionUtils.throwAsUncheckedException(getUnderlyingCause(var4));
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /** @deprecated */
&nbsp;    @API(
&nbsp;        status = Status.DEPRECATED,
&nbsp;        since = &quot;1.4&quot;
&nbsp;    )
&nbsp;    @Deprecated
&nbsp;    public static Optional&lt;Class&lt;?&gt;&gt; loadClass(String name) {
&nbsp;        return tryToLoadClass(name).toOptional();
&nbsp;    }
&nbsp;
&nbsp;    @API(
&nbsp;        status = Status.INTERNAL,
&nbsp;        since = &quot;1.4&quot;
&nbsp;    )
&nbsp;    public static Try&lt;Class&lt;?&gt;&gt; tryToLoadClass(String name) {
&nbsp;        return tryToLoadClass(name, ClassLoaderUtils.getDefaultClassLoader());
&nbsp;    }
&nbsp;
&nbsp;    /** @deprecated */
&nbsp;    @API(
&nbsp;        status = Status.DEPRECATED,
&nbsp;        since = &quot;1.4&quot;
&nbsp;    )
&nbsp;    @Deprecated
&nbsp;    public static Optional&lt;Class&lt;?&gt;&gt; loadClass(String name, ClassLoader classLoader) {
&nbsp;        return tryToLoadClass(name, classLoader).toOptional();
&nbsp;    }
&nbsp;
&nbsp;    @API(
&nbsp;        status = Status.INTERNAL,
&nbsp;        since = &quot;1.4&quot;
&nbsp;    )
&nbsp;    public static Try&lt;Class&lt;?&gt;&gt; tryToLoadClass(String name, ClassLoader classLoader) {
&nbsp;        Preconditions.notBlank(name, &quot;Class name must not be null or blank&quot;);
&nbsp;        Preconditions.notNull(classLoader, &quot;ClassLoader must not be null&quot;);
&nbsp;        String trimmedName = name.trim();
&nbsp;        return classNameToTypeMap.containsKey(trimmedName) ? Try.success((Class)classNameToTypeMap.get(trimmedName)) : Try.call(() -&gt; {
&nbsp;            Matcher matcher = VM_INTERNAL_PRIMITIVE_ARRAY_PATTERN.matcher(trimmedName);
&nbsp;            String componentTypeName;
&nbsp;            String bracketPairs;
&nbsp;            int dimensions;
&nbsp;            if (matcher.matches()) {
&nbsp;                componentTypeName = matcher.group(1);
&nbsp;                bracketPairs = matcher.group(2);
&nbsp;                dimensions = componentTypeName.length();
&nbsp;                return loadArrayType(classLoader, bracketPairs, dimensions);
&nbsp;            } else {
&nbsp;                matcher = VM_INTERNAL_OBJECT_ARRAY_PATTERN.matcher(trimmedName);
&nbsp;                if (matcher.matches()) {
<b class="fc">&nbsp;                    componentTypeName = matcher.group(1);</b>
&nbsp;                    bracketPairs = matcher.group(2);
<b class="fc">&nbsp;                    dimensions = componentTypeName.length();</b>
&nbsp;                    return loadArrayType(classLoader, bracketPairs, dimensions);
&nbsp;                } else {
&nbsp;                    matcher = SOURCE_CODE_SYNTAX_ARRAY_PATTERN.matcher(trimmedName);
<b class="fc">&nbsp;                    if (matcher.matches()) {</b>
<b class="fc">&nbsp;                        componentTypeName = matcher.group(1);</b>
&nbsp;                        bracketPairs = matcher.group(2);
&nbsp;                        dimensions = bracketPairs.length() / 2;
&nbsp;                        return loadArrayType(classLoader, componentTypeName, dimensions);
&nbsp;                    } else {
&nbsp;                        return classLoader.loadClass(trimmedName);
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        });
&nbsp;    }
&nbsp;
&nbsp;    private static Class&lt;?&gt; loadArrayType(ClassLoader classLoader, String componentTypeName, int dimensions) throws ClassNotFoundException {
&nbsp;        Class&lt;?&gt; componentType = classNameToTypeMap.containsKey(componentTypeName) ? (Class)classNameToTypeMap.get(componentTypeName) : classLoader.loadClass(componentTypeName);
&nbsp;        return Array.newInstance(componentType, new int[dimensions]).getClass();
&nbsp;    }
&nbsp;
&nbsp;    public static String getFullyQualifiedMethodName(Class&lt;?&gt; clazz, Method method) {
&nbsp;        Preconditions.notNull(method, &quot;Method must not be null&quot;);
&nbsp;        return getFullyQualifiedMethodName(clazz, method.getName(), method.getParameterTypes());
&nbsp;    }
&nbsp;
&nbsp;    public static String getFullyQualifiedMethodName(Class&lt;?&gt; clazz, String methodName, Class&lt;?&gt;... parameterTypes) {
&nbsp;        Preconditions.notNull(clazz, &quot;Class must not be null&quot;);
&nbsp;        Preconditions.notBlank(methodName, &quot;Method name must not be null or blank&quot;);
&nbsp;        return String.format(&quot;%s#%s(%s)&quot;, clazz.getName(), methodName, ClassUtils.nullSafeToString(parameterTypes));
&nbsp;    }
&nbsp;
&nbsp;    public static String[] parseFullyQualifiedMethodName(String fullyQualifiedMethodName) {
&nbsp;        Preconditions.notBlank(fullyQualifiedMethodName, &quot;fullyQualifiedMethodName must not be null or blank&quot;);
&nbsp;        int indexOfFirstHashtag = fullyQualifiedMethodName.indexOf(35);
&nbsp;        boolean validSyntax = indexOfFirstHashtag &gt; 0 &amp;&amp; indexOfFirstHashtag &lt; fullyQualifiedMethodName.length() - 1;
&nbsp;        Preconditions.condition(validSyntax, () -&gt; {
&nbsp;            return &quot;[&quot; + fullyQualifiedMethodName + &quot;] is not a valid fully qualified method name: it must start with a fully qualified class name followed by a &#39;#&#39; and then the method name, optionally followed by a parameter list enclosed in parentheses.&quot;;
&nbsp;        });
&nbsp;        String className = fullyQualifiedMethodName.substring(0, indexOfFirstHashtag);
&nbsp;        String methodPart = fullyQualifiedMethodName.substring(indexOfFirstHashtag + 1);
&nbsp;        String methodName = methodPart;
&nbsp;        String methodParameters = &quot;&quot;;
&nbsp;        if (methodPart.endsWith(&quot;()&quot;)) {
&nbsp;            methodName = methodPart.substring(0, methodPart.length() - 2);
&nbsp;        } else if (methodPart.endsWith(&quot;)&quot;)) {
&nbsp;            int indexOfLastOpeningParenthesis = methodPart.lastIndexOf(40);
&nbsp;            if (indexOfLastOpeningParenthesis &gt; 0 &amp;&amp; indexOfLastOpeningParenthesis &lt; methodPart.length() - 1) {
&nbsp;                methodName = methodPart.substring(0, indexOfLastOpeningParenthesis);
&nbsp;                methodParameters = methodPart.substring(indexOfLastOpeningParenthesis + 1, methodPart.length() - 1);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        return new String[]{className, methodName, methodParameters};
&nbsp;    }
&nbsp;
&nbsp;    /** @deprecated */
&nbsp;    @API(
&nbsp;        status = Status.DEPRECATED,
&nbsp;        since = &quot;1.4&quot;
&nbsp;    )
&nbsp;    @Deprecated
&nbsp;    public static Optional&lt;Object&gt; getOutermostInstance(Object inner, Class&lt;?&gt; requiredType) {
&nbsp;        Preconditions.notNull(inner, &quot;inner object must not be null&quot;);
&nbsp;        Preconditions.notNull(requiredType, &quot;requiredType must not be null&quot;);
&nbsp;        if (requiredType.isInstance(inner)) {
&nbsp;            return Optional.of(inner);
&nbsp;        } else {
&nbsp;            Optional&lt;Object&gt; candidate = getOuterInstance(inner);
&nbsp;            return candidate.isPresent() ? getOutermostInstance(candidate.get(), requiredType) : Optional.empty();
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static Optional&lt;Object&gt; getOuterInstance(Object inner) {
&nbsp;        return Arrays.stream(inner.getClass().getDeclaredFields()).filter((field) -&gt; {
&nbsp;            return field.getName().startsWith(&quot;this$&quot;);
&nbsp;        }).findFirst().map((field) -&gt; {
&nbsp;            try {
&nbsp;                return ((Field)makeAccessible(field)).get(inner);
&nbsp;            } catch (Throwable var3) {
&nbsp;                throw ExceptionUtils.throwAsUncheckedException(var3);
&nbsp;            }
&nbsp;        });
&nbsp;    }
&nbsp;
&nbsp;    public static Set&lt;Path&gt; getAllClasspathRootDirectories() {
&nbsp;        String fullClassPath = System.getProperty(&quot;java.class.path&quot;);
&nbsp;        return (Set)Arrays.stream(fullClassPath.split(File.pathSeparator)).map((x$0) -&gt; {
&nbsp;            return Paths.get(x$0);
&nbsp;        }).filter((x$0) -&gt; {
&nbsp;            return Files.isDirectory(x$0, new LinkOption[0]);
&nbsp;        }).collect(Collectors.toSet());
&nbsp;    }
&nbsp;
&nbsp;    public static List&lt;Class&lt;?&gt;&gt; findAllClassesInClasspathRoot(URI root, Predicate&lt;Class&lt;?&gt;&gt; classFilter, Predicate&lt;String&gt; classNameFilter) {
&nbsp;        return findAllClassesInClasspathRoot(root, ClassFilter.of(classNameFilter, classFilter));
&nbsp;    }
&nbsp;
&nbsp;    public static List&lt;Class&lt;?&gt;&gt; findAllClassesInClasspathRoot(URI root, ClassFilter classFilter) {
&nbsp;        return Collections.unmodifiableList(classpathScanner.scanForClassesInClasspathRoot(root, classFilter));
&nbsp;    }
&nbsp;
&nbsp;    public static List&lt;Class&lt;?&gt;&gt; findAllClassesInPackage(String basePackageName, Predicate&lt;Class&lt;?&gt;&gt; classFilter, Predicate&lt;String&gt; classNameFilter) {
&nbsp;        return findAllClassesInPackage(basePackageName, ClassFilter.of(classNameFilter, classFilter));
&nbsp;    }
&nbsp;
&nbsp;    public static List&lt;Class&lt;?&gt;&gt; findAllClassesInPackage(String basePackageName, ClassFilter classFilter) {
&nbsp;        return Collections.unmodifiableList(classpathScanner.scanForClassesInPackage(basePackageName, classFilter));
&nbsp;    }
&nbsp;
&nbsp;    public static List&lt;Class&lt;?&gt;&gt; findAllClassesInModule(String moduleName, Predicate&lt;Class&lt;?&gt;&gt; classFilter, Predicate&lt;String&gt; classNameFilter) {
&nbsp;        return findAllClassesInModule(moduleName, ClassFilter.of(classNameFilter, classFilter));
&nbsp;    }
&nbsp;
&nbsp;    public static List&lt;Class&lt;?&gt;&gt; findAllClassesInModule(String moduleName, ClassFilter classFilter) {
&nbsp;        return Collections.unmodifiableList(ModuleUtils.findAllClassesInModule(moduleName, classFilter));
&nbsp;    }
&nbsp;
&nbsp;    public static List&lt;Class&lt;?&gt;&gt; findNestedClasses(Class&lt;?&gt; clazz, Predicate&lt;Class&lt;?&gt;&gt; predicate) {
&nbsp;        Preconditions.notNull(clazz, &quot;Class must not be null&quot;);
&nbsp;        Preconditions.notNull(predicate, &quot;Predicate must not be null&quot;);
&nbsp;        Set&lt;Class&lt;?&gt;&gt; candidates = new LinkedHashSet();
&nbsp;        findNestedClasses(clazz, predicate, candidates);
&nbsp;        return Collections.unmodifiableList(new ArrayList(candidates));
&nbsp;    }
&nbsp;
&nbsp;    private static void findNestedClasses(Class&lt;?&gt; clazz, Predicate&lt;Class&lt;?&gt;&gt; predicate, Set&lt;Class&lt;?&gt;&gt; candidates) {
&nbsp;        if (isSearchable(clazz)) {
&nbsp;            if (isInnerClass(clazz) &amp;&amp; predicate.test(clazz)) {
&nbsp;                detectInnerClassCycle(clazz);
&nbsp;            }
&nbsp;
&nbsp;            Class[] var3;
&nbsp;            int var4;
&nbsp;            int var5;
&nbsp;            Class nestedClass;
&nbsp;            try {
&nbsp;                var3 = clazz.getDeclaredClasses();
&nbsp;                var4 = var3.length;
&nbsp;
&nbsp;                for(var5 = 0; var5 &lt; var4; ++var5) {
&nbsp;                    nestedClass = var3[var5];
&nbsp;                    if (predicate.test(nestedClass)) {
&nbsp;                        detectInnerClassCycle(nestedClass);
&nbsp;                        candidates.add(nestedClass);
&nbsp;                    }
&nbsp;                }
&nbsp;            } catch (NoClassDefFoundError var7) {
&nbsp;                logger.debug(var7, () -&gt; {
&nbsp;                    return &quot;Failed to retrieve declared classes for &quot; + clazz.getName();
&nbsp;                });
&nbsp;            }
&nbsp;
&nbsp;            findNestedClasses(clazz.getSuperclass(), predicate, candidates);
&nbsp;            var3 = clazz.getInterfaces();
&nbsp;            var4 = var3.length;
&nbsp;
&nbsp;            for(var5 = 0; var5 &lt; var4; ++var5) {
&nbsp;                nestedClass = var3[var5];
&nbsp;                findNestedClasses(nestedClass, predicate, candidates);
&nbsp;            }
&nbsp;
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static void detectInnerClassCycle(Class&lt;?&gt; clazz) {
&nbsp;        Preconditions.notNull(clazz, &quot;Class must not be null&quot;);
&nbsp;        String className = clazz.getName();
&nbsp;        if (!noCyclesDetectedCache.contains(className)) {
&nbsp;            Class&lt;?&gt; superclass = clazz.getSuperclass();
&nbsp;            if (isInnerClass(clazz) &amp;&amp; isSearchable(superclass)) {
&nbsp;                for(Class&lt;?&gt; enclosing = clazz.getEnclosingClass(); enclosing != null; enclosing = enclosing.getEnclosingClass()) {
&nbsp;                    if (superclass.equals(enclosing)) {
&nbsp;                        throw new JUnitException(String.format(&quot;Detected cycle in inner class hierarchy between %s and %s&quot;, className, enclosing.getName()));
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            noCyclesDetectedCache.add(className);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static &lt;T&gt; Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;T&gt; clazz) {
&nbsp;        Preconditions.notNull(clazz, &quot;Class must not be null&quot;);
&nbsp;
&nbsp;        try {
&nbsp;            List&lt;Constructor&lt;?&gt;&gt; constructors = (List)Arrays.stream(clazz.getDeclaredConstructors()).filter((ctor) -&gt; {
&nbsp;                return !ctor.isSynthetic();
&nbsp;            }).collect(Collectors.toList());
&nbsp;            Preconditions.condition(constructors.size() == 1, () -&gt; {
&nbsp;                return String.format(&quot;Class [%s] must declare a single constructor&quot;, clazz.getName());
&nbsp;            });
&nbsp;            return (Constructor)constructors.get(0);
&nbsp;        } catch (Throwable var2) {
&nbsp;            throw ExceptionUtils.throwAsUncheckedException(getUnderlyingCause(var2));
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static List&lt;Constructor&lt;?&gt;&gt; findConstructors(Class&lt;?&gt; clazz, Predicate&lt;Constructor&lt;?&gt;&gt; predicate) {
&nbsp;        Preconditions.notNull(clazz, &quot;Class must not be null&quot;);
&nbsp;        Preconditions.notNull(predicate, &quot;Predicate must not be null&quot;);
&nbsp;
&nbsp;        try {
&nbsp;            return (List)Arrays.stream(clazz.getDeclaredConstructors()).filter(predicate).collect(CollectionUtils.toUnmodifiableList());
&nbsp;        } catch (Throwable var3) {
&nbsp;            throw ExceptionUtils.throwAsUncheckedException(getUnderlyingCause(var3));
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static List&lt;Field&gt; findFields(Class&lt;?&gt; clazz, Predicate&lt;Field&gt; predicate, HierarchyTraversalMode traversalMode) {
&nbsp;        Preconditions.notNull(clazz, &quot;Class must not be null&quot;);
&nbsp;        Preconditions.notNull(predicate, &quot;Predicate must not be null&quot;);
&nbsp;        Preconditions.notNull(traversalMode, &quot;HierarchyTraversalMode must not be null&quot;);
&nbsp;        return (List)findAllFieldsInHierarchy(clazz, traversalMode).stream().filter(predicate).collect(CollectionUtils.toUnmodifiableList());
&nbsp;    }
&nbsp;
&nbsp;    private static List&lt;Field&gt; findAllFieldsInHierarchy(Class&lt;?&gt; clazz, HierarchyTraversalMode traversalMode) {
&nbsp;        Preconditions.notNull(clazz, &quot;Class must not be null&quot;);
&nbsp;        Preconditions.notNull(traversalMode, &quot;HierarchyTraversalMode must not be null&quot;);
&nbsp;        List&lt;Field&gt; localFields = (List)getDeclaredFields(clazz).stream().filter((field) -&gt; {
&nbsp;            return !field.isSynthetic();
&nbsp;        }).collect(Collectors.toList());
&nbsp;        List&lt;Field&gt; superclassFields = (List)getSuperclassFields(clazz, traversalMode).stream().filter((field) -&gt; {
&nbsp;            return !isFieldShadowedByLocalFields(field, localFields);
&nbsp;        }).collect(Collectors.toList());
&nbsp;        List&lt;Field&gt; interfaceFields = (List)getInterfaceFields(clazz, traversalMode).stream().filter((field) -&gt; {
&nbsp;            return !isFieldShadowedByLocalFields(field, localFields);
&nbsp;        }).collect(Collectors.toList());
&nbsp;        List&lt;Field&gt; fields = new ArrayList();
&nbsp;        if (traversalMode == ReflectionUtils.HierarchyTraversalMode.TOP_DOWN) {
&nbsp;            fields.addAll(superclassFields);
&nbsp;            fields.addAll(interfaceFields);
&nbsp;        }
&nbsp;
&nbsp;        fields.addAll(localFields);
&nbsp;        if (traversalMode == ReflectionUtils.HierarchyTraversalMode.BOTTOM_UP) {
&nbsp;            fields.addAll(interfaceFields);
&nbsp;            fields.addAll(superclassFields);
&nbsp;        }
&nbsp;
&nbsp;        return fields;
&nbsp;    }
&nbsp;
&nbsp;    public static boolean isMethodPresent(Class&lt;?&gt; clazz, Predicate&lt;Method&gt; predicate) {
&nbsp;        Preconditions.notNull(clazz, &quot;Class must not be null&quot;);
&nbsp;        Preconditions.notNull(predicate, &quot;Predicate must not be null&quot;);
&nbsp;        return findMethod(clazz, predicate).isPresent();
&nbsp;    }
&nbsp;
&nbsp;    /** @deprecated */
&nbsp;    @API(
&nbsp;        status = Status.DEPRECATED,
&nbsp;        since = &quot;1.4&quot;
&nbsp;    )
&nbsp;    @Deprecated
&nbsp;    static Optional&lt;Method&gt; getMethod(Class&lt;?&gt; clazz, String methodName, Class&lt;?&gt;... parameterTypes) {
&nbsp;        return tryToGetMethod(clazz, methodName, parameterTypes).toOptional();
&nbsp;    }
&nbsp;
&nbsp;    @API(
&nbsp;        status = Status.INTERNAL,
&nbsp;        since = &quot;1.4&quot;
&nbsp;    )
&nbsp;    public static Try&lt;Method&gt; tryToGetMethod(Class&lt;?&gt; clazz, String methodName, Class&lt;?&gt;... parameterTypes) {
&nbsp;        Preconditions.notNull(clazz, &quot;Class must not be null&quot;);
&nbsp;        Preconditions.notBlank(methodName, &quot;Method name must not be null or blank&quot;);
&nbsp;        return Try.call(() -&gt; {
&nbsp;            return clazz.getMethod(methodName, parameterTypes);
&nbsp;        });
&nbsp;    }
&nbsp;
&nbsp;    public static Optional&lt;Method&gt; findMethod(Class&lt;?&gt; clazz, String methodName, String parameterTypeNames) {
&nbsp;        Preconditions.notNull(clazz, &quot;Class must not be null&quot;);
&nbsp;        Preconditions.notBlank(methodName, &quot;Method name must not be null or blank&quot;);
&nbsp;        return findMethod(clazz, methodName, resolveParameterTypes(clazz, methodName, parameterTypeNames));
&nbsp;    }
&nbsp;
&nbsp;    private static Class&lt;?&gt;[] resolveParameterTypes(Class&lt;?&gt; clazz, String methodName, String parameterTypeNames) {
&nbsp;        return StringUtils.isBlank(parameterTypeNames) ? EMPTY_CLASS_ARRAY : (Class[])Arrays.stream(parameterTypeNames.split(&quot;,&quot;)).map(String::trim).map((typeName) -&gt; {
&nbsp;            return loadRequiredParameterType(clazz, methodName, typeName);
&nbsp;        }).toArray((x$0) -&gt; {
&nbsp;            return new Class[x$0];
&nbsp;        });
&nbsp;    }
&nbsp;
&nbsp;    private static Class&lt;?&gt; loadRequiredParameterType(Class&lt;?&gt; clazz, String methodName, String typeName) {
&nbsp;        return (Class)tryToLoadClass(typeName).getOrThrow((cause) -&gt; {
&nbsp;            return new JUnitException(String.format(&quot;Failed to load parameter type [%s] for method [%s] in class [%s].&quot;, typeName, methodName, clazz.getName()), cause);
&nbsp;        });
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    public static Optional&lt;Method&gt; findMethod(Class&lt;?&gt; clazz, String methodName, Class&lt;?&gt;... parameterTypes) {</b>
<b class="fc">&nbsp;        Preconditions.notNull(clazz, &quot;Class must not be null&quot;);</b>
&nbsp;        Preconditions.notBlank(methodName, &quot;Method name must not be null or blank&quot;);
&nbsp;        Preconditions.notNull(parameterTypes, &quot;Parameter types array must not be null&quot;);
&nbsp;        Preconditions.containsNoNullElements(parameterTypes, &quot;Individual parameter types must not be null&quot;);
<b class="fc">&nbsp;        return findMethod(clazz, (method) -&gt; {</b>
&nbsp;            return hasCompatibleSignature(method, methodName, parameterTypes);
&nbsp;        });
&nbsp;    }
&nbsp;
&nbsp;    private static Optional&lt;Method&gt; findMethod(Class&lt;?&gt; clazz, Predicate&lt;Method&gt; predicate) {
&nbsp;        Preconditions.notNull(clazz, &quot;Class must not be null&quot;);
&nbsp;        Preconditions.notNull(predicate, &quot;Predicate must not be null&quot;);
&nbsp;
&nbsp;        for(Class&lt;?&gt; current = clazz; isSearchable(current); current = current.getSuperclass()) {
&nbsp;            List&lt;Method&gt; methods = current.isInterface() ? getMethods(current) : getDeclaredMethods(current, ReflectionUtils.HierarchyTraversalMode.BOTTOM_UP);
&nbsp;            Iterator var4 = methods.iterator();
&nbsp;
&nbsp;            while(var4.hasNext()) {
&nbsp;                Method method = (Method)var4.next();
&nbsp;                if (predicate.test(method)) {
&nbsp;                    return Optional.of(method);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            Class[] var9 = current.getInterfaces();
&nbsp;            int var10 = var9.length;
&nbsp;
&nbsp;            for(int var6 = 0; var6 &lt; var10; ++var6) {
&nbsp;                Class&lt;?&gt; ifc = var9[var6];
&nbsp;                Optional&lt;Method&gt; optional = findMethod(ifc, predicate);
&nbsp;                if (optional.isPresent()) {
&nbsp;                    return optional;
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        return Optional.empty();
&nbsp;    }
&nbsp;
&nbsp;    @API(
&nbsp;        status = Status.STABLE,
&nbsp;        since = &quot;1.7&quot;
&nbsp;    )
&nbsp;    public static Method getRequiredMethod(Class&lt;?&gt; clazz, String methodName, Class&lt;?&gt;... parameterTypes) {
&nbsp;        return (Method)findMethod(clazz, methodName, parameterTypes).orElseThrow(() -&gt; {
&nbsp;            return new JUnitException(String.format(&quot;Could not find method [%s] in class [%s]&quot;, methodName, clazz.getName()));
&nbsp;        });
&nbsp;    }
&nbsp;
&nbsp;    public static List&lt;Method&gt; findMethods(Class&lt;?&gt; clazz, Predicate&lt;Method&gt; predicate) {
&nbsp;        return findMethods(clazz, predicate, ReflectionUtils.HierarchyTraversalMode.TOP_DOWN);
&nbsp;    }
&nbsp;
&nbsp;    public static List&lt;Method&gt; findMethods(Class&lt;?&gt; clazz, Predicate&lt;Method&gt; predicate, HierarchyTraversalMode traversalMode) {
&nbsp;        Preconditions.notNull(clazz, &quot;Class must not be null&quot;);
&nbsp;        Preconditions.notNull(predicate, &quot;Predicate must not be null&quot;);
&nbsp;        Preconditions.notNull(traversalMode, &quot;HierarchyTraversalMode must not be null&quot;);
&nbsp;        return (List)findAllMethodsInHierarchy(clazz, traversalMode).stream().filter(predicate).collect(CollectionUtils.toUnmodifiableList());
&nbsp;    }
&nbsp;
&nbsp;    private static List&lt;Method&gt; findAllMethodsInHierarchy(Class&lt;?&gt; clazz, HierarchyTraversalMode traversalMode) {
&nbsp;        Preconditions.notNull(clazz, &quot;Class must not be null&quot;);
&nbsp;        Preconditions.notNull(traversalMode, &quot;HierarchyTraversalMode must not be null&quot;);
&nbsp;        List&lt;Method&gt; localMethods = (List)getDeclaredMethods(clazz, traversalMode).stream().filter((method) -&gt; {
&nbsp;            return !method.isSynthetic();
&nbsp;        }).collect(Collectors.toList());
&nbsp;        List&lt;Method&gt; superclassMethods = (List)getSuperclassMethods(clazz, traversalMode).stream().filter((method) -&gt; {
&nbsp;            return !isMethodShadowedByLocalMethods(method, localMethods);
&nbsp;        }).collect(Collectors.toList());
&nbsp;        List&lt;Method&gt; interfaceMethods = (List)getInterfaceMethods(clazz, traversalMode).stream().filter((method) -&gt; {
&nbsp;            return !isMethodShadowedByLocalMethods(method, localMethods);
&nbsp;        }).collect(Collectors.toList());
&nbsp;        List&lt;Method&gt; methods = new ArrayList();
&nbsp;        if (traversalMode == ReflectionUtils.HierarchyTraversalMode.TOP_DOWN) {
&nbsp;            methods.addAll(superclassMethods);
&nbsp;            methods.addAll(interfaceMethods);
&nbsp;        }
&nbsp;
&nbsp;        methods.addAll(localMethods);
&nbsp;        if (traversalMode == ReflectionUtils.HierarchyTraversalMode.BOTTOM_UP) {
&nbsp;            methods.addAll(interfaceMethods);
&nbsp;            methods.addAll(superclassMethods);
&nbsp;        }
&nbsp;
&nbsp;        return methods;
&nbsp;    }
&nbsp;
&nbsp;    private static List&lt;Field&gt; getFields(Class&lt;?&gt; clazz) {
&nbsp;        return toSortedMutableList(clazz.getFields());
&nbsp;    }
&nbsp;
&nbsp;    private static List&lt;Field&gt; getDeclaredFields(Class&lt;?&gt; clazz) {
&nbsp;        return toSortedMutableList(clazz.getDeclaredFields());
&nbsp;    }
&nbsp;
&nbsp;    private static List&lt;Method&gt; getMethods(Class&lt;?&gt; clazz) {
&nbsp;        return toSortedMutableList(clazz.getMethods());
&nbsp;    }
&nbsp;
&nbsp;    private static List&lt;Method&gt; getDeclaredMethods(Class&lt;?&gt; clazz, HierarchyTraversalMode traversalMode) {
&nbsp;        List&lt;Method&gt; defaultMethods = getDefaultMethods(clazz);
&nbsp;        List&lt;Method&gt; declaredMethods = toSortedMutableList(clazz.getDeclaredMethods());
&nbsp;        if (traversalMode == ReflectionUtils.HierarchyTraversalMode.BOTTOM_UP) {
&nbsp;            declaredMethods.addAll(defaultMethods);
&nbsp;            return declaredMethods;
&nbsp;        } else {
&nbsp;            defaultMethods.addAll(declaredMethods);
&nbsp;            return defaultMethods;
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static List&lt;Method&gt; getDefaultMethods(Class&lt;?&gt; clazz) {
&nbsp;        List&lt;Method&gt; visibleDefaultMethods = (List)Arrays.stream(clazz.getMethods()).filter(Method::isDefault).collect(Collectors.toCollection(ArrayList::new));
&nbsp;        if (visibleDefaultMethods.isEmpty()) {
&nbsp;            return visibleDefaultMethods;
&nbsp;        } else {
&nbsp;            Stream var10000 = Arrays.stream(clazz.getInterfaces()).map(ReflectionUtils::getMethods).flatMap(Collection::stream);
&nbsp;            Objects.requireNonNull(visibleDefaultMethods);
&nbsp;            return (List)var10000.filter(visibleDefaultMethods::contains).collect(Collectors.toCollection(ArrayList::new));
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static List&lt;Field&gt; toSortedMutableList(Field[] fields) {
&nbsp;        return (List)Arrays.stream(fields).sorted(ReflectionUtils::defaultFieldSorter).collect(Collectors.toCollection(ArrayList::new));
&nbsp;    }
&nbsp;
&nbsp;    private static List&lt;Method&gt; toSortedMutableList(Method[] methods) {
&nbsp;        return (List)Arrays.stream(methods).sorted(ReflectionUtils::defaultMethodSorter).collect(Collectors.toCollection(ArrayList::new));
&nbsp;    }
&nbsp;
&nbsp;    private static int defaultFieldSorter(Field field1, Field field2) {
&nbsp;        return Integer.compare(field1.getName().hashCode(), field2.getName().hashCode());
&nbsp;    }
&nbsp;
&nbsp;    private static int defaultMethodSorter(Method method1, Method method2) {
&nbsp;        String name1 = method1.getName();
&nbsp;        String name2 = method2.getName();
&nbsp;        int comparison = Integer.compare(name1.hashCode(), name2.hashCode());
&nbsp;        if (comparison == 0) {
&nbsp;            comparison = name1.compareTo(name2);
&nbsp;            if (comparison == 0) {
&nbsp;                comparison = method1.toString().compareTo(method2.toString());
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        return comparison;
&nbsp;    }
&nbsp;
&nbsp;    private static List&lt;Method&gt; getInterfaceMethods(Class&lt;?&gt; clazz, HierarchyTraversalMode traversalMode) {
&nbsp;        List&lt;Method&gt; allInterfaceMethods = new ArrayList();
&nbsp;        Class[] var3 = clazz.getInterfaces();
&nbsp;        int var4 = var3.length;
&nbsp;
&nbsp;        for(int var5 = 0; var5 &lt; var4; ++var5) {
&nbsp;            Class&lt;?&gt; ifc = var3[var5];
&nbsp;            List&lt;Method&gt; localInterfaceMethods = (List)getMethods(ifc).stream().filter((m) -&gt; {
&nbsp;                return !isAbstract((Member)m);
&nbsp;            }).collect(Collectors.toList());
&nbsp;            List&lt;Method&gt; superinterfaceMethods = (List)getInterfaceMethods(ifc, traversalMode).stream().filter((method) -&gt; {
&nbsp;                return !isMethodShadowedByLocalMethods(method, localInterfaceMethods);
&nbsp;            }).collect(Collectors.toList());
&nbsp;            if (traversalMode == ReflectionUtils.HierarchyTraversalMode.TOP_DOWN) {
&nbsp;                allInterfaceMethods.addAll(superinterfaceMethods);
&nbsp;            }
&nbsp;
&nbsp;            allInterfaceMethods.addAll(localInterfaceMethods);
&nbsp;            if (traversalMode == ReflectionUtils.HierarchyTraversalMode.BOTTOM_UP) {
&nbsp;                allInterfaceMethods.addAll(superinterfaceMethods);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        return allInterfaceMethods;
&nbsp;    }
&nbsp;
&nbsp;    private static List&lt;Field&gt; getInterfaceFields(Class&lt;?&gt; clazz, HierarchyTraversalMode traversalMode) {
&nbsp;        List&lt;Field&gt; allInterfaceFields = new ArrayList();
&nbsp;        Class[] var3 = clazz.getInterfaces();
&nbsp;        int var4 = var3.length;
&nbsp;
&nbsp;        for(int var5 = 0; var5 &lt; var4; ++var5) {
&nbsp;            Class&lt;?&gt; ifc = var3[var5];
&nbsp;            List&lt;Field&gt; localInterfaceFields = getFields(ifc);
&nbsp;            List&lt;Field&gt; superinterfaceFields = (List)getInterfaceFields(ifc, traversalMode).stream().filter((field) -&gt; {
&nbsp;                return !isFieldShadowedByLocalFields(field, localInterfaceFields);
&nbsp;            }).collect(Collectors.toList());
&nbsp;            if (traversalMode == ReflectionUtils.HierarchyTraversalMode.TOP_DOWN) {
&nbsp;                allInterfaceFields.addAll(superinterfaceFields);
&nbsp;            }
&nbsp;
&nbsp;            allInterfaceFields.addAll(localInterfaceFields);
&nbsp;            if (traversalMode == ReflectionUtils.HierarchyTraversalMode.BOTTOM_UP) {
&nbsp;                allInterfaceFields.addAll(superinterfaceFields);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        return allInterfaceFields;
&nbsp;    }
&nbsp;
&nbsp;    private static List&lt;Field&gt; getSuperclassFields(Class&lt;?&gt; clazz, HierarchyTraversalMode traversalMode) {
&nbsp;        Class&lt;?&gt; superclass = clazz.getSuperclass();
&nbsp;        return !isSearchable(superclass) ? Collections.emptyList() : findAllFieldsInHierarchy(superclass, traversalMode);
&nbsp;    }
&nbsp;
&nbsp;    private static boolean isFieldShadowedByLocalFields(Field field, List&lt;Field&gt; localFields) {
&nbsp;        return localFields.stream().anyMatch((local) -&gt; {
&nbsp;            return local.getName().equals(field.getName());
&nbsp;        });
&nbsp;    }
&nbsp;
&nbsp;    private static List&lt;Method&gt; getSuperclassMethods(Class&lt;?&gt; clazz, HierarchyTraversalMode traversalMode) {
&nbsp;        Class&lt;?&gt; superclass = clazz.getSuperclass();
&nbsp;        return !isSearchable(superclass) ? Collections.emptyList() : findAllMethodsInHierarchy(superclass, traversalMode);
&nbsp;    }
&nbsp;
&nbsp;    private static boolean isMethodShadowedByLocalMethods(Method method, List&lt;Method&gt; localMethods) {
&nbsp;        return localMethods.stream().anyMatch((local) -&gt; {
&nbsp;            return isMethodShadowedBy(method, local);
&nbsp;        });
&nbsp;    }
&nbsp;
&nbsp;    private static boolean isMethodShadowedBy(Method upper, Method lower) {
&nbsp;        return hasCompatibleSignature(upper, lower.getName(), lower.getParameterTypes());
&nbsp;    }
&nbsp;
&nbsp;    private static boolean hasCompatibleSignature(Method candidate, String methodName, Class&lt;?&gt;[] parameterTypes) {
&nbsp;        if (!methodName.equals(candidate.getName())) {
&nbsp;            return false;
&nbsp;        } else if (parameterTypes.length != candidate.getParameterCount()) {
&nbsp;            return false;
&nbsp;        } else if (Arrays.equals(parameterTypes, candidate.getParameterTypes())) {
&nbsp;            return true;
&nbsp;        } else {
&nbsp;            for(int i = 0; i &lt; parameterTypes.length; ++i) {
&nbsp;                Class&lt;?&gt; lowerType = parameterTypes[i];
&nbsp;                Class&lt;?&gt; upperType = candidate.getParameterTypes()[i];
&nbsp;                if (!upperType.isAssignableFrom(lowerType)) {
&nbsp;                    return false;
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            if (isGeneric(candidate)) {
&nbsp;                return true;
&nbsp;            } else {
&nbsp;                return false;
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    static boolean isGeneric(Method method) {
&nbsp;        return isGeneric(method.getGenericReturnType()) || Arrays.stream(method.getGenericParameterTypes()).anyMatch(ReflectionUtils::isGeneric);
&nbsp;    }
&nbsp;
&nbsp;    private static boolean isGeneric(Type type) {
&nbsp;        return type instanceof TypeVariable || type instanceof GenericArrayType;
&nbsp;    }
&nbsp;
&nbsp;    public static &lt;T extends AccessibleObject&gt; T makeAccessible(T object) {
&nbsp;        if (!object.isAccessible()) {
&nbsp;            object.setAccessible(true);
&nbsp;        }
&nbsp;
&nbsp;        return object;
&nbsp;    }
&nbsp;
&nbsp;    public static Set&lt;Class&lt;?&gt;&gt; getAllAssignmentCompatibleClasses(Class&lt;?&gt; clazz) {
&nbsp;        Preconditions.notNull(clazz, &quot;Class must not be null&quot;);
&nbsp;        Set&lt;Class&lt;?&gt;&gt; result = new LinkedHashSet();
&nbsp;        getAllAssignmentCompatibleClasses(clazz, result);
&nbsp;        return result;
&nbsp;    }
&nbsp;
&nbsp;    private static void getAllAssignmentCompatibleClasses(Class&lt;?&gt; clazz, Set&lt;Class&lt;?&gt;&gt; result) {
&nbsp;        for(Class&lt;?&gt; current = clazz; current != null; current = current.getSuperclass()) {
&nbsp;            result.add(current);
&nbsp;            Class[] var3 = current.getInterfaces();
&nbsp;            int var4 = var3.length;
&nbsp;
&nbsp;            for(int var5 = 0; var5 &lt; var4; ++var5) {
&nbsp;                Class&lt;?&gt; interfaceClass = var3[var5];
&nbsp;                if (!result.contains(interfaceClass)) {
&nbsp;                    getAllAssignmentCompatibleClasses(interfaceClass, result);
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    private static boolean isSearchable(Class&lt;?&gt; clazz) {
&nbsp;        return clazz != null &amp;&amp; clazz != Object.class;
&nbsp;    }
&nbsp;
&nbsp;    private static Throwable getUnderlyingCause(Throwable t) {
&nbsp;        return t instanceof InvocationTargetException ? getUnderlyingCause(((InvocationTargetException)t).getTargetException()) : t;
&nbsp;    }
&nbsp;
&nbsp;    static {
&nbsp;        List&lt;Class&lt;?&gt;&gt; commonTypes = Arrays.asList(Boolean.TYPE, Byte.TYPE, Character.TYPE, Short.TYPE, Integer.TYPE, Long.TYPE, Float.TYPE, Double.TYPE, boolean[].class, byte[].class, char[].class, short[].class, int[].class, long[].class, float[].class, double[].class, boolean[][].class, byte[][].class, char[][].class, short[][].class, int[][].class, long[][].class, float[][].class, double[][].class, Boolean.class, Byte.class, Character.class, Short.class, Integer.class, Long.class, Float.class, Double.class, String.class, Boolean[].class, Byte[].class, Character[].class, Short[].class, Integer[].class, Long[].class, Float[].class, Double[].class, String[].class, Boolean[][].class, Byte[][].class, Character[][].class, Short[][].class, Integer[][].class, Long[][].class, Float[][].class, Double[][].class, String[][].class);
&nbsp;        Map&lt;String, Class&lt;?&gt;&gt; classNamesToTypes = new HashMap(64);
&nbsp;        commonTypes.forEach((type) -&gt; {
&nbsp;            classNamesToTypes.put(type.getName(), type);
&nbsp;            classNamesToTypes.put(type.getCanonicalName(), type);
&nbsp;        });
&nbsp;        classNameToTypeMap = Collections.unmodifiableMap(classNamesToTypes);
&nbsp;        Map&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt; primitivesToWrappers = new IdentityHashMap(8);
&nbsp;        primitivesToWrappers.put(Boolean.TYPE, Boolean.class);
&nbsp;        primitivesToWrappers.put(Byte.TYPE, Byte.class);
&nbsp;        primitivesToWrappers.put(Character.TYPE, Character.class);
&nbsp;        primitivesToWrappers.put(Short.TYPE, Short.class);
&nbsp;        primitivesToWrappers.put(Integer.TYPE, Integer.class);
&nbsp;        primitivesToWrappers.put(Long.TYPE, Long.class);
&nbsp;        primitivesToWrappers.put(Float.TYPE, Float.class);
&nbsp;        primitivesToWrappers.put(Double.TYPE, Double.class);
&nbsp;        primitiveToWrapperMap = Collections.unmodifiableMap(primitivesToWrappers);
&nbsp;    }
&nbsp;
&nbsp;    public static enum HierarchyTraversalMode {
&nbsp;        TOP_DOWN,
&nbsp;        BOTTOM_UP;
&nbsp;
&nbsp;        private HierarchyTraversalMode() {
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-22 12:48</div>
</div>
</body>
</html>
