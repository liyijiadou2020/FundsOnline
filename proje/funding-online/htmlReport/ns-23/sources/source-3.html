


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=GBK"> 
  <title>Coverage Report > TypeDescription</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.description.type</a>
</div>

<h1>Coverage Summary for Class: TypeDescription (net.bytebuddy.description.type)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">TypeDescription</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
</tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (68/68)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$OfSimpleType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$ForLoadedType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (53/53)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$Delegator</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$Delegator$Chained</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$Delegator$ForLoadedExecutableExceptionType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$Delegator$ForLoadedExecutableParameterType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$Delegator$ForLoadedMethodReturnType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$Delegator$Simple</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$ForComponentType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$ForTypeArgument</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$NoOp</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$LazyProjection</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (11/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$LazyProjection$ForLoadedReturnType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$LazyProjection$ForLoadedSuperClass</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$LazyProjection$OfMethodParameter</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$LazyProjection$WithEagerNavigation</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$LazyProjection$WithEagerNavigation$OfAnnotatedElement</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$LazyProjection$WithResolvedErasure</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (18/18)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType$ForErasure</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType$ForLoadedType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (33/33)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfParameterizedType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (11/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfParameterizedType$ForGenerifiedErasure</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfParameterizedType$ForLoadedType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (8/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfParameterizedType$ForLoadedType$ParameterArgumentTypeList</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfParameterizedType$Latent</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$ForRawType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$ForSignatureVisitor</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (17/17)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$ForSignatureVisitor$OfTypeArgument</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$Reducing</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$Reifying</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$Reifying$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$Reifying$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$Substitutor</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$Substitutor$ForAttachment</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$Substitutor$ForDetachment</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$Substitutor$WithoutTypeSubstitution</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (54/54)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (365/365)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;//
&nbsp;// Source code recreated from a .class file by IntelliJ IDEA
&nbsp;// (powered by FernFlower decompiler)
&nbsp;//
&nbsp;
&nbsp;package net.bytebuddy.description.type;
&nbsp;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import java.io.Serializable;
&nbsp;import java.lang.annotation.Annotation;
&nbsp;import java.lang.annotation.ElementType;
&nbsp;import java.lang.reflect.AccessibleObject;
&nbsp;import java.lang.reflect.AnnotatedElement;
&nbsp;import java.lang.reflect.Constructor;
&nbsp;import java.lang.reflect.Field;
&nbsp;import java.lang.reflect.GenericArrayType;
&nbsp;import java.lang.reflect.GenericDeclaration;
&nbsp;import java.lang.reflect.GenericSignatureFormatError;
&nbsp;import java.lang.reflect.Method;
&nbsp;import java.lang.reflect.ParameterizedType;
&nbsp;import java.lang.reflect.Type;
&nbsp;import java.lang.reflect.TypeVariable;
&nbsp;import java.lang.reflect.WildcardType;
&nbsp;import java.security.AccessController;
&nbsp;import java.security.PrivilegedAction;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Collection;
&nbsp;import java.util.Collections;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.Iterator;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Set;
&nbsp;import javax.annotation.CheckForNull;
&nbsp;import javax.annotation.Nonnull;
&nbsp;import javax.annotation.meta.When;
&nbsp;import net.bytebuddy.ClassFileVersion;
&nbsp;import net.bytebuddy.build.CachedReturnPlugin.Enhance;
&nbsp;import net.bytebuddy.build.HashCodeAndEqualsPlugin.ValueHandling;
&nbsp;import net.bytebuddy.description.ByteCodeElement;
&nbsp;import net.bytebuddy.description.ModifierReviewable;
&nbsp;import net.bytebuddy.description.TypeVariableSource;
&nbsp;import net.bytebuddy.description.annotation.AnnotationDescription;
&nbsp;import net.bytebuddy.description.annotation.AnnotationList;
&nbsp;import net.bytebuddy.description.annotation.AnnotationSource;
&nbsp;import net.bytebuddy.description.annotation.AnnotationSource.Empty;
&nbsp;import net.bytebuddy.description.enumeration.EnumerationDescription;
&nbsp;import net.bytebuddy.description.field.FieldDescription;
&nbsp;import net.bytebuddy.description.field.FieldList;
&nbsp;import net.bytebuddy.description.method.MethodDescription;
&nbsp;import net.bytebuddy.description.method.MethodList;
&nbsp;import net.bytebuddy.description.method.ParameterDescription;
&nbsp;import net.bytebuddy.description.type.TypeDefinition.Sort;
&nbsp;import net.bytebuddy.description.type.TypeList.Generic.ForLoadedTypes.OfTypeVariables;
&nbsp;import net.bytebuddy.dynamic.TargetType;
&nbsp;import net.bytebuddy.implementation.bytecode.StackSize;
&nbsp;import net.bytebuddy.jar.asm.signature.SignatureVisitor;
&nbsp;import net.bytebuddy.jar.asm.signature.SignatureWriter;
&nbsp;import net.bytebuddy.matcher.ElementMatcher;
&nbsp;import net.bytebuddy.matcher.ElementMatchers;
&nbsp;import net.bytebuddy.utility.CompoundList;
&nbsp;import net.bytebuddy.utility.JavaType;
&nbsp;import net.bytebuddy.utility.dispatcher.JavaDispatcher;
&nbsp;import net.bytebuddy.utility.dispatcher.JavaDispatcher.Defaults;
<b class="fc">&nbsp;import net.bytebuddy.utility.dispatcher.JavaDispatcher.Instance;</b>
&nbsp;import net.bytebuddy.utility.dispatcher.JavaDispatcher.Proxied;
&nbsp;import net.bytebuddy.utility.privilege.GetSystemPropertyAction;
&nbsp;
&nbsp;public interface TypeDescription extends TypeDefinition, ByteCodeElement, TypeVariableSource {
<b class="fc">&nbsp;    TypeDescription OBJECT = new ForLoadedType(Object.class);</b>
&nbsp;    TypeDescription STRING = new ForLoadedType(String.class);
&nbsp;    TypeDescription CLASS = new ForLoadedType(Class.class);
&nbsp;    TypeDescription THROWABLE = new ForLoadedType(Throwable.class);
&nbsp;    TypeDescription VOID = new ForLoadedType(Void.TYPE);
<b class="fc">&nbsp;    TypeList.Generic ARRAY_INTERFACES = new TypeList.Generic.ForLoadedTypes(new Type[]{Cloneable.class, Serializable.class});</b>
&nbsp;    @Nonnull(
&nbsp;        when = When.NEVER
&nbsp;    )
&nbsp;    TypeDescription UNDEFINED = null;
<b class="fc">&nbsp;</b>
&nbsp;    FieldList&lt;FieldDescription.InDefinedShape&gt; getDeclaredFields();
&nbsp;
&nbsp;    MethodList&lt;MethodDescription.InDefinedShape&gt; getDeclaredMethods();
&nbsp;
<b class="fc">&nbsp;    RecordComponentList&lt;RecordComponentDescription.InDefinedShape&gt; getRecordComponents();</b>
&nbsp;
&nbsp;    boolean isInstance(Object var1);
&nbsp;
&nbsp;    boolean isAssignableFrom(Class&lt;?&gt; var1);
<b class="fc">&nbsp;</b>
&nbsp;    boolean isAssignableFrom(TypeDescription var1);
&nbsp;
&nbsp;    boolean isAssignableTo(Class&lt;?&gt; var1);
&nbsp;
&nbsp;    boolean isAssignableTo(TypeDescription var1);
&nbsp;
<b class="fc">&nbsp;    boolean isInHierarchyWith(Class&lt;?&gt; var1);</b>
&nbsp;
&nbsp;    boolean isInHierarchyWith(TypeDescription var1);
&nbsp;
&nbsp;    @Nonnull(
&nbsp;        when = When.MAYBE
&nbsp;    )
&nbsp;    TypeDescription getComponentType();
&nbsp;
&nbsp;    @Nonnull(
&nbsp;        when = When.MAYBE
&nbsp;    )
&nbsp;    TypeDescription getDeclaringType();
&nbsp;
&nbsp;    TypeList getDeclaredTypes();
&nbsp;
&nbsp;    @Nonnull(
&nbsp;        when = When.MAYBE
&nbsp;    )
&nbsp;    MethodDescription.InDefinedShape getEnclosingMethod();
&nbsp;
&nbsp;    @Nonnull(
&nbsp;        when = When.MAYBE
&nbsp;    )
&nbsp;    TypeDescription getEnclosingType();
&nbsp;
&nbsp;    int getActualModifiers(boolean var1);
&nbsp;
&nbsp;    String getSimpleName();
&nbsp;
&nbsp;    @Nonnull(
&nbsp;        when = When.MAYBE
&nbsp;    )
&nbsp;    String getCanonicalName();
&nbsp;
&nbsp;    boolean isAnonymousType();
&nbsp;
&nbsp;    boolean isLocalType();
&nbsp;
&nbsp;    boolean isMemberType();
&nbsp;
&nbsp;    @Nonnull(
&nbsp;        when = When.MAYBE
&nbsp;    )
&nbsp;    PackageDescription getPackage();
&nbsp;
&nbsp;    AnnotationList getInheritedAnnotations();
&nbsp;
&nbsp;    boolean isSamePackage(TypeDescription var1);
&nbsp;
&nbsp;    boolean isPrimitiveWrapper();
&nbsp;
&nbsp;    boolean isAnnotationReturnType();
&nbsp;
&nbsp;    boolean isAnnotationValue();
&nbsp;
&nbsp;    boolean isAnnotationValue(Object var1);
&nbsp;
&nbsp;    boolean isPackageType();
&nbsp;
&nbsp;    int getInnerClassCount();
&nbsp;
&nbsp;    boolean isInnerClass();
&nbsp;
&nbsp;    boolean isNestedClass();
&nbsp;
&nbsp;    TypeDescription asBoxed();
&nbsp;
&nbsp;    TypeDescription asUnboxed();
&nbsp;
&nbsp;    @Nonnull(
&nbsp;        when = When.MAYBE
&nbsp;    )
&nbsp;    Object getDefaultValue();
&nbsp;
&nbsp;    TypeDescription getNestHost();
&nbsp;
&nbsp;    TypeList getNestMembers();
&nbsp;
&nbsp;    boolean isNestHost();
&nbsp;
&nbsp;    boolean isNestMateOf(Class&lt;?&gt; var1);
&nbsp;
&nbsp;    boolean isNestMateOf(TypeDescription var1);
&nbsp;
&nbsp;    boolean isCompileTimeConstant();
&nbsp;
&nbsp;    TypeList getPermittedSubtypes();
&nbsp;
&nbsp;    boolean isSealed();
&nbsp;
&nbsp;    @Nonnull(
&nbsp;        when = When.MAYBE
&nbsp;    )
&nbsp;    ClassFileVersion getClassFileVersion();
&nbsp;
&nbsp;    public static class SuperTypeLoading extends AbstractBase {
&nbsp;        private final TypeDescription delegate;
&nbsp;        @Nonnull(
&nbsp;            when = When.MAYBE
&nbsp;        )
&nbsp;        private final ClassLoader classLoader;
&nbsp;        private final ClassLoadingDelegate classLoadingDelegate;
&nbsp;
&nbsp;        public SuperTypeLoading(TypeDescription delegate, @Nonnull(when = When.MAYBE) ClassLoader classLoader) {
&nbsp;            this(delegate, classLoader, TypeDescription.SuperTypeLoading.ClassLoadingDelegate.Simple.INSTANCE);
&nbsp;        }
&nbsp;
&nbsp;        public SuperTypeLoading(TypeDescription delegate, @Nonnull(when = When.MAYBE) ClassLoader classLoader, ClassLoadingDelegate classLoadingDelegate) {
&nbsp;            this.delegate = delegate;
&nbsp;            this.classLoader = classLoader;
&nbsp;            this.classLoadingDelegate = classLoadingDelegate;
&nbsp;        }
&nbsp;
&nbsp;        public AnnotationList getDeclaredAnnotations() {
&nbsp;            return this.delegate.getDeclaredAnnotations();
&nbsp;        }
&nbsp;
&nbsp;        public int getModifiers() {
&nbsp;            return this.delegate.getModifiers();
&nbsp;        }
&nbsp;
&nbsp;        public TypeList.Generic getTypeVariables() {
&nbsp;            return this.delegate.getTypeVariables();
&nbsp;        }
&nbsp;
&nbsp;        public String getDescriptor() {
&nbsp;            return this.delegate.getDescriptor();
&nbsp;        }
&nbsp;
&nbsp;        public String getName() {
&nbsp;            return this.delegate.getName();
&nbsp;        }
&nbsp;
&nbsp;        @Nonnull(
&nbsp;            when = When.MAYBE
&nbsp;        )
&nbsp;        public Generic getSuperClass() {
&nbsp;            Generic superClass = this.delegate.getSuperClass();
&nbsp;            return (Generic)(superClass == null ? TypeDescription.Generic.UNDEFINED : new ClassLoadingTypeProjection(superClass, this.classLoader, this.classLoadingDelegate));
&nbsp;        }
&nbsp;
&nbsp;        public TypeList.Generic getInterfaces() {
&nbsp;            return new ClassLoadingTypeList(this.delegate.getInterfaces(), this.classLoader, this.classLoadingDelegate);
&nbsp;        }
&nbsp;
&nbsp;        public FieldList&lt;FieldDescription.InDefinedShape&gt; getDeclaredFields() {
&nbsp;            return this.delegate.getDeclaredFields();
&nbsp;        }
&nbsp;
&nbsp;        public MethodList&lt;MethodDescription.InDefinedShape&gt; getDeclaredMethods() {
&nbsp;            return this.delegate.getDeclaredMethods();
&nbsp;        }
&nbsp;
&nbsp;        public StackSize getStackSize() {
&nbsp;            return this.delegate.getStackSize();
&nbsp;        }
&nbsp;
&nbsp;        public boolean isArray() {
&nbsp;            return this.delegate.isArray();
&nbsp;        }
&nbsp;
&nbsp;        public boolean isPrimitive() {
&nbsp;            return this.delegate.isPrimitive();
&nbsp;        }
&nbsp;
&nbsp;        @Nonnull(
&nbsp;            when = When.MAYBE
&nbsp;        )
&nbsp;        public TypeDescription getComponentType() {
&nbsp;            return this.delegate.getComponentType();
&nbsp;        }
&nbsp;
&nbsp;        @Nonnull(
&nbsp;            when = When.MAYBE
&nbsp;        )
&nbsp;        public TypeDescription getDeclaringType() {
&nbsp;            return this.delegate.getDeclaringType();
&nbsp;        }
&nbsp;
&nbsp;        public TypeList getDeclaredTypes() {
&nbsp;            return this.delegate.getDeclaredTypes();
&nbsp;        }
&nbsp;
&nbsp;        @Nonnull(
&nbsp;            when = When.MAYBE
&nbsp;        )
&nbsp;        public MethodDescription.InDefinedShape getEnclosingMethod() {
&nbsp;            return this.delegate.getEnclosingMethod();
&nbsp;        }
&nbsp;
&nbsp;        @Nonnull(
&nbsp;            when = When.MAYBE
&nbsp;        )
&nbsp;        public TypeDescription getEnclosingType() {
&nbsp;            return this.delegate.getEnclosingType();
&nbsp;        }
&nbsp;
&nbsp;        public String getSimpleName() {
&nbsp;            return this.delegate.getSimpleName();
&nbsp;        }
&nbsp;
&nbsp;        @Nonnull(
&nbsp;            when = When.MAYBE
&nbsp;        )
&nbsp;        public String getCanonicalName() {
&nbsp;            return this.delegate.getCanonicalName();
&nbsp;        }
&nbsp;
&nbsp;        public boolean isAnonymousType() {
&nbsp;            return this.delegate.isAnonymousType();
&nbsp;        }
&nbsp;
&nbsp;        public boolean isLocalType() {
&nbsp;            return this.delegate.isLocalType();
&nbsp;        }
&nbsp;
&nbsp;        @Nonnull(
&nbsp;            when = When.MAYBE
&nbsp;        )
&nbsp;        public PackageDescription getPackage() {
&nbsp;            return this.delegate.getPackage();
&nbsp;        }
&nbsp;
&nbsp;        public TypeDescription getNestHost() {
&nbsp;            return this.delegate.getNestHost();
&nbsp;        }
&nbsp;
&nbsp;        public TypeList getNestMembers() {
&nbsp;            return this.delegate.getNestMembers();
&nbsp;        }
&nbsp;
&nbsp;        public RecordComponentList&lt;RecordComponentDescription.InDefinedShape&gt; getRecordComponents() {
&nbsp;            return this.delegate.getRecordComponents();
&nbsp;        }
&nbsp;
&nbsp;        public boolean isRecord() {
&nbsp;            return this.delegate.isRecord();
&nbsp;        }
&nbsp;
&nbsp;        public boolean isSealed() {
&nbsp;            return this.delegate.isSealed();
&nbsp;        }
&nbsp;
&nbsp;        public TypeList getPermittedSubtypes() {
&nbsp;            return this.delegate.getPermittedSubtypes();
&nbsp;        }
&nbsp;
&nbsp;        @Nonnull(
&nbsp;            when = When.MAYBE
&nbsp;        )
&nbsp;        public ClassFileVersion getClassFileVersion() {
&nbsp;            return this.delegate.getClassFileVersion();
&nbsp;        }
&nbsp;
&nbsp;        protected static class ClassLoadingTypeList extends TypeList.Generic.AbstractBase {
&nbsp;            private final TypeList.Generic delegate;
&nbsp;            @Nonnull(
&nbsp;                when = When.MAYBE
&nbsp;            )
&nbsp;            private final ClassLoader classLoader;
&nbsp;            private final ClassLoadingDelegate classLoadingDelegate;
&nbsp;
&nbsp;            protected ClassLoadingTypeList(TypeList.Generic delegate, @Nonnull(when = When.MAYBE) ClassLoader classLoader, ClassLoadingDelegate classLoadingDelegate) {
&nbsp;                this.delegate = delegate;
&nbsp;                this.classLoader = classLoader;
&nbsp;                this.classLoadingDelegate = classLoadingDelegate;
&nbsp;            }
&nbsp;
&nbsp;            public Generic get(int index) {
&nbsp;                return new ClassLoadingTypeProjection((Generic)this.delegate.get(index), this.classLoader, this.classLoadingDelegate);
&nbsp;            }
&nbsp;
&nbsp;            public int size() {
&nbsp;                return this.delegate.size();
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        protected static class ClassLoadingTypeProjection extends Generic.LazyProjection {
&nbsp;            private final Generic delegate;
&nbsp;            @Nonnull(
&nbsp;                when = When.MAYBE
&nbsp;            )
&nbsp;            private final ClassLoader classLoader;
&nbsp;            private final ClassLoadingDelegate classLoadingDelegate;
&nbsp;
&nbsp;            protected ClassLoadingTypeProjection(Generic delegate, @Nonnull(when = When.MAYBE) ClassLoader classLoader, ClassLoadingDelegate classLoadingDelegate) {
&nbsp;                this.delegate = delegate;
&nbsp;                this.classLoader = classLoader;
&nbsp;                this.classLoadingDelegate = classLoadingDelegate;
&nbsp;            }
&nbsp;
&nbsp;            public AnnotationList getDeclaredAnnotations() {
&nbsp;                return this.delegate.getDeclaredAnnotations();
&nbsp;            }
&nbsp;
&nbsp;            @Enhance(&quot;erasure&quot;)
&nbsp;            public TypeDescription asErasure() {
&nbsp;                TypeDescription var1 = this.erasure;
&nbsp;                TypeDescription var10000;
&nbsp;                if (var1 != null) {
&nbsp;                    var10000 = null;
&nbsp;                } else {
&nbsp;                    ClassLoadingTypeProjection var2 = this;
&nbsp;
&nbsp;                    try {
&nbsp;                        var10000 = TypeDescription.ForLoadedType.of(var2.classLoadingDelegate.load(var2.delegate.asErasure().getName(), var2.classLoader));
&nbsp;                    } catch (ClassNotFoundException var5) {
&nbsp;                        var10000 = this.delegate.asErasure();
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                TypeDescription var6 = var10000;
&nbsp;                if (var6 == null) {
&nbsp;                    var6 = (TypeDescription)this.erasure;
&nbsp;                } else {
&nbsp;                    this.erasure = var6;
&nbsp;                }
&nbsp;
&nbsp;                return var6;
&nbsp;            }
&nbsp;
&nbsp;            protected Generic resolve() {
&nbsp;                return this.delegate;
&nbsp;            }
&nbsp;
&nbsp;            @Nonnull(
&nbsp;                when = When.MAYBE
&nbsp;            )
&nbsp;            @Enhance(&quot;superClass&quot;)
&nbsp;            public Generic getSuperClass() {
&nbsp;                Generic var1 = this.superClass;
&nbsp;                Object var10000;
&nbsp;                if (var1 != null) {
&nbsp;                    var10000 = null;
&nbsp;                } else {
&nbsp;                    ClassLoadingTypeProjection var2 = this;
&nbsp;                    Generic superClass = this.delegate.getSuperClass();
&nbsp;                    if (superClass == null) {
&nbsp;                        var10000 = TypeDescription.Generic.UNDEFINED;
&nbsp;                    } else {
&nbsp;                        try {
&nbsp;                            var10000 = new ClassLoadingTypeProjection(superClass, var2.classLoadingDelegate.load(var2.delegate.asErasure().getName(), var2.classLoader).getClassLoader(), var2.classLoadingDelegate);
&nbsp;                        } catch (ClassNotFoundException var6) {
&nbsp;                            var10000 = superClass;
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                Object var7 = var10000;
&nbsp;                if (var7 == null) {
&nbsp;                    var7 = (Generic)this.superClass;
&nbsp;                } else {
&nbsp;                    this.superClass = (Generic)var7;
&nbsp;                }
&nbsp;
&nbsp;                return (Generic)var7;
&nbsp;            }
&nbsp;
&nbsp;            @Enhance(&quot;interfaces&quot;)
&nbsp;            public TypeList.Generic getInterfaces() {
&nbsp;                TypeList.Generic var1 = this.interfaces;
&nbsp;                Object var10000;
&nbsp;                if (var1 != null) {
&nbsp;                    var10000 = null;
&nbsp;                } else {
&nbsp;                    ClassLoadingTypeProjection var2 = this;
<b class="fc">&nbsp;                    TypeList.Generic interfaces = this.delegate.getInterfaces();</b>
&nbsp;
&nbsp;                    try {
&nbsp;                        var10000 = new ClassLoadingTypeList(interfaces, var2.classLoadingDelegate.load(var2.delegate.asErasure().getName(), var2.classLoader).getClassLoader(), var2.classLoadingDelegate);
&nbsp;                    } catch (ClassNotFoundException var6) {
<b class="fc">&nbsp;                        var10000 = interfaces;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                Object var7 = var10000;
<b class="fc">&nbsp;                if (var7 == null) {</b>
&nbsp;                    var7 = (TypeList.Generic)this.interfaces;
&nbsp;                } else {
&nbsp;                    this.interfaces = (TypeList.Generic)var7;
&nbsp;                }
<b class="fc">&nbsp;</b>
&nbsp;                return (TypeList.Generic)var7;
&nbsp;            }
&nbsp;
&nbsp;            public Iterator&lt;TypeDefinition&gt; iterator() {
&nbsp;                return new TypeDefinition.SuperClassIterator(this);
&nbsp;            }
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        public interface ClassLoadingDelegate {
&nbsp;            Class&lt;?&gt; load(String var1, @Nonnull(when = When.MAYBE) ClassLoader var2) throws ClassNotFoundException;
&nbsp;
&nbsp;            public static enum Simple implements ClassLoadingDelegate {
&nbsp;                INSTANCE;
&nbsp;
&nbsp;                private Simple() {
&nbsp;                }
&nbsp;
&nbsp;                public Class&lt;?&gt; load(String name, @Nonnull(when = When.MAYBE) ClassLoader classLoader) throws ClassNotFoundException {
&nbsp;                    return Class.forName(name, false, classLoader);
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static class ForPackageDescription extends AbstractBase.OfSimpleType {
&nbsp;        private final PackageDescription packageDescription;
&nbsp;
&nbsp;        public ForPackageDescription(PackageDescription packageDescription) {
&nbsp;            this.packageDescription = packageDescription;
&nbsp;        }
&nbsp;
&nbsp;        @Nonnull(
&nbsp;            when = When.MAYBE
&nbsp;        )
&nbsp;        public Generic getSuperClass() {
&nbsp;            return TypeDescription.Generic.OBJECT;
&nbsp;        }
&nbsp;
&nbsp;        public TypeList.Generic getInterfaces() {
&nbsp;            return new TypeList.Generic.Empty();
&nbsp;        }
&nbsp;
&nbsp;        @Nonnull(
&nbsp;            when = When.MAYBE
&nbsp;        )
&nbsp;        public MethodDescription.InDefinedShape getEnclosingMethod() {
&nbsp;            return MethodDescription.UNDEFINED;
&nbsp;        }
&nbsp;
&nbsp;        @Nonnull(
&nbsp;            when = When.MAYBE
&nbsp;        )
&nbsp;        public TypeDescription getEnclosingType() {
&nbsp;            return TypeDescription.UNDEFINED;
&nbsp;        }
&nbsp;
&nbsp;        public boolean isAnonymousType() {
&nbsp;            return false;
&nbsp;        }
&nbsp;
&nbsp;        public boolean isLocalType() {
&nbsp;            return false;
&nbsp;        }
&nbsp;
&nbsp;        public TypeList getDeclaredTypes() {
&nbsp;            return new TypeList.Empty();
&nbsp;        }
&nbsp;
&nbsp;        public FieldList&lt;FieldDescription.InDefinedShape&gt; getDeclaredFields() {
&nbsp;            return new FieldList.Empty();
&nbsp;        }
&nbsp;
&nbsp;        public MethodList&lt;MethodDescription.InDefinedShape&gt; getDeclaredMethods() {
&nbsp;            return new MethodList.Empty();
&nbsp;        }
&nbsp;
&nbsp;        public PackageDescription getPackage() {
&nbsp;            return this.packageDescription;
&nbsp;        }
&nbsp;
&nbsp;        public AnnotationList getDeclaredAnnotations() {
&nbsp;            return this.packageDescription.getDeclaredAnnotations();
&nbsp;        }
&nbsp;
&nbsp;        @Nonnull(
&nbsp;            when = When.MAYBE
&nbsp;        )
&nbsp;        public TypeDescription getDeclaringType() {
&nbsp;            return TypeDescription.UNDEFINED;
&nbsp;        }
&nbsp;
&nbsp;        public TypeList.Generic getTypeVariables() {
&nbsp;            return new TypeList.Generic.Empty();
&nbsp;        }
&nbsp;
&nbsp;        public int getModifiers() {
&nbsp;            return 5632;
&nbsp;        }
&nbsp;
&nbsp;        public String getName() {
&nbsp;            return this.packageDescription.getName() + &quot;.&quot; + &quot;package-info&quot;;
&nbsp;        }
&nbsp;
&nbsp;        public TypeDescription getNestHost() {
&nbsp;            return this;
&nbsp;        }
&nbsp;
&nbsp;        public TypeList getNestMembers() {
&nbsp;            return new TypeList.Explicit(new TypeDescription[]{this});
&nbsp;        }
&nbsp;
&nbsp;        public RecordComponentList&lt;RecordComponentDescription.InDefinedShape&gt; getRecordComponents() {
&nbsp;            return new RecordComponentList.Empty();
&nbsp;        }
&nbsp;
&nbsp;        public boolean isRecord() {
&nbsp;            return false;
&nbsp;        }
&nbsp;
&nbsp;        public TypeList getPermittedSubtypes() {
&nbsp;            return new TypeList.Empty();
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static class Latent extends AbstractBase.OfSimpleType {
&nbsp;        private final String name;
&nbsp;        private final int modifiers;
&nbsp;        @Nonnull(
&nbsp;            when = When.MAYBE
&nbsp;        )
&nbsp;        private final Generic superClass;
&nbsp;        private final List&lt;? extends Generic&gt; interfaces;
&nbsp;
&nbsp;        public Latent(String name, int modifiers, @Nonnull(when = When.MAYBE) Generic superClass, Generic... anInterface) {
&nbsp;            this(name, modifiers, superClass, Arrays.asList(anInterface));
&nbsp;        }
&nbsp;
&nbsp;        public Latent(String name, int modifiers, @Nonnull(when = When.MAYBE) Generic superClass, List&lt;? extends Generic&gt; interfaces) {
&nbsp;            this.name = name;
&nbsp;            this.modifiers = modifiers;
&nbsp;            this.superClass = superClass;
&nbsp;            this.interfaces = interfaces;
&nbsp;        }
&nbsp;
&nbsp;        @Nonnull(
&nbsp;            when = When.MAYBE
&nbsp;        )
&nbsp;        public Generic getSuperClass() {
&nbsp;            return this.superClass;
&nbsp;        }
&nbsp;
&nbsp;        public TypeList.Generic getInterfaces() {
&nbsp;            return new TypeList.Generic.Explicit(this.interfaces);
&nbsp;        }
&nbsp;
&nbsp;        public MethodDescription.InDefinedShape getEnclosingMethod() {
&nbsp;            throw new IllegalStateException(&quot;Cannot resolve enclosing method of a latent type description: &quot; + this);
&nbsp;        }
&nbsp;
&nbsp;        public TypeDescription getEnclosingType() {
&nbsp;            throw new IllegalStateException(&quot;Cannot resolve enclosing type of a latent type description: &quot; + this);
&nbsp;        }
&nbsp;
&nbsp;        public TypeList getDeclaredTypes() {
&nbsp;            throw new IllegalStateException(&quot;Cannot resolve inner types of a latent type description: &quot; + this);
&nbsp;        }
&nbsp;
&nbsp;        public boolean isAnonymousType() {
&nbsp;            throw new IllegalStateException(&quot;Cannot resolve anonymous type property of a latent type description: &quot; + this);
&nbsp;        }
&nbsp;
&nbsp;        public boolean isLocalType() {
&nbsp;            throw new IllegalStateException(&quot;Cannot resolve local class property of a latent type description: &quot; + this);
&nbsp;        }
&nbsp;
&nbsp;        public FieldList&lt;FieldDescription.InDefinedShape&gt; getDeclaredFields() {
&nbsp;            throw new IllegalStateException(&quot;Cannot resolve declared fields of a latent type description: &quot; + this);
&nbsp;        }
&nbsp;
&nbsp;        public MethodList&lt;MethodDescription.InDefinedShape&gt; getDeclaredMethods() {
&nbsp;            throw new IllegalStateException(&quot;Cannot resolve declared methods of a latent type description: &quot; + this);
&nbsp;        }
&nbsp;
&nbsp;        @Nonnull(
&nbsp;            when = When.MAYBE
&nbsp;        )
&nbsp;        public PackageDescription getPackage() {
&nbsp;            String name = this.getName();
&nbsp;            int index = name.lastIndexOf(46);
&nbsp;            return (PackageDescription)(index == -1 ? PackageDescription.UNDEFINED : new PackageDescription.Simple(name.substring(0, index)));
&nbsp;        }
&nbsp;
&nbsp;        public AnnotationList getDeclaredAnnotations() {
&nbsp;            throw new IllegalStateException(&quot;Cannot resolve declared annotations of a latent type description: &quot; + this);
&nbsp;        }
&nbsp;
&nbsp;        public TypeDescription getDeclaringType() {
&nbsp;            throw new IllegalStateException(&quot;Cannot resolve declared type of a latent type description: &quot; + this);
&nbsp;        }
&nbsp;
&nbsp;        public int getModifiers() {
&nbsp;            return this.modifiers;
&nbsp;        }
&nbsp;
&nbsp;        public String getName() {
&nbsp;            return this.name;
&nbsp;        }
&nbsp;
&nbsp;        public TypeList.Generic getTypeVariables() {
&nbsp;            throw new IllegalStateException(&quot;Cannot resolve type variables of a latent type description: &quot; + this);
&nbsp;        }
&nbsp;
&nbsp;        public TypeDescription getNestHost() {
&nbsp;            throw new IllegalStateException(&quot;Cannot resolve nest host of a latent type description: &quot; + this);
&nbsp;        }
&nbsp;
&nbsp;        public TypeList getNestMembers() {
&nbsp;            throw new IllegalStateException(&quot;Cannot resolve nest mates of a latent type description: &quot; + this);
&nbsp;        }
&nbsp;
&nbsp;        public RecordComponentList&lt;RecordComponentDescription.InDefinedShape&gt; getRecordComponents() {
&nbsp;            throw new IllegalStateException(&quot;Cannot resolve record components of a latent type description: &quot; + this);
&nbsp;        }
&nbsp;
&nbsp;        public boolean isRecord() {
&nbsp;            throw new IllegalStateException(&quot;Cannot resolve record attribute of a latent type description: &quot; + this);
&nbsp;        }
&nbsp;
&nbsp;        public TypeList getPermittedSubtypes() {
&nbsp;            throw new IllegalStateException(&quot;Cannot resolve permitted subclasses of a latent type description: &quot; + this);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static class ArrayProjection extends AbstractBase {
&nbsp;        private static final int ARRAY_IMPLIED = 1040;
&nbsp;        private static final int ARRAY_EXCLUDED = 8712;
&nbsp;        private final TypeDescription componentType;
&nbsp;        private final int arity;
&nbsp;
&nbsp;        protected ArrayProjection(TypeDescription componentType, int arity) {
&nbsp;            this.componentType = componentType;
&nbsp;            this.arity = arity;
&nbsp;        }
&nbsp;
&nbsp;        public static TypeDescription of(TypeDescription componentType) {
&nbsp;            return of(componentType, 1);
&nbsp;        }
&nbsp;
&nbsp;        @SuppressFBWarnings(
&nbsp;            value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;            justification = &quot;Assuming component type for array type.&quot;
&nbsp;        )
&nbsp;        public static TypeDescription of(TypeDescription componentType, int arity) {
&nbsp;            if (arity &lt; 0) {
&nbsp;                throw new IllegalArgumentException(&quot;Arrays cannot have a negative arity&quot;);
&nbsp;            } else {
&nbsp;                while(componentType.isArray()) {
&nbsp;                    componentType = componentType.getComponentType();
&nbsp;                    ++arity;
&nbsp;                }
&nbsp;
&nbsp;                return (TypeDescription)(arity == 0 ? componentType : new ArrayProjection(componentType, arity));
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public boolean isArray() {
&nbsp;            return true;
&nbsp;        }
&nbsp;
&nbsp;        @Nonnull(
&nbsp;            when = When.MAYBE
&nbsp;        )
&nbsp;        public TypeDescription getComponentType() {
&nbsp;            return (TypeDescription)(this.arity == 1 ? this.componentType : new ArrayProjection(this.componentType, this.arity - 1));
&nbsp;        }
&nbsp;
&nbsp;        public boolean isPrimitive() {
&nbsp;            return false;
&nbsp;        }
&nbsp;
&nbsp;        @Nonnull(
&nbsp;            when = When.MAYBE
&nbsp;        )
&nbsp;        public Generic getSuperClass() {
&nbsp;            return TypeDescription.Generic.OBJECT;
&nbsp;        }
&nbsp;
&nbsp;        public TypeList.Generic getInterfaces() {
&nbsp;            return ARRAY_INTERFACES;
&nbsp;        }
&nbsp;
&nbsp;        @Nonnull(
&nbsp;            when = When.MAYBE
&nbsp;        )
&nbsp;        public MethodDescription.InDefinedShape getEnclosingMethod() {
&nbsp;            return MethodDescription.UNDEFINED;
&nbsp;        }
&nbsp;
&nbsp;        @Nonnull(
&nbsp;            when = When.MAYBE
&nbsp;        )
&nbsp;        public TypeDescription getEnclosingType() {
&nbsp;            return TypeDescription.UNDEFINED;
&nbsp;        }
&nbsp;
&nbsp;        public TypeList getDeclaredTypes() {
&nbsp;            return new TypeList.Empty();
&nbsp;        }
&nbsp;
&nbsp;        public String getSimpleName() {
&nbsp;            StringBuilder stringBuilder = new StringBuilder(this.componentType.getSimpleName());
&nbsp;
&nbsp;            for(int i = 0; i &lt; this.arity; ++i) {
&nbsp;                stringBuilder.append(&quot;[]&quot;);
&nbsp;            }
&nbsp;
&nbsp;            return stringBuilder.toString();
&nbsp;        }
&nbsp;
&nbsp;        @Nonnull(
&nbsp;            when = When.MAYBE
&nbsp;        )
&nbsp;        public String getCanonicalName() {
&nbsp;            String canonicalName = this.componentType.getCanonicalName();
&nbsp;            if (canonicalName == null) {
&nbsp;                return NO_NAME;
&nbsp;            } else {
&nbsp;                StringBuilder stringBuilder = new StringBuilder(canonicalName);
&nbsp;
&nbsp;                for(int i = 0; i &lt; this.arity; ++i) {
&nbsp;                    stringBuilder.append(&quot;[]&quot;);
&nbsp;                }
&nbsp;
&nbsp;                return stringBuilder.toString();
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public boolean isAnonymousType() {
&nbsp;            return false;
&nbsp;        }
&nbsp;
&nbsp;        public boolean isLocalType() {
&nbsp;            return false;
&nbsp;        }
&nbsp;
&nbsp;        public boolean isMemberType() {
&nbsp;            return false;
&nbsp;        }
&nbsp;
&nbsp;        public FieldList&lt;FieldDescription.InDefinedShape&gt; getDeclaredFields() {
&nbsp;            return new FieldList.Empty();
&nbsp;        }
&nbsp;
&nbsp;        public MethodList&lt;MethodDescription.InDefinedShape&gt; getDeclaredMethods() {
&nbsp;            return new MethodList.Empty();
&nbsp;        }
&nbsp;
&nbsp;        public StackSize getStackSize() {
&nbsp;            return StackSize.SINGLE;
&nbsp;        }
&nbsp;
&nbsp;        public AnnotationList getDeclaredAnnotations() {
&nbsp;            return new AnnotationList.Empty();
&nbsp;        }
&nbsp;
&nbsp;        public AnnotationList getInheritedAnnotations() {
&nbsp;            return new AnnotationList.Empty();
&nbsp;        }
&nbsp;
&nbsp;        @Nonnull(
&nbsp;            when = When.MAYBE
&nbsp;        )
&nbsp;        public PackageDescription getPackage() {
&nbsp;            return PackageDescription.UNDEFINED;
&nbsp;        }
&nbsp;
&nbsp;        public String getName() {
&nbsp;            String descriptor = this.componentType.getDescriptor();
&nbsp;            StringBuilder stringBuilder = new StringBuilder(descriptor.length() + this.arity);
&nbsp;
&nbsp;            int index;
&nbsp;            for(index = 0; index &lt; this.arity; ++index) {
&nbsp;                stringBuilder.append(&#39;[&#39;);
&nbsp;            }
&nbsp;
&nbsp;            for(index = 0; index &lt; descriptor.length(); ++index) {
&nbsp;                char character = descriptor.charAt(index);
&nbsp;                stringBuilder.append(character == &#39;/&#39; ? &#39;.&#39; : character);
&nbsp;            }
&nbsp;
&nbsp;            return stringBuilder.toString();
&nbsp;        }
&nbsp;
&nbsp;        public String getDescriptor() {
&nbsp;            StringBuilder stringBuilder = new StringBuilder();
&nbsp;
&nbsp;            for(int i = 0; i &lt; this.arity; ++i) {
&nbsp;                stringBuilder.append(&#39;[&#39;);
&nbsp;            }
&nbsp;
&nbsp;            return stringBuilder.append(this.componentType.getDescriptor()).toString();
&nbsp;        }
&nbsp;
&nbsp;        @Nonnull(
&nbsp;            when = When.NEVER
&nbsp;        )
&nbsp;        public TypeDescription getDeclaringType() {
&nbsp;            return TypeDescription.UNDEFINED;
&nbsp;        }
&nbsp;
&nbsp;        @SuppressFBWarnings(
&nbsp;            value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;            justification = &quot;Assuming component type for array type.&quot;
&nbsp;        )
&nbsp;        public int getModifiers() {
&nbsp;            return this.getComponentType().getModifiers() &amp; -8713 | 1040;
&nbsp;        }
&nbsp;
&nbsp;        public TypeList.Generic getTypeVariables() {
&nbsp;            return new TypeList.Generic.Empty();
&nbsp;        }
&nbsp;
&nbsp;        public TypeDescription getNestHost() {
&nbsp;            return this;
&nbsp;        }
&nbsp;
&nbsp;        public TypeList getNestMembers() {
&nbsp;            return new TypeList.Explicit(new TypeDescription[]{this});
&nbsp;        }
&nbsp;
&nbsp;        public RecordComponentList&lt;RecordComponentDescription.InDefinedShape&gt; getRecordComponents() {
&nbsp;            return new RecordComponentList.Empty();
&nbsp;        }
&nbsp;
&nbsp;        public boolean isRecord() {
&nbsp;            return false;
&nbsp;        }
&nbsp;
&nbsp;        public TypeList getPermittedSubtypes() {
&nbsp;            return new TypeList.Empty();
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @SuppressFBWarnings(
&nbsp;        value = {&quot;SE_TRANSIENT_FIELD_NOT_RESTORED&quot;},
&nbsp;        justification = &quot;Field is only used as a cache store and is implicitly recomputed&quot;
&nbsp;    )
&nbsp;    public static class ForLoadedType extends AbstractBase implements Serializable {
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;        private static final Dispatcher DISPATCHER;
&nbsp;        private static final Map&lt;Class&lt;?&gt;, TypeDescription&gt; TYPE_CACHE;
&nbsp;        private final Class&lt;?&gt; type;
&nbsp;        private static final boolean ACCESS_CONTROLLER;
&nbsp;
&nbsp;        public ForLoadedType(Class&lt;?&gt; type) {
&nbsp;            this.type = type;
&nbsp;        }
&nbsp;
&nbsp;        @net.bytebuddy.build.AccessControllerPlugin.Enhance
&nbsp;        private static &lt;T&gt; T doPrivileged(PrivilegedAction&lt;T&gt; action) {
&nbsp;            return ACCESS_CONTROLLER ? AccessController.doPrivileged(action) : action.run();
&nbsp;        }
&nbsp;
&nbsp;        public static String getName(Class&lt;?&gt; type) {
&nbsp;            String name = type.getName();
&nbsp;            int anonymousLoaderIndex = name.indexOf(47);
&nbsp;            return anonymousLoaderIndex == -1 ? name : name.substring(0, anonymousLoaderIndex);
&nbsp;        }
&nbsp;
&nbsp;        public static TypeDescription of(Class&lt;?&gt; type) {
&nbsp;            TypeDescription typeDescription = (TypeDescription)TYPE_CACHE.get(type);
&nbsp;            return (TypeDescription)(typeDescription == null ? new ForLoadedType(type) : typeDescription);
&nbsp;        }
&nbsp;
&nbsp;        public boolean isAssignableFrom(Class&lt;?&gt; type) {
&nbsp;            return this.type.isAssignableFrom(type) || super.isAssignableFrom(type);
&nbsp;        }
&nbsp;
&nbsp;        public boolean isAssignableFrom(TypeDescription typeDescription) {
&nbsp;            return typeDescription instanceof ForLoadedType &amp;&amp; this.type.isAssignableFrom(((ForLoadedType)typeDescription).type) || super.isAssignableFrom(typeDescription);
&nbsp;        }
&nbsp;
&nbsp;        public boolean isAssignableTo(Class&lt;?&gt; type) {
&nbsp;            return type.isAssignableFrom(this.type) || super.isAssignableTo(type);
&nbsp;        }
&nbsp;
&nbsp;        public boolean isAssignableTo(TypeDescription typeDescription) {
&nbsp;            return typeDescription instanceof ForLoadedType &amp;&amp; ((ForLoadedType)typeDescription).type.isAssignableFrom(this.type) || super.isAssignableTo(typeDescription);
&nbsp;        }
&nbsp;
&nbsp;        public boolean isInHierarchyWith(Class&lt;?&gt; type) {
&nbsp;            return type.isAssignableFrom(this.type) || this.type.isAssignableFrom(type) || super.isInHierarchyWith(type);
&nbsp;        }
&nbsp;
&nbsp;        public boolean isInHierarchyWith(TypeDescription typeDescription) {
&nbsp;            return typeDescription instanceof ForLoadedType &amp;&amp; (((ForLoadedType)typeDescription).type.isAssignableFrom(this.type) || this.type.isAssignableFrom(((ForLoadedType)typeDescription).type)) || super.isInHierarchyWith(typeDescription);
&nbsp;        }
&nbsp;
&nbsp;        public boolean represents(Type type) {
&nbsp;            return type == this.type || super.represents(type);
&nbsp;        }
&nbsp;
&nbsp;        @Nonnull(
&nbsp;            when = When.MAYBE
&nbsp;        )
&nbsp;        public TypeDescription getComponentType() {
&nbsp;            Class&lt;?&gt; componentType = this.type.getComponentType();
&nbsp;            return componentType == null ? TypeDescription.UNDEFINED : of(componentType);
&nbsp;        }
&nbsp;
&nbsp;        public boolean isArray() {
&nbsp;            return this.type.isArray();
&nbsp;        }
&nbsp;
&nbsp;        public boolean isPrimitive() {
&nbsp;            return this.type.isPrimitive();
&nbsp;        }
&nbsp;
&nbsp;        public boolean isAnnotation() {
&nbsp;            return this.type.isAnnotation();
&nbsp;        }
&nbsp;
&nbsp;        @Nonnull(
&nbsp;            when = When.MAYBE
&nbsp;        )
&nbsp;        public Generic getSuperClass() {
&nbsp;            if (RAW_TYPES) {
&nbsp;                return this.type.getSuperclass() == null ? TypeDescription.Generic.UNDEFINED : TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(this.type.getSuperclass());
&nbsp;            } else {
&nbsp;                return TypeDescription.Generic.LazyProjection.ForLoadedSuperClass.of(this.type);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public TypeList.Generic getInterfaces() {
&nbsp;            if (RAW_TYPES) {
&nbsp;                return (TypeList.Generic)(this.isArray() ? ARRAY_INTERFACES : new TypeList.Generic.ForLoadedTypes(this.type.getInterfaces()));
&nbsp;            } else {
&nbsp;                return (TypeList.Generic)(this.isArray() ? ARRAY_INTERFACES : new TypeList.Generic.OfLoadedInterfaceTypes(this.type));
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Nonnull(
&nbsp;            when = When.MAYBE
&nbsp;        )
&nbsp;        public TypeDescription getDeclaringType() {
&nbsp;            Class&lt;?&gt; declaringType = this.type.getDeclaringClass();
&nbsp;            return declaringType == null ? TypeDescription.UNDEFINED : of(declaringType);
&nbsp;        }
&nbsp;
&nbsp;        @Nonnull(
&nbsp;            when = When.MAYBE
&nbsp;        )
&nbsp;        public MethodDescription.InDefinedShape getEnclosingMethod() {
&nbsp;            Method enclosingMethod = this.type.getEnclosingMethod();
&nbsp;            Constructor&lt;?&gt; enclosingConstructor = this.type.getEnclosingConstructor();
&nbsp;            if (enclosingMethod != null) {
&nbsp;                return new MethodDescription.ForLoadedMethod(enclosingMethod);
&nbsp;            } else {
&nbsp;                return (MethodDescription.InDefinedShape)(enclosingConstructor != null ? new MethodDescription.ForLoadedConstructor(enclosingConstructor) : MethodDescription.UNDEFINED);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public TypeDescription getEnclosingType() {
&nbsp;            Class&lt;?&gt; enclosingType = this.type.getEnclosingClass();
&nbsp;            return enclosingType == null ? TypeDescription.UNDEFINED : of(enclosingType);
&nbsp;        }
&nbsp;
&nbsp;        public TypeList getDeclaredTypes() {
&nbsp;            return new TypeList.ForLoadedTypes(this.type.getDeclaredClasses());
&nbsp;        }
&nbsp;
&nbsp;        public String getSimpleName() {
&nbsp;            String simpleName = this.type.getSimpleName();
&nbsp;            int anonymousLoaderIndex = simpleName.indexOf(47);
&nbsp;            if (anonymousLoaderIndex == -1) {
&nbsp;                return simpleName;
&nbsp;            } else {
&nbsp;                StringBuilder normalized = new StringBuilder(simpleName.substring(0, anonymousLoaderIndex));
&nbsp;
&nbsp;                for(Class&lt;?&gt; type = this.type; type.isArray(); type = type.getComponentType()) {
&nbsp;                    normalized.append(&quot;[]&quot;);
&nbsp;                }
&nbsp;
&nbsp;                return normalized.toString();
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public boolean isAnonymousType() {
&nbsp;            return this.type.isAnonymousClass();
&nbsp;        }
&nbsp;
&nbsp;        public boolean isLocalType() {
&nbsp;            return this.type.isLocalClass();
&nbsp;        }
&nbsp;
&nbsp;        public boolean isMemberType() {
&nbsp;            return this.type.isMemberClass();
&nbsp;        }
&nbsp;
&nbsp;        @Enhance(&quot;declaredFields&quot;)
&nbsp;        public FieldList&lt;FieldDescription.InDefinedShape&gt; getDeclaredFields() {
&nbsp;            FieldList var1 = this.declaredFields;
&nbsp;            Object var2 = var1 != null ? null : new FieldList.ForLoadedFields(this.type.getDeclaredFields());
&nbsp;            if (var2 == null) {
&nbsp;                var2 = (FieldList)this.declaredFields;
&nbsp;            } else {
&nbsp;                this.declaredFields = (FieldList)var2;
&nbsp;            }
&nbsp;
&nbsp;            return (FieldList)var2;
&nbsp;        }
&nbsp;
&nbsp;        @Enhance(&quot;declaredMethods&quot;)
&nbsp;        public MethodList&lt;MethodDescription.InDefinedShape&gt; getDeclaredMethods() {
&nbsp;            MethodList var1 = this.declaredMethods;
&nbsp;            Object var2 = var1 != null ? null : new MethodList.ForLoadedMethods(this.type);
&nbsp;            if (var2 == null) {
&nbsp;                var2 = (MethodList)this.declaredMethods;
&nbsp;            } else {
&nbsp;                this.declaredMethods = (MethodList)var2;
&nbsp;            }
&nbsp;
&nbsp;            return (MethodList)var2;
&nbsp;        }
&nbsp;
&nbsp;        @Nonnull(
&nbsp;            when = When.MAYBE
&nbsp;        )
&nbsp;        public PackageDescription getPackage() {
&nbsp;            if (!this.type.isArray() &amp;&amp; !this.type.isPrimitive()) {
&nbsp;                Package aPackage = this.type.getPackage();
&nbsp;                if (aPackage == null) {
&nbsp;                    String name = this.type.getName();
&nbsp;                    int index = name.lastIndexOf(46);
&nbsp;                    return index == -1 ? new PackageDescription.Simple(&quot;&quot;) : new PackageDescription.Simple(name.substring(0, index));
&nbsp;                } else {
&nbsp;                    return new PackageDescription.ForLoadedPackage(aPackage);
&nbsp;                }
&nbsp;            } else {
&nbsp;                return PackageDescription.UNDEFINED;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public StackSize getStackSize() {
&nbsp;            return StackSize.of(this.type);
&nbsp;        }
&nbsp;
&nbsp;        public String getName() {
&nbsp;            return getName(this.type);
&nbsp;        }
&nbsp;
&nbsp;        @Nonnull(
&nbsp;            when = When.MAYBE
&nbsp;        )
&nbsp;        public String getCanonicalName() {
&nbsp;            String canonicalName = this.type.getCanonicalName();
&nbsp;            if (canonicalName == null) {
&nbsp;                return NO_NAME;
&nbsp;            } else {
&nbsp;                int anonymousLoaderIndex = canonicalName.indexOf(47);
&nbsp;                if (anonymousLoaderIndex == -1) {
&nbsp;                    return canonicalName;
&nbsp;                } else {
&nbsp;                    StringBuilder normalized = new StringBuilder(canonicalName.substring(0, anonymousLoaderIndex));
&nbsp;
&nbsp;                    for(Class&lt;?&gt; type = this.type; type.isArray(); type = type.getComponentType()) {
&nbsp;                        normalized.append(&quot;[]&quot;);
&nbsp;                    }
&nbsp;
&nbsp;                    return normalized.toString();
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public String getDescriptor() {
&nbsp;            String name = this.type.getName();
&nbsp;            int anonymousLoaderIndex = name.indexOf(47);
&nbsp;            return anonymousLoaderIndex == -1 ? net.bytebuddy.jar.asm.Type.getDescriptor(this.type) : &quot;L&quot; + name.substring(0, anonymousLoaderIndex).replace(&#39;.&#39;, &#39;/&#39;) + &quot;;&quot;;
&nbsp;        }
&nbsp;
&nbsp;        public int getModifiers() {
&nbsp;            return this.type.getModifiers();
&nbsp;        }
&nbsp;
&nbsp;        public TypeList.Generic getTypeVariables() {
&nbsp;            return (TypeList.Generic)(RAW_TYPES ? new TypeList.Generic.Empty() : OfTypeVariables.of(this.type));
&nbsp;        }
&nbsp;
&nbsp;        @Enhance(&quot;declaredAnnotations&quot;)
&nbsp;        public AnnotationList getDeclaredAnnotations() {
&nbsp;            AnnotationList var1 = this.declaredAnnotations;
&nbsp;            Object var2 = var1 != null ? null : new AnnotationList.ForLoadedAnnotations(this.type.getDeclaredAnnotations());
&nbsp;            if (var2 == null) {
&nbsp;                var2 = (AnnotationList)this.declaredAnnotations;
&nbsp;            } else {
&nbsp;                this.declaredAnnotations = (AnnotationList)var2;
&nbsp;            }
&nbsp;
&nbsp;            return (AnnotationList)var2;
&nbsp;        }
&nbsp;
&nbsp;        public Generic asGenericType() {
&nbsp;            return TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(this.type);
&nbsp;        }
&nbsp;
&nbsp;        public TypeDescription getNestHost() {
&nbsp;            Class&lt;?&gt; host = DISPATCHER.getNestHost(this.type);
&nbsp;            return (TypeDescription)(host == null ? this : of(host));
&nbsp;        }
&nbsp;
&nbsp;        public TypeList getNestMembers() {
&nbsp;            Class&lt;?&gt;[] member = DISPATCHER.getNestMembers(this.type);
&nbsp;            return new TypeList.ForLoadedTypes(member.length == 0 ? new Class[]{this.type} : member);
&nbsp;        }
&nbsp;
&nbsp;        public boolean isNestHost() {
&nbsp;            Class&lt;?&gt; host = DISPATCHER.getNestHost(this.type);
&nbsp;            return host == null || host == this.type;
&nbsp;        }
&nbsp;
&nbsp;        public boolean isNestMateOf(Class&lt;?&gt; type) {
&nbsp;            return DISPATCHER.isNestmateOf(this.type, type) || super.isNestMateOf(of(type));
&nbsp;        }
&nbsp;
&nbsp;        public boolean isNestMateOf(TypeDescription typeDescription) {
&nbsp;            return typeDescription instanceof ForLoadedType &amp;&amp; DISPATCHER.isNestmateOf(this.type, ((ForLoadedType)typeDescription).type) || super.isNestMateOf(typeDescription);
&nbsp;        }
&nbsp;
&nbsp;        public RecordComponentList&lt;RecordComponentDescription.InDefinedShape&gt; getRecordComponents() {
&nbsp;            Object[] recordComponent = DISPATCHER.getRecordComponents(this.type);
&nbsp;            return (RecordComponentList)(recordComponent == null ? new RecordComponentList.Empty() : new RecordComponentList.ForLoadedRecordComponents(recordComponent));
&nbsp;        }
&nbsp;
&nbsp;        public boolean isRecord() {
&nbsp;            return DISPATCHER.isRecord(this.type);
&nbsp;        }
&nbsp;
&nbsp;        public boolean isSealed() {
&nbsp;            return DISPATCHER.isSealed(this.type);
&nbsp;        }
&nbsp;
&nbsp;        public TypeList getPermittedSubtypes() {
&nbsp;            Class&lt;?&gt;[] permittedSubclass = DISPATCHER.getPermittedSubclasses(this.type);
&nbsp;            return (TypeList)(permittedSubclass == null ? new TypeList.Empty() : new TypeList.ForLoadedTypes(permittedSubclass));
&nbsp;        }
&nbsp;
&nbsp;        @Nonnull(
&nbsp;            when = When.MAYBE
&nbsp;        )
&nbsp;        @Enhance(&quot;classFileVersion&quot;)
&nbsp;        public ClassFileVersion getClassFileVersion() {
&nbsp;            ClassFileVersion var1 = this.classFileVersion;
&nbsp;            ClassFileVersion var10000;
&nbsp;            if (var1 != null) {
&nbsp;                var10000 = null;
&nbsp;            } else {
&nbsp;                ForLoadedType var2 = this;
&nbsp;
&nbsp;                try {
&nbsp;                    var10000 = ClassFileVersion.of(var2.type);
&nbsp;                } catch (Throwable var5) {
&nbsp;                    var10000 = null;
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            ClassFileVersion var6 = var10000;
&nbsp;            if (var6 == null) {
&nbsp;                var6 = (ClassFileVersion)this.classFileVersion;
&nbsp;            } else {
&nbsp;                this.classFileVersion = var6;
&nbsp;            }
&nbsp;
&nbsp;            return var6;
&nbsp;        }
&nbsp;
&nbsp;        static {
&nbsp;            try {
&nbsp;                Class.forName(&quot;java.security.AccessController&quot;, false, (ClassLoader)null);
&nbsp;                ACCESS_CONTROLLER = Boolean.parseBoolean(System.getProperty(&quot;net.bytebuddy.securitymanager&quot;, &quot;true&quot;));
&nbsp;            } catch (ClassNotFoundException var0) {
&nbsp;                ACCESS_CONTROLLER = false;
&nbsp;            } catch (SecurityException var1) {
&nbsp;                ACCESS_CONTROLLER = true;
&nbsp;            }
&nbsp;
&nbsp;            DISPATCHER = (Dispatcher)doPrivileged(JavaDispatcher.of(Dispatcher.class));
&nbsp;            TYPE_CACHE = new HashMap();
&nbsp;            TYPE_CACHE.put(TargetType.class, new ForLoadedType(TargetType.class));
&nbsp;            TYPE_CACHE.put(Object.class, new ForLoadedType(Object.class));
&nbsp;            TYPE_CACHE.put(String.class, new ForLoadedType(String.class));
&nbsp;            TYPE_CACHE.put(Boolean.class, new ForLoadedType(Boolean.class));
&nbsp;            TYPE_CACHE.put(Byte.class, new ForLoadedType(Byte.class));
&nbsp;            TYPE_CACHE.put(Short.class, new ForLoadedType(Short.class));
&nbsp;            TYPE_CACHE.put(Character.class, new ForLoadedType(Character.class));
&nbsp;            TYPE_CACHE.put(Integer.class, new ForLoadedType(Integer.class));
&nbsp;            TYPE_CACHE.put(Long.class, new ForLoadedType(Long.class));
&nbsp;            TYPE_CACHE.put(Float.class, new ForLoadedType(Float.class));
&nbsp;            TYPE_CACHE.put(Double.class, new ForLoadedType(Double.class));
&nbsp;            TYPE_CACHE.put(Void.TYPE, new ForLoadedType(Void.TYPE));
&nbsp;            TYPE_CACHE.put(Boolean.TYPE, new ForLoadedType(Boolean.TYPE));
&nbsp;            TYPE_CACHE.put(Byte.TYPE, new ForLoadedType(Byte.TYPE));
&nbsp;            TYPE_CACHE.put(Short.TYPE, new ForLoadedType(Short.TYPE));
&nbsp;            TYPE_CACHE.put(Character.TYPE, new ForLoadedType(Character.TYPE));
&nbsp;            TYPE_CACHE.put(Integer.TYPE, new ForLoadedType(Integer.TYPE));
&nbsp;            TYPE_CACHE.put(Long.TYPE, new ForLoadedType(Long.TYPE));
&nbsp;            TYPE_CACHE.put(Float.TYPE, new ForLoadedType(Float.TYPE));
&nbsp;            TYPE_CACHE.put(Double.TYPE, new ForLoadedType(Double.TYPE));
&nbsp;        }
&nbsp;
&nbsp;        @Defaults
&nbsp;        @Proxied(&quot;java.lang.Class&quot;)
&nbsp;        protected interface Dispatcher {
&nbsp;            @Nonnull(
&nbsp;                when = When.MAYBE
&nbsp;            )
&nbsp;            @Proxied(&quot;getAnnotatedSuperclass&quot;)
&nbsp;            AnnotatedElement getAnnotatedSuperclass(Class&lt;?&gt; var1);
&nbsp;
&nbsp;            @Proxied(&quot;getAnnotatedInterfaces&quot;)
&nbsp;            AnnotatedElement[] getAnnotatedInterfaces(Class&lt;?&gt; var1);
&nbsp;
&nbsp;            @Nonnull(
&nbsp;                when = When.MAYBE
&nbsp;            )
&nbsp;            @Proxied(&quot;getNestHost&quot;)
&nbsp;            Class&lt;?&gt; getNestHost(Class&lt;?&gt; var1);
&nbsp;
&nbsp;            @Proxied(&quot;getNestMembers&quot;)
&nbsp;            Class&lt;?&gt;[] getNestMembers(Class&lt;?&gt; var1);
&nbsp;
&nbsp;            @Proxied(&quot;isNestmateOf&quot;)
&nbsp;            boolean isNestmateOf(Class&lt;?&gt; var1, Class&lt;?&gt; var2);
&nbsp;
&nbsp;            @Proxied(&quot;isSealed&quot;)
&nbsp;            boolean isSealed(Class&lt;?&gt; var1);
&nbsp;
&nbsp;            @Nonnull(
&nbsp;                when = When.MAYBE
&nbsp;            )
&nbsp;            @Proxied(&quot;getPermittedSubclasses&quot;)
&nbsp;            Class&lt;?&gt;[] getPermittedSubclasses(Class&lt;?&gt; var1);
&nbsp;
&nbsp;            @Proxied(&quot;isRecord&quot;)
&nbsp;            boolean isRecord(Class&lt;?&gt; var1);
&nbsp;
&nbsp;            @Nonnull(
&nbsp;                when = When.MAYBE
&nbsp;            )
&nbsp;            @Proxied(&quot;getRecordComponents&quot;)
&nbsp;            Object[] getRecordComponents(Class&lt;?&gt; var1);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public abstract static class AbstractBase extends TypeVariableSource.AbstractBase implements TypeDescription {
&nbsp;        public static final boolean RAW_TYPES;
&nbsp;        private static final boolean ACCESS_CONTROLLER;
&nbsp;
&nbsp;        public AbstractBase() {
&nbsp;        }
&nbsp;
&nbsp;        @net.bytebuddy.build.AccessControllerPlugin.Enhance
&nbsp;        private static &lt;T&gt; T doPrivileged(PrivilegedAction&lt;T&gt; action) {
&nbsp;            return ACCESS_CONTROLLER ? AccessController.doPrivileged(action) : action.run();
&nbsp;        }
&nbsp;
&nbsp;        @SuppressFBWarnings(
&nbsp;            value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;            justification = &quot;Assuming component type for array type.&quot;
&nbsp;        )
&nbsp;        private static boolean isAssignable(TypeDescription sourceType, TypeDescription targetType) {
&nbsp;            if (sourceType.equals(targetType)) {
&nbsp;                return true;
&nbsp;            } else if (targetType.isArray()) {
&nbsp;                return sourceType.isArray() ? isAssignable(sourceType.getComponentType(), targetType.getComponentType()) : sourceType.represents(Object.class) || ARRAY_INTERFACES.contains(sourceType.asGenericType());
&nbsp;            } else if (sourceType.represents(Object.class)) {
&nbsp;                return !targetType.isPrimitive();
&nbsp;            } else {
&nbsp;                Generic superClass = targetType.getSuperClass();
&nbsp;                if (superClass != null &amp;&amp; sourceType.isAssignableFrom(superClass.asErasure())) {
&nbsp;                    return true;
&nbsp;                } else {
&nbsp;                    if (sourceType.isInterface()) {
&nbsp;                        Iterator var3 = targetType.getInterfaces().asErasures().iterator();
&nbsp;
&nbsp;                        while(var3.hasNext()) {
&nbsp;                            TypeDescription interfaceType = (TypeDescription)var3.next();
&nbsp;                            if (sourceType.isAssignableFrom(interfaceType)) {
&nbsp;                                return true;
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    return false;
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public boolean isAssignableFrom(Class&lt;?&gt; type) {
&nbsp;            return this.isAssignableFrom(TypeDescription.ForLoadedType.of(type));
&nbsp;        }
&nbsp;
&nbsp;        public boolean isAssignableFrom(TypeDescription typeDescription) {
&nbsp;            return isAssignable(this, typeDescription);
&nbsp;        }
&nbsp;
&nbsp;        public boolean isAssignableTo(Class&lt;?&gt; type) {
&nbsp;            return this.isAssignableTo(TypeDescription.ForLoadedType.of(type));
&nbsp;        }
&nbsp;
&nbsp;        public boolean isAssignableTo(TypeDescription typeDescription) {
&nbsp;            return isAssignable(typeDescription, this);
&nbsp;        }
&nbsp;
&nbsp;        public boolean isInHierarchyWith(Class&lt;?&gt; type) {
&nbsp;            return this.isAssignableTo(type) || this.isAssignableFrom(type);
&nbsp;        }
&nbsp;
&nbsp;        public boolean isInHierarchyWith(TypeDescription typeDescription) {
&nbsp;            return this.isAssignableTo(typeDescription) || this.isAssignableFrom(typeDescription);
&nbsp;        }
&nbsp;
&nbsp;        public TypeDescription asErasure() {
&nbsp;            return this;
&nbsp;        }
&nbsp;
&nbsp;        public Generic asGenericType() {
&nbsp;            return new Generic.OfNonGenericType.ForErasure(this);
&nbsp;        }
&nbsp;
&nbsp;        public TypeDefinition.Sort getSort() {
&nbsp;            return Sort.NON_GENERIC;
&nbsp;        }
&nbsp;
&nbsp;        public boolean isInstance(Object value) {
&nbsp;            return this.isAssignableFrom(value.getClass());
&nbsp;        }
&nbsp;
&nbsp;        public boolean isAnnotationValue(Object value) {
&nbsp;            if (this.represents(Class.class) &amp;&amp; value instanceof TypeDescription || value instanceof AnnotationDescription &amp;&amp; ((AnnotationDescription)value).getAnnotationType().equals(this) || value instanceof EnumerationDescription &amp;&amp; ((EnumerationDescription)value).getEnumerationType().equals(this) || this.represents(String.class) &amp;&amp; value instanceof String || this.represents(Boolean.TYPE) &amp;&amp; value instanceof Boolean || this.represents(Byte.TYPE) &amp;&amp; value instanceof Byte || this.represents(Short.TYPE) &amp;&amp; value instanceof Short || this.represents(Character.TYPE) &amp;&amp; value instanceof Character || this.represents(Integer.TYPE) &amp;&amp; value instanceof Integer || this.represents(Long.TYPE) &amp;&amp; value instanceof Long || this.represents(Float.TYPE) &amp;&amp; value instanceof Float || this.represents(Double.TYPE) &amp;&amp; value instanceof Double || this.represents(String[].class) &amp;&amp; value instanceof String[] || this.represents(boolean[].class) &amp;&amp; value instanceof boolean[] || this.represents(byte[].class) &amp;&amp; value instanceof byte[] || this.represents(short[].class) &amp;&amp; value instanceof short[] || this.represents(char[].class) &amp;&amp; value instanceof char[] || this.represents(int[].class) &amp;&amp; value instanceof int[] || this.represents(long[].class) &amp;&amp; value instanceof long[] || this.represents(float[].class) &amp;&amp; value instanceof float[] || this.represents(double[].class) &amp;&amp; value instanceof double[] || this.represents(Class[].class) &amp;&amp; value instanceof TypeDescription[]) {
&nbsp;                return true;
&nbsp;            } else {
&nbsp;                int var3;
&nbsp;                int var4;
&nbsp;                if (this.isAssignableTo(Annotation[].class) &amp;&amp; value instanceof AnnotationDescription[]) {
&nbsp;                    AnnotationDescription[] var6 = (AnnotationDescription[])((AnnotationDescription[])value);
&nbsp;                    var3 = var6.length;
&nbsp;
&nbsp;                    for(var4 = 0; var4 &lt; var3; ++var4) {
&nbsp;                        AnnotationDescription annotationDescription = var6[var4];
&nbsp;                        if (!annotationDescription.getAnnotationType().equals(this.getComponentType())) {
&nbsp;                            return false;
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    return true;
&nbsp;                } else if (this.isAssignableTo(Enum[].class) &amp;&amp; value instanceof EnumerationDescription[]) {
&nbsp;                    EnumerationDescription[] var2 = (EnumerationDescription[])((EnumerationDescription[])value);
&nbsp;                    var3 = var2.length;
&nbsp;
&nbsp;                    for(var4 = 0; var4 &lt; var3; ++var4) {
&nbsp;                        EnumerationDescription enumerationDescription = var2[var4];
&nbsp;                        if (!enumerationDescription.getEnumerationType().equals(this.getComponentType())) {
&nbsp;                            return false;
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    return true;
&nbsp;                } else {
&nbsp;                    return false;
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public String getInternalName() {
&nbsp;            return this.getName().replace(&#39;.&#39;, &#39;/&#39;);
&nbsp;        }
&nbsp;
&nbsp;        public int getActualModifiers(boolean superFlag) {
&nbsp;            int actualModifiers = this.getModifiers() | (this.getDeclaredAnnotations().isAnnotationPresent(Deprecated.class) ? 131072 : 0) | (this.isRecord() ? 65536 : 0) | (superFlag ? 32 : 0);
&nbsp;            if (this.isPrivate()) {
&nbsp;                return actualModifiers &amp; -11;
&nbsp;            } else {
&nbsp;                return this.isProtected() ? actualModifiers &amp; -13 | 1 : actualModifiers &amp; -9;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Nonnull(
&nbsp;            when = When.MAYBE
&nbsp;        )
&nbsp;        public String getGenericSignature() {
&nbsp;            try {
&nbsp;                SignatureWriter signatureWriter = new SignatureWriter();
&nbsp;                boolean generic = false;
&nbsp;
&nbsp;                for(Iterator var3 = this.getTypeVariables().iterator(); var3.hasNext(); generic = true) {
&nbsp;                    Generic typeVariable = (Generic)var3.next();
&nbsp;                    signatureWriter.visitFormalTypeParameter(typeVariable.getSymbol());
&nbsp;                    Iterator var5 = typeVariable.getUpperBounds().iterator();
&nbsp;
&nbsp;                    while(var5.hasNext()) {
&nbsp;                        Generic upperBound = (Generic)var5.next();
&nbsp;                        upperBound.accept(new Generic.Visitor.ForSignatureVisitor(upperBound.asErasure().isInterface() ? signatureWriter.visitInterfaceBound() : signatureWriter.visitClassBound()));
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                Generic superClass = this.getSuperClass();
&nbsp;                if (superClass == null) {
&nbsp;                    superClass = TypeDescription.Generic.OBJECT;
&nbsp;                }
&nbsp;
&nbsp;                superClass.accept(new Generic.Visitor.ForSignatureVisitor(signatureWriter.visitSuperclass()));
&nbsp;                generic = generic || !superClass.getSort().isNonGeneric();
&nbsp;
&nbsp;                Generic interfaceType;
&nbsp;                for(Iterator var9 = this.getInterfaces().iterator(); var9.hasNext(); generic = generic || !interfaceType.getSort().isNonGeneric()) {
&nbsp;                    interfaceType = (Generic)var9.next();
&nbsp;                    interfaceType.accept(new Generic.Visitor.ForSignatureVisitor(signatureWriter.visitInterface()));
&nbsp;                }
&nbsp;
&nbsp;                return generic ? signatureWriter.toString() : NON_GENERIC_SIGNATURE;
&nbsp;            } catch (GenericSignatureFormatError var7) {
&nbsp;                return NON_GENERIC_SIGNATURE;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public boolean isSamePackage(TypeDescription typeDescription) {
&nbsp;            PackageDescription thisPackage = this.getPackage();
&nbsp;            PackageDescription otherPackage = typeDescription.getPackage();
&nbsp;            return thisPackage != null &amp;&amp; otherPackage != null ? thisPackage.equals(otherPackage) : thisPackage == otherPackage;
&nbsp;        }
&nbsp;
&nbsp;        @SuppressFBWarnings(
&nbsp;            value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;            justification = &quot;Assuming component type for array type.&quot;
&nbsp;        )
&nbsp;        public boolean isVisibleTo(TypeDescription typeDescription) {
&nbsp;            boolean var10000;
&nbsp;            if (!this.isPrimitive()) {
&nbsp;                label36: {
&nbsp;                    if (this.isArray()) {
&nbsp;                        if (this.getComponentType().isVisibleTo(typeDescription)) {
&nbsp;                            break label36;
&nbsp;                        }
&nbsp;                    } else if (this.isPublic() || this.isProtected() || this.isSamePackage(typeDescription)) {
&nbsp;                        break label36;
&nbsp;                    }
&nbsp;
&nbsp;                    var10000 = false;
&nbsp;                    return var10000;
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            var10000 = true;
&nbsp;            return var10000;
&nbsp;        }
&nbsp;
&nbsp;        @SuppressFBWarnings(
&nbsp;            value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;            justification = &quot;Assuming component type for array type.&quot;
&nbsp;        )
&nbsp;        public boolean isAccessibleTo(TypeDescription typeDescription) {
&nbsp;            boolean var10000;
&nbsp;            if (!this.isPrimitive()) {
&nbsp;                label32: {
&nbsp;                    if (this.isArray()) {
&nbsp;                        if (this.getComponentType().isVisibleTo(typeDescription)) {
&nbsp;                            break label32;
&nbsp;                        }
&nbsp;                    } else if (this.isPublic() || this.isSamePackage(typeDescription)) {
&nbsp;                        break label32;
&nbsp;                    }
&nbsp;
&nbsp;                    var10000 = false;
&nbsp;                    return var10000;
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            var10000 = true;
&nbsp;            return var10000;
&nbsp;        }
&nbsp;
&nbsp;        public AnnotationList getInheritedAnnotations() {
&nbsp;            Generic superClass = this.getSuperClass();
&nbsp;            AnnotationList declaredAnnotations = this.getDeclaredAnnotations();
&nbsp;            if (superClass == null) {
&nbsp;                return declaredAnnotations;
&nbsp;            } else {
&nbsp;                Set&lt;TypeDescription&gt; annotationTypes = new HashSet();
&nbsp;                Iterator var4 = declaredAnnotations.iterator();
&nbsp;
&nbsp;                while(var4.hasNext()) {
&nbsp;                    AnnotationDescription annotationDescription = (AnnotationDescription)var4.next();
&nbsp;                    annotationTypes.add(annotationDescription.getAnnotationType());
&nbsp;                }
&nbsp;
&nbsp;                return new AnnotationList.Explicit(CompoundList.of(declaredAnnotations, superClass.asErasure().getInheritedAnnotations().inherited(annotationTypes)));
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @SuppressFBWarnings(
&nbsp;            value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;            justification = &quot;Assuming component type for array type.&quot;
&nbsp;        )
&nbsp;        public String getActualName() {
&nbsp;            if (!this.isArray()) {
&nbsp;                return this.getName();
&nbsp;            } else {
&nbsp;                TypeDescription typeDescription = this;
&nbsp;                int dimensions = 0;
&nbsp;
&nbsp;                do {
&nbsp;                    ++dimensions;
&nbsp;                    typeDescription = ((TypeDescription)typeDescription).getComponentType();
&nbsp;                } while(((TypeDescription)typeDescription).isArray());
&nbsp;
&nbsp;                StringBuilder stringBuilder = new StringBuilder();
&nbsp;                stringBuilder.append(((TypeDescription)typeDescription).getActualName());
&nbsp;
&nbsp;                for(int i = 0; i &lt; dimensions; ++i) {
&nbsp;                    stringBuilder.append(&quot;[]&quot;);
&nbsp;                }
&nbsp;
&nbsp;                return stringBuilder.toString();
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public boolean isPrimitiveWrapper() {
&nbsp;            return this.represents(Boolean.class) || this.represents(Byte.class) || this.represents(Short.class) || this.represents(Character.class) || this.represents(Integer.class) || this.represents(Long.class) || this.represents(Float.class) || this.represents(Double.class);
&nbsp;        }
&nbsp;
&nbsp;        @SuppressFBWarnings(
&nbsp;            value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;            justification = &quot;Assuming component type for array type.&quot;
&nbsp;        )
&nbsp;        public boolean isAnnotationReturnType() {
&nbsp;            return this.isPrimitive() || this.represents(String.class) || this.isAssignableTo(Enum.class) &amp;&amp; !this.represents(Enum.class) || this.isAssignableTo(Annotation.class) &amp;&amp; !this.represents(Annotation.class) || this.represents(Class.class) || this.isArray() &amp;&amp; !this.getComponentType().isArray() &amp;&amp; this.getComponentType().isAnnotationReturnType();
&nbsp;        }
&nbsp;
&nbsp;        @SuppressFBWarnings(
&nbsp;            value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;            justification = &quot;Assuming component type for array type.&quot;
&nbsp;        )
&nbsp;        public boolean isAnnotationValue() {
&nbsp;            return this.isPrimitive() || this.represents(String.class) || this.isAssignableTo(TypeDescription.class) || this.isAssignableTo(AnnotationDescription.class) || this.isAssignableTo(EnumerationDescription.class) || this.isArray() &amp;&amp; !this.getComponentType().isArray() &amp;&amp; this.getComponentType().isAnnotationValue();
&nbsp;        }
&nbsp;
&nbsp;        @SuppressFBWarnings(
&nbsp;            value = {&quot;EC_UNRELATED_CLASS_AND_INTERFACE&quot;},
&nbsp;            justification = &quot;Fits equality contract for type definitions.&quot;
&nbsp;        )
&nbsp;        public boolean represents(Type type) {
&nbsp;            return this.equals(Sort.describe(type));
&nbsp;        }
&nbsp;
&nbsp;        public String getTypeName() {
&nbsp;            return this.getName();
&nbsp;        }
&nbsp;
&nbsp;        @Nonnull(
&nbsp;            when = When.MAYBE
&nbsp;        )
&nbsp;        public TypeVariableSource getEnclosingSource() {
&nbsp;            MethodDescription enclosingMethod = this.getEnclosingMethod();
&nbsp;            return (TypeVariableSource)(enclosingMethod == null ? (this.isStatic() ? TypeVariableSource.UNDEFINED : this.getEnclosingType()) : enclosingMethod);
&nbsp;        }
&nbsp;
&nbsp;        public boolean isInferrable() {
&nbsp;            return false;
&nbsp;        }
&nbsp;
&nbsp;        public &lt;T&gt; T accept(TypeVariableSource.Visitor&lt;T&gt; visitor) {
&nbsp;            return visitor.onType(this);
&nbsp;        }
&nbsp;
&nbsp;        public boolean isPackageType() {
&nbsp;            return this.getSimpleName().equals(&quot;package-info&quot;);
&nbsp;        }
&nbsp;
&nbsp;        public boolean isGenerified() {
&nbsp;            if (!this.getTypeVariables().isEmpty()) {
&nbsp;                return true;
&nbsp;            } else if (this.isStatic()) {
&nbsp;                return false;
&nbsp;            } else {
<b class="fc">&nbsp;                TypeDescription declaringType = this.getDeclaringType();</b>
&nbsp;                return declaringType != null &amp;&amp; declaringType.isGenerified();
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public int getInnerClassCount() {
<b class="fc">&nbsp;            if (this.isStatic()) {</b>
&nbsp;                return 0;
&nbsp;            } else {
&nbsp;                TypeDescription declaringType = this.getDeclaringType();
&nbsp;                return declaringType == null ? 0 : declaringType.getInnerClassCount() + 1;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public boolean isInnerClass() {
&nbsp;            return !this.isStatic() &amp;&amp; this.isNestedClass();
&nbsp;        }
<b class="fc">&nbsp;</b>
&nbsp;        public boolean isNestedClass() {
&nbsp;            return this.getDeclaringType() != null;
&nbsp;        }
&nbsp;
&nbsp;        public TypeDescription asBoxed() {
&nbsp;            if (this.represents(Boolean.TYPE)) {
&nbsp;                return TypeDescription.ForLoadedType.of(Boolean.class);
&nbsp;            } else if (this.represents(Byte.TYPE)) {
&nbsp;                return TypeDescription.ForLoadedType.of(Byte.class);
&nbsp;            } else if (this.represents(Short.TYPE)) {
&nbsp;                return TypeDescription.ForLoadedType.of(Short.class);
&nbsp;            } else if (this.represents(Character.TYPE)) {
&nbsp;                return TypeDescription.ForLoadedType.of(Character.class);
&nbsp;            } else if (this.represents(Integer.TYPE)) {
&nbsp;                return TypeDescription.ForLoadedType.of(Integer.class);
&nbsp;            } else if (this.represents(Long.TYPE)) {
&nbsp;                return TypeDescription.ForLoadedType.of(Long.class);
&nbsp;            } else if (this.represents(Float.TYPE)) {
&nbsp;                return TypeDescription.ForLoadedType.of(Float.class);
&nbsp;            } else {
&nbsp;                return (TypeDescription)(this.represents(Double.TYPE) ? TypeDescription.ForLoadedType.of(Double.class) : this);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public TypeDescription asUnboxed() {
&nbsp;            if (this.represents(Boolean.class)) {
&nbsp;                return TypeDescription.ForLoadedType.of(Boolean.TYPE);
&nbsp;            } else if (this.represents(Byte.class)) {
&nbsp;                return TypeDescription.ForLoadedType.of(Byte.TYPE);
&nbsp;            } else if (this.represents(Short.class)) {
&nbsp;                return TypeDescription.ForLoadedType.of(Short.TYPE);
<b class="fc">&nbsp;            } else if (this.represents(Character.class)) {</b>
<b class="fc">&nbsp;                return TypeDescription.ForLoadedType.of(Character.TYPE);</b>
&nbsp;            } else if (this.represents(Integer.class)) {
&nbsp;                return TypeDescription.ForLoadedType.of(Integer.TYPE);
&nbsp;            } else if (this.represents(Long.class)) {
&nbsp;                return TypeDescription.ForLoadedType.of(Long.TYPE);
&nbsp;            } else if (this.represents(Float.class)) {
&nbsp;                return TypeDescription.ForLoadedType.of(Float.TYPE);
&nbsp;            } else {
&nbsp;                return (TypeDescription)(this.represents(Double.class) ? TypeDescription.ForLoadedType.of(Double.TYPE) : this);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Nonnull(
&nbsp;            when = When.MAYBE
&nbsp;        )
&nbsp;        public Object getDefaultValue() {
&nbsp;            if (this.represents(Boolean.TYPE)) {
&nbsp;                return false;
&nbsp;            } else if (this.represents(Byte.TYPE)) {
&nbsp;                return 0;
&nbsp;            } else if (this.represents(Short.TYPE)) {
&nbsp;                return Short.valueOf((short)0);
&nbsp;            } else if (this.represents(Character.TYPE)) {
&nbsp;                return &#39;\u0000&#39;;
&nbsp;            } else if (this.represents(Integer.TYPE)) {
&nbsp;                return 0;
&nbsp;            } else if (this.represents(Long.TYPE)) {
<b class="fc">&nbsp;                return 0L;</b>
<b class="fc">&nbsp;            } else if (this.represents(Float.TYPE)) {</b>
&nbsp;                return 0.0F;
&nbsp;            } else {
&nbsp;                return this.represents(Double.TYPE) ? 0.0 : null;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public boolean isNestHost() {
&nbsp;            return this.equals(this.getNestHost());
&nbsp;        }
&nbsp;
&nbsp;        public boolean isNestMateOf(Class&lt;?&gt; type) {
&nbsp;            return this.isNestMateOf(TypeDescription.ForLoadedType.of(type));
&nbsp;        }
&nbsp;
&nbsp;        public boolean isNestMateOf(TypeDescription typeDescription) {
&nbsp;            return this.getNestHost().equals(typeDescription.getNestHost());
&nbsp;        }
&nbsp;
&nbsp;        public boolean isMemberType() {
&nbsp;            return !this.isLocalType() &amp;&amp; !this.isAnonymousType() &amp;&amp; this.getDeclaringType() != null;
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        public boolean isCompileTimeConstant() {</b>
<b class="fc">&nbsp;            return this.represents(Integer.TYPE) || this.represents(Long.TYPE) || this.represents(Float.TYPE) || this.represents(Double.TYPE) || this.represents(String.class) || this.represents(Class.class) || this.equals(JavaType.METHOD_TYPE.getTypeStub()) || this.equals(JavaType.METHOD_HANDLE.getTypeStub());</b>
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        public boolean isSealed() {
&nbsp;            return !this.isPrimitive() &amp;&amp; !this.isArray() &amp;&amp; !this.getPermittedSubtypes().isEmpty();
&nbsp;        }
&nbsp;
&nbsp;        @Nonnull(
&nbsp;            when = When.MAYBE
&nbsp;        )
<b class="fc">&nbsp;        public ClassFileVersion getClassFileVersion() {</b>
<b class="fc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        public Iterator&lt;TypeDefinition&gt; iterator() {
<b class="fc">&nbsp;            return new TypeDefinition.SuperClassIterator(this);</b>
&nbsp;        }
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;        @Enhance(&quot;hashCode&quot;)</b>
<b class="fc">&nbsp;        public int hashCode() {</b>
&nbsp;            int var1 = this.hashCode;
&nbsp;            int var2 = var1 != 0 ? 0 : this.getName().hashCode();
&nbsp;            if (var2 == 0) {
&nbsp;                var2 = this.hashCode;
&nbsp;            } else {
&nbsp;                this.hashCode = var2;
&nbsp;            }
&nbsp;
&nbsp;            return var2;
&nbsp;        }
&nbsp;
&nbsp;        public boolean equals(@CheckForNull Object other) {
&nbsp;            if (this == other) {
&nbsp;                return true;
&nbsp;            } else if (!(other instanceof TypeDefinition)) {
<b class="fc">&nbsp;                return false;</b>
&nbsp;            } else {
<b class="fc">&nbsp;                TypeDefinition typeDefinition = (TypeDefinition)other;</b>
<b class="fc">&nbsp;                return typeDefinition.getSort().isNonGeneric() &amp;&amp; this.getName().equals(typeDefinition.asErasure().getName());</b>
&nbsp;            }
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;</b>
&nbsp;        public String toString() {
<b class="fc">&nbsp;            return (this.isPrimitive() ? &quot;&quot; : (this.isInterface() ? &quot;interface&quot; : &quot;class&quot;) + &quot; &quot;) + this.getName();</b>
&nbsp;        }
&nbsp;
&nbsp;        static {
&nbsp;            try {
&nbsp;                Class.forName(&quot;java.security.AccessController&quot;, false, (ClassLoader)null);
&nbsp;                ACCESS_CONTROLLER = Boolean.parseBoolean(System.getProperty(&quot;net.bytebuddy.securitymanager&quot;, &quot;true&quot;));
&nbsp;            } catch (ClassNotFoundException var3) {
&nbsp;                ACCESS_CONTROLLER = false;
&nbsp;            } catch (SecurityException var4) {
&nbsp;                ACCESS_CONTROLLER = true;
&nbsp;            }
&nbsp;
&nbsp;            boolean rawTypes;
<b class="fc">&nbsp;            try {</b>
&nbsp;                rawTypes = Boolean.parseBoolean((String)doPrivileged(new GetSystemPropertyAction(&quot;net.bytebuddy.raw&quot;)));
&nbsp;            } catch (Exception var2) {
&nbsp;                rawTypes = false;
&nbsp;            }
&nbsp;
&nbsp;            RAW_TYPES = rawTypes;
&nbsp;        }
&nbsp;
&nbsp;        public abstract static class OfSimpleType extends AbstractBase {
&nbsp;            public OfSimpleType() {
&nbsp;            }
&nbsp;
&nbsp;            public boolean isPrimitive() {
&nbsp;                return false;
&nbsp;            }
&nbsp;
&nbsp;            public boolean isArray() {
&nbsp;                return false;
&nbsp;            }
&nbsp;
&nbsp;            @Nonnull(
&nbsp;                when = When.MAYBE
&nbsp;            )
&nbsp;            public TypeDescription getComponentType() {
&nbsp;                return TypeDescription.UNDEFINED;
&nbsp;            }
&nbsp;
&nbsp;            public String getDescriptor() {
&nbsp;                return &quot;L&quot; + this.getInternalName() + &quot;;&quot;;
&nbsp;            }
&nbsp;
&nbsp;            @Nonnull(
&nbsp;                when = When.MAYBE
&nbsp;            )
&nbsp;            public String getCanonicalName() {
&nbsp;                if (!this.isAnonymousType() &amp;&amp; !this.isLocalType()) {
&nbsp;                    String internalName = this.getInternalName();
&nbsp;                    TypeDescription enclosingType = this.getEnclosingType();
&nbsp;                    return enclosingType != null &amp;&amp; internalName.startsWith(enclosingType.getInternalName() + &quot;$&quot;) ? enclosingType.getCanonicalName() + &quot;.&quot; + internalName.substring(enclosingType.getInternalName().length() + 1) : this.getName();
&nbsp;                } else {
&nbsp;                    return NO_NAME;
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public String getSimpleName() {
<b class="fc">&nbsp;                String internalName = this.getInternalName();</b>
<b class="fc">&nbsp;                TypeDescription enclosingType = this.getEnclosingType();</b>
&nbsp;                int simpleNameIndex;
&nbsp;                if (enclosingType != null &amp;&amp; internalName.startsWith(enclosingType.getInternalName() + &quot;$&quot;)) {
&nbsp;                    simpleNameIndex = enclosingType.getInternalName().length() + 1;
&nbsp;                } else {
&nbsp;                    simpleNameIndex = internalName.lastIndexOf(47);
&nbsp;                    if (simpleNameIndex == -1) {
&nbsp;                        return internalName;
&nbsp;                    }
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                while(simpleNameIndex &lt; internalName.length() &amp;&amp; !Character.isLetter(internalName.charAt(simpleNameIndex))) {
&nbsp;                    ++simpleNameIndex;
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                return internalName.substring(simpleNameIndex);</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;            public StackSize getStackSize() {</b>
<b class="fc">&nbsp;                return StackSize.SINGLE;</b>
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            public abstract static class WithDelegation extends OfSimpleType {
&nbsp;                public WithDelegation() {
&nbsp;                }
&nbsp;
&nbsp;                protected abstract TypeDescription delegate();
&nbsp;
&nbsp;                public Generic getSuperClass() {
&nbsp;                    return this.delegate().getSuperClass();
&nbsp;                }
&nbsp;
&nbsp;                public TypeList.Generic getInterfaces() {
&nbsp;                    return this.delegate().getInterfaces();
&nbsp;                }
&nbsp;
&nbsp;                public FieldList&lt;FieldDescription.InDefinedShape&gt; getDeclaredFields() {
&nbsp;                    return this.delegate().getDeclaredFields();
&nbsp;                }
&nbsp;
&nbsp;                public MethodList&lt;MethodDescription.InDefinedShape&gt; getDeclaredMethods() {
&nbsp;                    return this.delegate().getDeclaredMethods();
&nbsp;                }
&nbsp;
&nbsp;                @Nonnull(
&nbsp;                    when = When.MAYBE
&nbsp;                )
&nbsp;                public TypeDescription getDeclaringType() {
<b class="fc">&nbsp;                    return this.delegate().getDeclaringType();</b>
&nbsp;                }
<b class="fc">&nbsp;</b>
&nbsp;                @Nonnull(
&nbsp;                    when = When.MAYBE
&nbsp;                )
&nbsp;                public MethodDescription.InDefinedShape getEnclosingMethod() {
&nbsp;                    return this.delegate().getEnclosingMethod();
&nbsp;                }
&nbsp;
&nbsp;                @Nonnull(
&nbsp;                    when = When.MAYBE
&nbsp;                )
&nbsp;                public TypeDescription getEnclosingType() {
&nbsp;                    return this.delegate().getEnclosingType();
&nbsp;                }
<b class="fc">&nbsp;</b>
&nbsp;                public TypeList getDeclaredTypes() {
&nbsp;                    return this.delegate().getDeclaredTypes();
&nbsp;                }
&nbsp;
&nbsp;                public boolean isAnonymousType() {
<b class="fc">&nbsp;                    return this.delegate().isAnonymousType();</b>
&nbsp;                }
&nbsp;
&nbsp;                public boolean isLocalType() {
&nbsp;                    return this.delegate().isLocalType();
&nbsp;                }
&nbsp;
&nbsp;                @Nonnull(
&nbsp;                    when = When.MAYBE
&nbsp;                )
&nbsp;                public PackageDescription getPackage() {
&nbsp;                    return this.delegate().getPackage();
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationList getDeclaredAnnotations() {
&nbsp;                    return this.delegate().getDeclaredAnnotations();
&nbsp;                }
&nbsp;
&nbsp;                public TypeList.Generic getTypeVariables() {
&nbsp;                    return this.delegate().getTypeVariables();
&nbsp;                }
&nbsp;
&nbsp;                public int getModifiers() {
&nbsp;                    return this.delegate().getModifiers();
&nbsp;                }
&nbsp;
&nbsp;                @Nonnull(
&nbsp;                    when = When.MAYBE
&nbsp;                )
&nbsp;                public String getGenericSignature() {
&nbsp;                    return this.delegate().getGenericSignature();
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                public int getActualModifiers(boolean superFlag) {</b>
&nbsp;                    return this.delegate().getActualModifiers(superFlag);
&nbsp;                }
&nbsp;
&nbsp;                public TypeDescription getNestHost() {
&nbsp;                    return this.delegate().getNestHost();
&nbsp;                }
&nbsp;
&nbsp;                public TypeList getNestMembers() {
<b class="fc">&nbsp;                    return this.delegate().getNestMembers();</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;</b>
&nbsp;                public RecordComponentList&lt;RecordComponentDescription.InDefinedShape&gt; getRecordComponents() {
&nbsp;                    return this.delegate().getRecordComponents();
&nbsp;                }
&nbsp;
&nbsp;                public boolean isRecord() {
&nbsp;                    return this.delegate().isRecord();
&nbsp;                }
&nbsp;
&nbsp;                public boolean isSealed() {
<b class="fc">&nbsp;                    return this.delegate().isSealed();</b>
&nbsp;                }
&nbsp;
&nbsp;                public TypeList getPermittedSubtypes() {
&nbsp;                    return this.delegate().getPermittedSubtypes();
&nbsp;                }
&nbsp;
&nbsp;                @Nonnull(
&nbsp;                    when = When.MAYBE
&nbsp;                )
&nbsp;                public ClassFileVersion getClassFileVersion() {
<b class="fc">&nbsp;                    return this.delegate().getClassFileVersion();</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public interface Generic extends TypeDefinition, AnnotationSource {
&nbsp;        Generic OBJECT = new OfNonGenericType.ForLoadedType(Object.class);
&nbsp;        Generic CLASS = new OfNonGenericType.ForLoadedType(Class.class);
&nbsp;        Generic VOID = new OfNonGenericType.ForLoadedType(Void.TYPE);
<b class="fc">&nbsp;        Generic ANNOTATION = new OfNonGenericType.ForLoadedType(Annotation.class);</b>
&nbsp;        @Nonnull(
&nbsp;            when = When.NEVER
&nbsp;        )
&nbsp;        Generic UNDEFINED = null;
&nbsp;
&nbsp;        Generic asRawType();
&nbsp;
&nbsp;        TypeList.Generic getUpperBounds();
&nbsp;
<b class="fc">&nbsp;        TypeList.Generic getLowerBounds();</b>
&nbsp;
&nbsp;        TypeList.Generic getTypeArguments();
&nbsp;
&nbsp;        @Nonnull(
&nbsp;            when = When.MAYBE
&nbsp;        )
&nbsp;        Generic getOwnerType();
&nbsp;
&nbsp;        @Nonnull(
&nbsp;            when = When.MAYBE
&nbsp;        )
&nbsp;        Generic findBindingOf(Generic var1);
&nbsp;
&nbsp;        TypeVariableSource getTypeVariableSource();
&nbsp;
&nbsp;        String getSymbol();
&nbsp;
&nbsp;        @Nonnull(
&nbsp;            when = When.MAYBE
&nbsp;        )
&nbsp;        Generic getComponentType();
<b class="fc">&nbsp;</b>
&nbsp;        FieldList&lt;FieldDescription.InGenericShape&gt; getDeclaredFields();
&nbsp;
&nbsp;        MethodList&lt;MethodDescription.InGenericShape&gt; getDeclaredMethods();
&nbsp;
&nbsp;        RecordComponentList&lt;RecordComponentDescription.InGenericShape&gt; getRecordComponents();
&nbsp;
&nbsp;        &lt;T&gt; T accept(Visitor&lt;T&gt; var1);
&nbsp;
&nbsp;        @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;        public abstract static class Builder {
&nbsp;            @Nonnull(
&nbsp;                when = When.NEVER
&nbsp;            )
&nbsp;            private static final Type UNDEFINED = null;
&nbsp;            protected final List&lt;? extends AnnotationDescription&gt; annotations;
&nbsp;
&nbsp;            protected Builder(List&lt;? extends AnnotationDescription&gt; annotations) {
&nbsp;                this.annotations = annotations;
&nbsp;            }
&nbsp;
&nbsp;            public static Builder of(Type type) {
&nbsp;                return of(Sort.describe(type));
&nbsp;            }
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;            public static Builder of(Generic typeDescription) {</b>
&nbsp;                return (Builder)typeDescription.accept(TypeDescription.Generic.Builder.Visitor.INSTANCE);
&nbsp;            }
&nbsp;
&nbsp;            public static Builder rawType(Class&lt;?&gt; type) {
&nbsp;                return rawType(TypeDescription.ForLoadedType.of(type));
&nbsp;            }
&nbsp;
&nbsp;            public static Builder rawType(TypeDescription type) {
&nbsp;                return new OfNonGenericType(type);
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            public static Builder rawType(Class&lt;?&gt; type, @Nonnull(when = When.MAYBE) Generic ownerType) {
&nbsp;                return rawType(TypeDescription.ForLoadedType.of(type), ownerType);
&nbsp;            }
&nbsp;
&nbsp;            public static Builder rawType(TypeDescription type, @Nonnull(when = When.MAYBE) Generic ownerType) {
&nbsp;                TypeDescription declaringType = type.getDeclaringType();
&nbsp;                if (declaringType == null &amp;&amp; ownerType != null) {
&nbsp;                    throw new IllegalArgumentException(type + &quot; does not have a declaring type: &quot; + ownerType);
&nbsp;                } else if (declaringType == null || ownerType != null &amp;&amp; declaringType.equals(ownerType.asErasure())) {
&nbsp;                    return new OfNonGenericType(type, ownerType);
<b class="fc">&nbsp;                } else {</b>
&nbsp;                    throw new IllegalArgumentException(ownerType + &quot; is not the declaring type of &quot; + type);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public static Generic unboundWildcard() {
&nbsp;                return unboundWildcard((Collection)Collections.emptySet());
&nbsp;            }
&nbsp;
&nbsp;            public static Generic unboundWildcard(Annotation... annotation) {
&nbsp;                return unboundWildcard(Arrays.asList(annotation));
&nbsp;            }
&nbsp;
&nbsp;            public static Generic unboundWildcard(List&lt;? extends Annotation&gt; annotations) {
&nbsp;                return unboundWildcard((Collection)(new AnnotationList.ForLoadedAnnotations(annotations)));
&nbsp;            }
&nbsp;
&nbsp;            public static Generic unboundWildcard(AnnotationDescription... annotation) {
&nbsp;                return unboundWildcard((Collection)Arrays.asList(annotation));
&nbsp;            }
&nbsp;
&nbsp;            public static Generic unboundWildcard(Collection&lt;? extends AnnotationDescription&gt; annotations) {
&nbsp;                return TypeDescription.Generic.OfWildcardType.Latent.unbounded(new AnnotationSource.Explicit(new ArrayList(annotations)));
&nbsp;            }
&nbsp;
&nbsp;            public static Builder typeVariable(String symbol) {
&nbsp;                return new OfTypeVariable(symbol);
&nbsp;            }
&nbsp;
&nbsp;            public static Builder parameterizedType(Class&lt;?&gt; rawType, Type... parameter) {
&nbsp;                return parameterizedType(rawType, Arrays.asList(parameter));
&nbsp;            }
&nbsp;
&nbsp;            public static Builder parameterizedType(Class&lt;?&gt; rawType, List&lt;? extends Type&gt; parameters) {
&nbsp;                return parameterizedType(rawType, UNDEFINED, parameters);
&nbsp;            }
&nbsp;
&nbsp;            public static Builder parameterizedType(Class&lt;?&gt; rawType, @Nonnull(when = When.MAYBE) Type ownerType, List&lt;? extends Type&gt; parameters) {
&nbsp;                return parameterizedType((TypeDescription)TypeDescription.ForLoadedType.of(rawType), (Generic)(ownerType == null ? null : Sort.describe(ownerType)), (Collection)(new TypeList.ForLoadedTypes(parameters)));
&nbsp;            }
&nbsp;
&nbsp;            public static Builder parameterizedType(TypeDescription rawType, TypeDefinition... parameter) {
&nbsp;                return parameterizedType((TypeDescription)rawType, (Collection)Arrays.asList(parameter));
&nbsp;            }
&nbsp;
&nbsp;            public static Builder parameterizedType(TypeDescription rawType, Collection&lt;? extends TypeDefinition&gt; parameters) {
&nbsp;                return parameterizedType(rawType, TypeDescription.Generic.UNDEFINED, parameters);
&nbsp;            }
&nbsp;
&nbsp;            public static Builder parameterizedType(TypeDescription rawType, @Nonnull(when = When.MAYBE) Generic ownerType, Collection&lt;? extends TypeDefinition&gt; parameters) {
&nbsp;                TypeDescription declaringType = rawType.getDeclaringType();
&nbsp;                if (ownerType == null &amp;&amp; declaringType != null &amp;&amp; rawType.isStatic()) {
&nbsp;                    ownerType = declaringType.asGenericType();
&nbsp;                }
&nbsp;
&nbsp;                if (!rawType.represents(TargetType.class)) {
&nbsp;                    if (!rawType.isGenerified()) {
&nbsp;                        throw new IllegalArgumentException(rawType + &quot; is not a parameterized type&quot;);
&nbsp;                    }
&nbsp;
&nbsp;                    if (ownerType == null &amp;&amp; declaringType != null &amp;&amp; !rawType.isStatic()) {
&nbsp;                        throw new IllegalArgumentException(rawType + &quot; requires an owner type&quot;);
&nbsp;                    }
&nbsp;
&nbsp;                    if (ownerType != null &amp;&amp; !ownerType.asErasure().equals(declaringType)) {
&nbsp;                        throw new IllegalArgumentException(ownerType + &quot; does not represent required owner for &quot; + rawType);
&nbsp;                    }
&nbsp;
&nbsp;                    if (ownerType != null &amp;&amp; rawType.isStatic() ^ ownerType.getSort().isNonGeneric()) {
&nbsp;                        throw new IllegalArgumentException(ownerType + &quot; does not define the correct parameters for owning &quot; + rawType);
&nbsp;                    }
&nbsp;
&nbsp;                    if (rawType.getTypeVariables().size() != parameters.size()) {
&nbsp;                        throw new IllegalArgumentException(parameters + &quot; does not contain number of required parameters for &quot; + rawType);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                return new OfParameterizedType(rawType, ownerType, new TypeList.Explicit(new ArrayList(parameters)));
&nbsp;            }
&nbsp;
&nbsp;            public Generic asWildcardUpperBound() {
&nbsp;                return this.asWildcardUpperBound((Collection)Collections.emptySet());
&nbsp;            }
&nbsp;
&nbsp;            public Generic asWildcardUpperBound(Annotation... annotation) {
&nbsp;                return this.asWildcardUpperBound(Arrays.asList(annotation));
&nbsp;            }
&nbsp;
&nbsp;            public Generic asWildcardUpperBound(List&lt;? extends Annotation&gt; annotations) {
&nbsp;                return this.asWildcardUpperBound((Collection)(new AnnotationList.ForLoadedAnnotations(annotations)));
&nbsp;            }
&nbsp;
&nbsp;            public Generic asWildcardUpperBound(AnnotationDescription... annotation) {
&nbsp;                return this.asWildcardUpperBound((Collection)Arrays.asList(annotation));
&nbsp;            }
&nbsp;
&nbsp;            public Generic asWildcardUpperBound(Collection&lt;? extends AnnotationDescription&gt; annotations) {
&nbsp;                return TypeDescription.Generic.OfWildcardType.Latent.boundedAbove(this.build(), new AnnotationSource.Explicit(new ArrayList(annotations)));
&nbsp;            }
&nbsp;
&nbsp;            public Generic asWildcardLowerBound() {
&nbsp;                return this.asWildcardLowerBound((Collection)Collections.emptySet());
&nbsp;            }
&nbsp;
&nbsp;            public Generic asWildcardLowerBound(Annotation... annotation) {
&nbsp;                return this.asWildcardLowerBound(Arrays.asList(annotation));
&nbsp;            }
&nbsp;
&nbsp;            public Generic asWildcardLowerBound(List&lt;? extends Annotation&gt; annotations) {
&nbsp;                return this.asWildcardLowerBound((Collection)(new AnnotationList.ForLoadedAnnotations(annotations)));
&nbsp;            }
&nbsp;
&nbsp;            public Generic asWildcardLowerBound(AnnotationDescription... annotation) {
&nbsp;                return this.asWildcardLowerBound((Collection)Arrays.asList(annotation));
&nbsp;            }
&nbsp;
&nbsp;            public Generic asWildcardLowerBound(Collection&lt;? extends AnnotationDescription&gt; annotations) {
&nbsp;                return TypeDescription.Generic.OfWildcardType.Latent.boundedBelow(this.build(), new AnnotationSource.Explicit(new ArrayList(annotations)));
&nbsp;            }
&nbsp;
&nbsp;            public Builder asArray() {
&nbsp;                return this.asArray(1);
&nbsp;            }
&nbsp;
&nbsp;            public Builder asArray(int arity) {
&nbsp;                if (arity &lt; 1) {
&nbsp;                    throw new IllegalArgumentException(&quot;Cannot define an array of a non-positive arity: &quot; + arity);
&nbsp;                } else {
&nbsp;                    Generic typeDescription = this.build();
&nbsp;
&nbsp;                    while(true) {
&nbsp;                        --arity;
&nbsp;                        if (arity &lt;= 0) {
&nbsp;                            return new OfGenericArrayType((Generic)typeDescription);
&nbsp;                        }
&nbsp;
&nbsp;                        typeDescription = new OfGenericArray.Latent((Generic)typeDescription, Empty.INSTANCE);
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public Builder annotate(Annotation... annotation) {
&nbsp;                return this.annotate(Arrays.asList(annotation));
&nbsp;            }
&nbsp;
&nbsp;            public Builder annotate(List&lt;? extends Annotation&gt; annotations) {
&nbsp;                return this.annotate((Collection)(new AnnotationList.ForLoadedAnnotations(annotations)));
&nbsp;            }
&nbsp;
&nbsp;            public Builder annotate(AnnotationDescription... annotation) {
&nbsp;                return this.annotate((Collection)Arrays.asList(annotation));
&nbsp;            }
&nbsp;
&nbsp;            public Builder annotate(Collection&lt;? extends AnnotationDescription&gt; annotations) {
&nbsp;                return this.doAnnotate(new ArrayList(annotations));
&nbsp;            }
&nbsp;
&nbsp;            protected abstract Builder doAnnotate(List&lt;? extends AnnotationDescription&gt; var1);
&nbsp;
&nbsp;            public Generic build() {
&nbsp;                return this.doBuild();
&nbsp;            }
&nbsp;
&nbsp;            public Generic build(Annotation... annotation) {
&nbsp;                return this.build(Arrays.asList(annotation));
&nbsp;            }
&nbsp;
&nbsp;            public Generic build(List&lt;? extends Annotation&gt; annotations) {
&nbsp;                return this.build((Collection)(new AnnotationList.ForLoadedAnnotations(annotations)));
&nbsp;            }
&nbsp;
&nbsp;            public Generic build(AnnotationDescription... annotation) {
&nbsp;                return this.build((Collection)Arrays.asList(annotation));
&nbsp;            }
&nbsp;
&nbsp;            public Generic build(Collection&lt;? extends AnnotationDescription&gt; annotations) {
&nbsp;                return this.doAnnotate(new ArrayList(annotations)).doBuild();
&nbsp;            }
&nbsp;
&nbsp;            protected abstract Generic doBuild();
&nbsp;
&nbsp;            public boolean equals(Object var1) {
&nbsp;                if (this == var1) {
&nbsp;                    return true;
&nbsp;                } else if (var1 == null) {
&nbsp;                    return false;
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return this.annotations.equals(((Builder)var1).annotations);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public int hashCode() {
&nbsp;                return this.getClass().hashCode() * 31 + this.annotations.hashCode();
&nbsp;            }
&nbsp;
&nbsp;            @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;            protected static class OfTypeVariable extends Builder {
&nbsp;                private final String symbol;
&nbsp;
&nbsp;                protected OfTypeVariable(String symbol) {
&nbsp;                    this(symbol, Collections.emptyList());
&nbsp;                }
&nbsp;
&nbsp;                protected OfTypeVariable(String symbol, List&lt;? extends AnnotationDescription&gt; annotations) {
&nbsp;                    super(annotations);
&nbsp;                    this.symbol = symbol;
&nbsp;                }
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                protected Builder doAnnotate(List&lt;? extends AnnotationDescription&gt; annotations) {</b>
&nbsp;                    return new OfTypeVariable(this.symbol, CompoundList.of(this.annotations, annotations));
&nbsp;                }
&nbsp;
&nbsp;                protected Generic doBuild() {
&nbsp;                    return new OfTypeVariable.Symbolic(this.symbol, new AnnotationSource.Explicit(this.annotations));
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(Object var1) {
&nbsp;                    if (!super.equals(var1)) {
&nbsp;                        return false;
&nbsp;                    } else if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.symbol.equals(((OfTypeVariable)var1).symbol);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
<b class="fc">&nbsp;                    return super.hashCode() * 31 + this.symbol.hashCode();</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;            protected static class OfGenericArrayType extends Builder {
&nbsp;                private final Generic componentType;
&nbsp;
&nbsp;                protected OfGenericArrayType(Generic componentType) {
&nbsp;                    this(componentType, Collections.emptyList());
&nbsp;                }
&nbsp;
&nbsp;                protected OfGenericArrayType(Generic componentType, List&lt;? extends AnnotationDescription&gt; annotations) {
&nbsp;                    super(annotations);
&nbsp;                    this.componentType = componentType;
&nbsp;                }
&nbsp;
&nbsp;                protected Builder doAnnotate(List&lt;? extends AnnotationDescription&gt; annotations) {
<b class="fc">&nbsp;                    return new OfGenericArrayType(this.componentType, CompoundList.of(this.annotations, annotations));</b>
&nbsp;                }
&nbsp;
&nbsp;                protected Generic doBuild() {
&nbsp;                    return new OfGenericArray.Latent(this.componentType, new AnnotationSource.Explicit(this.annotations));
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(Object var1) {
&nbsp;                    if (!super.equals(var1)) {
&nbsp;                        return false;
&nbsp;                    } else if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.componentType.equals(((OfGenericArrayType)var1).componentType);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return super.hashCode() * 31 + this.componentType.hashCode();
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
<b class="fc">&nbsp;            protected static class OfParameterizedType extends Builder {</b>
&nbsp;                private final TypeDescription rawType;
&nbsp;                @Nonnull(
&nbsp;                    when = When.MAYBE
&nbsp;                )
&nbsp;                @ValueHandling(net.bytebuddy.build.HashCodeAndEqualsPlugin.ValueHandling.Sort.REVERSE_NULLABILITY)
&nbsp;                private final Generic ownerType;
&nbsp;                private final List&lt;? extends Generic&gt; parameterTypes;
&nbsp;
<b class="fc">&nbsp;                protected OfParameterizedType(TypeDescription rawType, @Nonnull(when = When.MAYBE) Generic ownerType, List&lt;? extends Generic&gt; parameterTypes) {</b>
<b class="fc">&nbsp;                    this(rawType, ownerType, parameterTypes, Collections.emptyList());</b>
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                protected OfParameterizedType(TypeDescription rawType, @Nonnull(when = When.MAYBE) Generic ownerType, List&lt;? extends Generic&gt; parameterTypes, List&lt;? extends AnnotationDescription&gt; annotations) {
&nbsp;                    super(annotations);
&nbsp;                    this.rawType = rawType;
&nbsp;                    this.ownerType = ownerType;
&nbsp;                    this.parameterTypes = parameterTypes;
&nbsp;                }
&nbsp;
&nbsp;                protected Builder doAnnotate(List&lt;? extends AnnotationDescription&gt; annotations) {
&nbsp;                    return new OfParameterizedType(this.rawType, this.ownerType, this.parameterTypes, CompoundList.of(this.annotations, annotations));
&nbsp;                }
&nbsp;
&nbsp;                protected Generic doBuild() {
&nbsp;                    return new OfParameterizedType.Latent(this.rawType, this.ownerType, this.parameterTypes, new AnnotationSource.Explicit(this.annotations));
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(Object var1) {
&nbsp;                    if (!super.equals(var1)) {
&nbsp;                        return false;
&nbsp;                    } else if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.rawType.equals(((OfParameterizedType)var1).rawType)) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        Generic var2 = ((OfParameterizedType)var1).ownerType;
&nbsp;                        Generic var3 = this.ownerType;
&nbsp;                        if (var2 != null) {
&nbsp;                            if (var3 == null) {
&nbsp;                                return false;
&nbsp;                            }
&nbsp;
&nbsp;                            if (!var3.equals(var2)) {
&nbsp;                                return false;
&nbsp;                            }
&nbsp;                        } else if (var3 != null) {
&nbsp;                            return false;
&nbsp;                        }
&nbsp;
&nbsp;                        if (!this.parameterTypes.equals(((OfParameterizedType)var1).parameterTypes)) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return true;
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    int var10000 = (super.hashCode() * 31 + this.rawType.hashCode()) * 31;
&nbsp;                    Generic var1 = this.ownerType;
&nbsp;                    if (var1 != null) {
&nbsp;                        var10000 += var1.hashCode();
&nbsp;                    }
&nbsp;
<b class="fc">&nbsp;                    return var10000 * 31 + this.parameterTypes.hashCode();</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;            protected static class OfNonGenericType extends Builder {
&nbsp;                private final TypeDescription typeDescription;
&nbsp;                @Nonnull(
&nbsp;                    when = When.MAYBE
&nbsp;                )
&nbsp;                @ValueHandling(net.bytebuddy.build.HashCodeAndEqualsPlugin.ValueHandling.Sort.REVERSE_NULLABILITY)
&nbsp;                private final Generic ownerType;
&nbsp;
&nbsp;                protected OfNonGenericType(TypeDescription typeDescription) {
&nbsp;                    this(typeDescription, typeDescription.getDeclaringType());
&nbsp;                }
&nbsp;
&nbsp;                protected OfNonGenericType(TypeDescription typeDescription, @Nonnull(when = When.MAYBE) TypeDescription ownerType) {
&nbsp;                    this(typeDescription, ownerType == null ? TypeDescription.Generic.UNDEFINED : ownerType.asGenericType());
&nbsp;                }
&nbsp;
&nbsp;                protected OfNonGenericType(TypeDescription typeDescription, @Nonnull(when = When.MAYBE) Generic ownerType) {
&nbsp;                    this(typeDescription, ownerType, Collections.emptyList());
&nbsp;                }
&nbsp;
&nbsp;                protected OfNonGenericType(TypeDescription typeDescription, @Nonnull(when = When.MAYBE) Generic ownerType, List&lt;? extends AnnotationDescription&gt; annotations) {
&nbsp;                    super(annotations);
&nbsp;                    this.ownerType = ownerType;
&nbsp;                    this.typeDescription = typeDescription;
&nbsp;                }
&nbsp;
&nbsp;                protected Builder doAnnotate(List&lt;? extends AnnotationDescription&gt; annotations) {
&nbsp;                    return new OfNonGenericType(this.typeDescription, this.ownerType, CompoundList.of(this.annotations, annotations));
&nbsp;                }
&nbsp;
&nbsp;                protected Generic doBuild() {
&nbsp;                    if (this.typeDescription.represents(Void.TYPE) &amp;&amp; !this.annotations.isEmpty()) {
&nbsp;                        throw new IllegalArgumentException(&quot;The void non-type cannot be annotated&quot;);
&nbsp;                    } else {
&nbsp;                        return new OfNonGenericType.Latent(this.typeDescription, this.ownerType, new AnnotationSource.Explicit(this.annotations));
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(Object var1) {
&nbsp;                    if (!super.equals(var1)) {
&nbsp;                        return false;
&nbsp;                    } else if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.typeDescription.equals(((OfNonGenericType)var1).typeDescription)) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        Generic var2 = ((OfNonGenericType)var1).ownerType;
&nbsp;                        Generic var3 = this.ownerType;
&nbsp;                        if (var2 != null) {
&nbsp;                            if (var3 == null) {
&nbsp;                                return false;
&nbsp;                            }
&nbsp;
&nbsp;                            if (!var3.equals(var2)) {
&nbsp;                                return false;
&nbsp;                            }
&nbsp;                        } else if (var3 != null) {
&nbsp;                            return false;
&nbsp;                        }
&nbsp;
&nbsp;                        return true;
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    int var10000 = (super.hashCode() * 31 + this.typeDescription.hashCode()) * 31;
&nbsp;                    Generic var1 = this.ownerType;
&nbsp;                    if (var1 != null) {
&nbsp;                        var10000 += var1.hashCode();
&nbsp;                    }
&nbsp;
&nbsp;                    return var10000;
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            protected static enum Visitor implements Visitor&lt;Builder&gt; {
&nbsp;                INSTANCE;
&nbsp;
&nbsp;                private Visitor() {
&nbsp;                }
&nbsp;
&nbsp;                @SuppressFBWarnings(
<b class="fc">&nbsp;                    value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},</b>
&nbsp;                    justification = &quot;Assuming component type for array type.&quot;
&nbsp;                )
&nbsp;                public Builder onGenericArray(Generic genericArray) {
&nbsp;                    return new OfGenericArrayType(genericArray.getComponentType(), genericArray.getDeclaredAnnotations());
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                public Builder onWildcard(Generic wildcard) {
&nbsp;                    throw new IllegalArgumentException(&quot;Cannot resolve wildcard type &quot; + wildcard + &quot; to builder&quot;);
&nbsp;                }
&nbsp;
&nbsp;                public Builder onParameterizedType(Generic parameterizedType) {
&nbsp;                    return new OfParameterizedType(parameterizedType.asErasure(), parameterizedType.getOwnerType(), parameterizedType.getTypeArguments(), parameterizedType.getDeclaredAnnotations());
&nbsp;                }
&nbsp;
&nbsp;                public Builder onTypeVariable(Generic typeVariable) {
&nbsp;                    return new OfTypeVariable(typeVariable.getSymbol(), typeVariable.getDeclaredAnnotations());
&nbsp;                }
<b class="fc">&nbsp;</b>
&nbsp;                @SuppressFBWarnings(
&nbsp;                    value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;                    justification = &quot;Assuming component type for array type.&quot;
&nbsp;                )
&nbsp;                public Builder onNonGenericType(Generic typeDescription) {
&nbsp;                    return (Builder)(typeDescription.isArray() ? ((Builder)typeDescription.getComponentType().accept(this)).asArray().annotate((Collection)typeDescription.getDeclaredAnnotations()) : new OfNonGenericType(typeDescription.asErasure(), typeDescription.getOwnerType(), typeDescription.getDeclaredAnnotations()));
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public abstract static class LazyProjection extends AbstractBase {
&nbsp;            public LazyProjection() {
&nbsp;            }
&nbsp;
&nbsp;            protected abstract Generic resolve();
&nbsp;
&nbsp;            public TypeDefinition.Sort getSort() {
&nbsp;                return this.resolve().getSort();
&nbsp;            }
&nbsp;
&nbsp;            public FieldList&lt;FieldDescription.InGenericShape&gt; getDeclaredFields() {
&nbsp;                return this.resolve().getDeclaredFields();
&nbsp;            }
&nbsp;
&nbsp;            public MethodList&lt;MethodDescription.InGenericShape&gt; getDeclaredMethods() {
&nbsp;                return this.resolve().getDeclaredMethods();
&nbsp;            }
&nbsp;
&nbsp;            public RecordComponentList&lt;RecordComponentDescription.InGenericShape&gt; getRecordComponents() {
&nbsp;                return this.resolve().getRecordComponents();
&nbsp;            }
&nbsp;
&nbsp;            public TypeList.Generic getUpperBounds() {
&nbsp;                return this.resolve().getUpperBounds();
&nbsp;            }
&nbsp;
&nbsp;            public TypeList.Generic getLowerBounds() {
&nbsp;                return this.resolve().getLowerBounds();
&nbsp;            }
&nbsp;
&nbsp;            @Nonnull(
&nbsp;                when = When.MAYBE
&nbsp;            )
&nbsp;            public Generic getComponentType() {
&nbsp;                return this.resolve().getComponentType();
&nbsp;            }
&nbsp;
&nbsp;            public TypeList.Generic getTypeArguments() {
&nbsp;                return this.resolve().getTypeArguments();
&nbsp;            }
&nbsp;
&nbsp;            @Nonnull(
&nbsp;                when = When.MAYBE
&nbsp;            )
&nbsp;            public Generic findBindingOf(Generic typeVariable) {
&nbsp;                return this.resolve().findBindingOf(typeVariable);
&nbsp;            }
&nbsp;
&nbsp;            public TypeVariableSource getTypeVariableSource() {
&nbsp;                return this.resolve().getTypeVariableSource();
&nbsp;            }
&nbsp;
&nbsp;            @Nonnull(
&nbsp;                when = When.MAYBE
&nbsp;            )
&nbsp;            public Generic getOwnerType() {
&nbsp;                return this.resolve().getOwnerType();
&nbsp;            }
&nbsp;
&nbsp;            public String getTypeName() {
&nbsp;                return this.resolve().getTypeName();
&nbsp;            }
&nbsp;
&nbsp;            public String getSymbol() {
&nbsp;                return this.resolve().getSymbol();
&nbsp;            }
&nbsp;
&nbsp;            public String getActualName() {
&nbsp;                return this.resolve().getActualName();
&nbsp;            }
&nbsp;
&nbsp;            public &lt;T&gt; T accept(Visitor&lt;T&gt; visitor) {
&nbsp;                return this.resolve().accept(visitor);
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            public StackSize getStackSize() {
&nbsp;                return this.asErasure().getStackSize();
&nbsp;            }
&nbsp;
&nbsp;            public boolean isArray() {
&nbsp;                return this.asErasure().isArray();
&nbsp;            }
&nbsp;
&nbsp;            public boolean isPrimitive() {
&nbsp;                return this.asErasure().isPrimitive();
&nbsp;            }
&nbsp;
&nbsp;            public boolean isRecord() {
&nbsp;                return this.asErasure().isRecord();
&nbsp;            }
&nbsp;
&nbsp;            public boolean represents(Type type) {
&nbsp;                return this.resolve().represents(type);
&nbsp;            }
&nbsp;
&nbsp;            @Enhance(&quot;hashCode&quot;)
&nbsp;            public int hashCode() {
&nbsp;                int var1 = this.hashCode;
&nbsp;                int var2 = var1 != 0 ? 0 : this.resolve().hashCode();
&nbsp;                if (var2 == 0) {
&nbsp;                    var2 = this.hashCode;
&nbsp;                } else {
&nbsp;                    this.hashCode = var2;
&nbsp;                }
&nbsp;
&nbsp;                return var2;
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(@CheckForNull Object other) {
&nbsp;                return this == other || other instanceof TypeDefinition &amp;&amp; this.resolve().equals(other);
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            public String toString() {</b>
&nbsp;                return this.resolve().toString();
&nbsp;            }
&nbsp;
&nbsp;            public static class WithResolvedErasure extends WithEagerNavigation {
&nbsp;                private final Generic delegate;
&nbsp;                private final Visitor&lt;? extends Generic&gt; visitor;
&nbsp;                private final AnnotationSource annotationSource;
&nbsp;
&nbsp;                public WithResolvedErasure(Generic delegate, Visitor&lt;? extends Generic&gt; visitor) {
&nbsp;                    this(delegate, visitor, delegate);
&nbsp;                }
&nbsp;
&nbsp;                public WithResolvedErasure(Generic delegate, Visitor&lt;? extends Generic&gt; visitor, AnnotationSource annotationSource) {
&nbsp;                    this.delegate = delegate;
&nbsp;                    this.visitor = visitor;
&nbsp;                    this.annotationSource = annotationSource;
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationList getDeclaredAnnotations() {
&nbsp;                    return this.annotationSource.getDeclaredAnnotations();
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                public TypeDescription asErasure() {
&nbsp;                    return this.delegate.asErasure();
&nbsp;                }
&nbsp;
&nbsp;                @Enhance(&quot;resolved&quot;)
<b class="fc">&nbsp;                protected Generic resolve() {</b>
&nbsp;                    Generic var1 = this.resolved;
&nbsp;                    Generic var2 = var1 != null ? null : (Generic)this.delegate.accept(this.visitor);
&nbsp;                    if (var2 == null) {
&nbsp;                        var2 = (Generic)this.resolved;
&nbsp;                    } else {
&nbsp;                        this.resolved = var2;
&nbsp;                    }
&nbsp;
&nbsp;                    return var2;
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public static class OfRecordComponent extends WithEagerNavigation.OfAnnotatedElement {
&nbsp;                private final Object recordComponent;
&nbsp;
&nbsp;                protected OfRecordComponent(Object recordComponent) {
&nbsp;                    this.recordComponent = recordComponent;
&nbsp;                }
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                @Enhance(&quot;resolved&quot;)</b>
&nbsp;                protected Generic resolve() {
&nbsp;                    Generic var1 = this.resolved;
&nbsp;                    Generic var2 = var1 != null ? null : Sort.describe(net.bytebuddy.description.type.RecordComponentDescription.ForLoadedRecordComponent.RECORD_COMPONENT.getGenericType(this.recordComponent), this.getAnnotationReader());
&nbsp;                    if (var2 == null) {
&nbsp;                        var2 = (Generic)this.resolved;
&nbsp;                    } else {
<b class="fc">&nbsp;                        this.resolved = var2;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    return var2;
&nbsp;                }
&nbsp;
&nbsp;                public TypeDescription asErasure() {
&nbsp;                    return TypeDescription.ForLoadedType.of(net.bytebuddy.description.type.RecordComponentDescription.ForLoadedRecordComponent.RECORD_COMPONENT.getType(this.recordComponent));
&nbsp;                }
&nbsp;
&nbsp;                protected AnnotationReader getAnnotationReader() {
&nbsp;                    return new AnnotationReader.Delegator.ForLoadedRecordComponent(this.recordComponent);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public static class OfMethodParameter extends WithEagerNavigation.OfAnnotatedElement {
&nbsp;                private final Method method;
&nbsp;                private final int index;
&nbsp;                private final Class&lt;?&gt;[] erasure;
&nbsp;
<b class="fc">&nbsp;                @SuppressFBWarnings(</b>
<b class="fc">&nbsp;                    value = {&quot;EI_EXPOSE_REP2&quot;},</b>
&nbsp;                    justification = &quot;The array is not modified by class contract.&quot;
&nbsp;                )
&nbsp;                public OfMethodParameter(Method method, int index, Class&lt;?&gt;[] erasure) {
&nbsp;                    this.method = method;
&nbsp;                    this.index = index;
&nbsp;                    this.erasure = erasure;
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                @Enhance(&quot;resolved&quot;)
&nbsp;                protected Generic resolve() {
&nbsp;                    Generic var1 = this.resolved;
&nbsp;                    Generic var10000;
&nbsp;                    if (var1 != null) {
&nbsp;                        var10000 = null;
&nbsp;                    } else {
&nbsp;                        Type[] type = this.method.getGenericParameterTypes();
&nbsp;                        var10000 = this.erasure.length == type.length ? Sort.describe(type[this.index], this.getAnnotationReader()) : TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(this.erasure[this.index]);
&nbsp;                    }
&nbsp;
&nbsp;                    Generic var2 = var10000;
&nbsp;                    if (var2 == null) {
&nbsp;                        var2 = (Generic)this.resolved;
&nbsp;                    } else {
&nbsp;                        this.resolved = var2;
&nbsp;                    }
&nbsp;
&nbsp;                    return var2;
&nbsp;                }
&nbsp;
&nbsp;                public TypeDescription asErasure() {
&nbsp;                    return TypeDescription.ForLoadedType.of(this.erasure[this.index]);
&nbsp;                }
&nbsp;
&nbsp;                protected AnnotationReader getAnnotationReader() {
&nbsp;                    return new AnnotationReader.Delegator.ForLoadedExecutableParameterType(this.method, this.index);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public static class OfConstructorParameter extends WithEagerNavigation.OfAnnotatedElement {
&nbsp;                private final Constructor&lt;?&gt; constructor;
&nbsp;                private final int index;
&nbsp;                private final Class&lt;?&gt;[] erasure;
&nbsp;
&nbsp;                @SuppressFBWarnings(
&nbsp;                    value = {&quot;EI_EXPOSE_REP2&quot;},
&nbsp;                    justification = &quot;The array is not modified by class contract.&quot;
&nbsp;                )
&nbsp;                public OfConstructorParameter(Constructor&lt;?&gt; constructor, int index, Class&lt;?&gt;[] erasure) {
&nbsp;                    this.constructor = constructor;
&nbsp;                    this.index = index;
&nbsp;                    this.erasure = erasure;
&nbsp;                }
&nbsp;
&nbsp;                @Enhance(&quot;delegate&quot;)
&nbsp;                protected Generic resolve() {
&nbsp;                    Generic var1 = this.delegate;
&nbsp;                    Generic var10000;
&nbsp;                    if (var1 != null) {
&nbsp;                        var10000 = null;
&nbsp;                    } else {
&nbsp;                        Type[] type = this.constructor.getGenericParameterTypes();
&nbsp;                        var10000 = this.erasure.length == type.length ? Sort.describe(type[this.index], this.getAnnotationReader()) : TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(this.erasure[this.index]);
&nbsp;                    }
&nbsp;
&nbsp;                    Generic var2 = var10000;
&nbsp;                    if (var2 == null) {
&nbsp;                        var2 = (Generic)this.delegate;
&nbsp;                    } else {
&nbsp;                        this.delegate = var2;
&nbsp;                    }
&nbsp;
&nbsp;                    return var2;
&nbsp;                }
&nbsp;
&nbsp;                public TypeDescription asErasure() {
&nbsp;                    return TypeDescription.ForLoadedType.of(this.erasure[this.index]);
&nbsp;                }
&nbsp;
&nbsp;                protected AnnotationReader getAnnotationReader() {
&nbsp;                    return new AnnotationReader.Delegator.ForLoadedExecutableParameterType(this.constructor, this.index);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public static class ForLoadedReturnType extends WithEagerNavigation.OfAnnotatedElement {
&nbsp;                private final Method method;
&nbsp;
&nbsp;                public ForLoadedReturnType(Method method) {
&nbsp;                    this.method = method;
&nbsp;                }
&nbsp;
&nbsp;                @Enhance(&quot;resolved&quot;)
&nbsp;                protected Generic resolve() {
&nbsp;                    Generic var1 = this.resolved;
&nbsp;                    Generic var2 = var1 != null ? null : Sort.describe(this.method.getGenericReturnType(), this.getAnnotationReader());
&nbsp;                    if (var2 == null) {
&nbsp;                        var2 = (Generic)this.resolved;
&nbsp;                    } else {
&nbsp;                        this.resolved = var2;
&nbsp;                    }
&nbsp;
&nbsp;                    return var2;
&nbsp;                }
&nbsp;
&nbsp;                public TypeDescription asErasure() {
&nbsp;                    return TypeDescription.ForLoadedType.of(this.method.getReturnType());
&nbsp;                }
&nbsp;
&nbsp;                protected AnnotationReader getAnnotationReader() {
&nbsp;                    return new AnnotationReader.Delegator.ForLoadedMethodReturnType(this.method);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public static class ForLoadedFieldType extends WithEagerNavigation.OfAnnotatedElement {
&nbsp;                private final Field field;
&nbsp;
&nbsp;                public ForLoadedFieldType(Field field) {
&nbsp;                    this.field = field;
&nbsp;                }
&nbsp;
&nbsp;                @Enhance(&quot;resolved&quot;)
&nbsp;                protected Generic resolve() {
&nbsp;                    Generic var1 = this.resolved;
&nbsp;                    Generic var2 = var1 != null ? null : Sort.describe(this.field.getGenericType(), this.getAnnotationReader());
&nbsp;                    if (var2 == null) {
&nbsp;                        var2 = (Generic)this.resolved;
&nbsp;                    } else {
&nbsp;                        this.resolved = var2;
&nbsp;                    }
&nbsp;
&nbsp;                    return var2;
&nbsp;                }
&nbsp;
&nbsp;                public TypeDescription asErasure() {
&nbsp;                    return TypeDescription.ForLoadedType.of(this.field.getType());
&nbsp;                }
&nbsp;
&nbsp;                protected AnnotationReader getAnnotationReader() {
&nbsp;                    return new AnnotationReader.Delegator.ForLoadedField(this.field);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public static class ForLoadedSuperClass extends WithLazyNavigation.OfAnnotatedElement {
&nbsp;                private final Class&lt;?&gt; type;
&nbsp;
&nbsp;                protected ForLoadedSuperClass(Class&lt;?&gt; type) {
&nbsp;                    this.type = type;
&nbsp;                }
&nbsp;
&nbsp;                @Nonnull(
&nbsp;                    when = When.MAYBE
&nbsp;                )
&nbsp;                public static Generic of(Class&lt;?&gt; type) {
&nbsp;                    return (Generic)(type.getSuperclass() == null ? TypeDescription.Generic.UNDEFINED : new ForLoadedSuperClass(type));
&nbsp;                }
&nbsp;
&nbsp;                @Enhance(&quot;resolved&quot;)
&nbsp;                protected Generic resolve() {
&nbsp;                    Generic var1 = this.resolved;
&nbsp;                    Generic var2 = var1 != null ? null : Sort.describe(this.type.getGenericSuperclass(), this.getAnnotationReader());
&nbsp;                    if (var2 == null) {
&nbsp;                        var2 = (Generic)this.resolved;
&nbsp;                    } else {
&nbsp;                        this.resolved = var2;
&nbsp;                    }
&nbsp;
&nbsp;                    return var2;
&nbsp;                }
&nbsp;
&nbsp;                public TypeDescription asErasure() {
&nbsp;                    return TypeDescription.ForLoadedType.of(this.type.getSuperclass());
&nbsp;                }
&nbsp;
&nbsp;                protected AnnotationReader getAnnotationReader() {
&nbsp;                    return new AnnotationReader.Delegator.ForLoadedSuperClass(this.type);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public abstract static class WithEagerNavigation extends LazyProjection {
&nbsp;                public WithEagerNavigation() {
&nbsp;                }
&nbsp;
&nbsp;                @Nonnull(
&nbsp;                    when = When.MAYBE
&nbsp;                )
&nbsp;                public Generic getSuperClass() {
&nbsp;                    return this.resolve().getSuperClass();
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                public TypeList.Generic getInterfaces() {
&nbsp;                    return this.resolve().getInterfaces();
&nbsp;                }
&nbsp;
&nbsp;                public Iterator&lt;TypeDefinition&gt; iterator() {
&nbsp;                    return this.resolve().iterator();
&nbsp;                }
&nbsp;
&nbsp;                protected abstract static class OfAnnotatedElement extends WithEagerNavigation {
&nbsp;                    protected OfAnnotatedElement() {
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;</b>
&nbsp;                    protected abstract AnnotationReader getAnnotationReader();
&nbsp;
&nbsp;                    public AnnotationList getDeclaredAnnotations() {
&nbsp;                        return this.getAnnotationReader().asList();
&nbsp;                    }
&nbsp;                }
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;</b>
&nbsp;            public abstract static class WithLazyNavigation extends LazyProjection {
&nbsp;                public WithLazyNavigation() {
&nbsp;                }
&nbsp;
&nbsp;                @Nonnull(
&nbsp;                    when = When.MAYBE
&nbsp;                )
&nbsp;                public Generic getSuperClass() {
&nbsp;                    return TypeDescription.Generic.LazyProjection.WithLazyNavigation.LazySuperClass.of(this);
&nbsp;                }
&nbsp;
&nbsp;                public TypeList.Generic getInterfaces() {
&nbsp;                    return TypeDescription.Generic.LazyProjection.WithLazyNavigation.LazyInterfaceList.of(this);
&nbsp;                }
&nbsp;
&nbsp;                public Iterator&lt;TypeDefinition&gt; iterator() {
&nbsp;                    return new TypeDefinition.SuperClassIterator(this);
&nbsp;                }
&nbsp;
&nbsp;                protected abstract static class OfAnnotatedElement extends WithLazyNavigation {
&nbsp;                    protected OfAnnotatedElement() {
&nbsp;                    }
&nbsp;
&nbsp;                    protected abstract AnnotationReader getAnnotationReader();
&nbsp;
&nbsp;                    public AnnotationList getDeclaredAnnotations() {
&nbsp;                        return this.getAnnotationReader().asList();
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                protected static class LazyInterfaceList extends TypeList.AbstractBase {
<b class="fc">&nbsp;                    private final LazyProjection delegate;</b>
&nbsp;                    private final TypeList.Generic rawInterfaces;
&nbsp;
&nbsp;                    protected LazyInterfaceList(LazyProjection delegate, TypeList.Generic rawInterfaces) {
&nbsp;                        this.delegate = delegate;
&nbsp;                        this.rawInterfaces = rawInterfaces;
&nbsp;                    }
&nbsp;
&nbsp;                    protected static TypeList.Generic of(LazyProjection delegate) {
&nbsp;                        return new LazyInterfaceList(delegate, delegate.asErasure().getInterfaces());
&nbsp;                    }
&nbsp;
&nbsp;                    public Generic get(int index) {
&nbsp;                        return new LazyInterfaceType(this.delegate, index, (Generic)this.rawInterfaces.get(index));
&nbsp;                    }
&nbsp;
&nbsp;                    public int size() {
&nbsp;                        return this.rawInterfaces.size();
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;</b>
&nbsp;                protected static class LazyInterfaceType extends WithLazyNavigation {
&nbsp;                    private final LazyProjection delegate;
&nbsp;                    private final int index;
&nbsp;                    private final Generic rawInterface;
&nbsp;
&nbsp;                    protected LazyInterfaceType(LazyProjection delegate, int index, Generic rawInterface) {
<b class="fc">&nbsp;                        this.delegate = delegate;</b>
<b class="fc">&nbsp;                        this.index = index;</b>
&nbsp;                        this.rawInterface = rawInterface;
&nbsp;                    }
&nbsp;
&nbsp;                    public AnnotationList getDeclaredAnnotations() {
&nbsp;                        return this.resolve().getDeclaredAnnotations();
&nbsp;                    }
&nbsp;
&nbsp;                    public TypeDescription asErasure() {
&nbsp;                        return this.rawInterface.asErasure();
&nbsp;                    }
&nbsp;
&nbsp;                    @Enhance(&quot;resolved&quot;)
&nbsp;                    protected Generic resolve() {
&nbsp;                        Generic var1 = this.resolved;
&nbsp;                        Generic var2 = var1 != null ? null : (Generic)this.delegate.resolve().getInterfaces().get(this.index);
&nbsp;                        if (var2 == null) {
&nbsp;                            var2 = (Generic)this.resolved;
&nbsp;                        } else {
&nbsp;                            this.resolved = var2;
&nbsp;                        }
&nbsp;
&nbsp;                        return var2;
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                protected static class LazySuperClass extends WithLazyNavigation {
&nbsp;                    private final LazyProjection delegate;
&nbsp;
<b class="fc">&nbsp;                    protected LazySuperClass(LazyProjection delegate) {</b>
&nbsp;                        this.delegate = delegate;
&nbsp;                    }
&nbsp;
&nbsp;                    @Nonnull(
&nbsp;                        when = When.MAYBE
&nbsp;                    )
&nbsp;                    protected static Generic of(LazyProjection delegate) {
&nbsp;                        return (Generic)(delegate.asErasure().getSuperClass() == null ? TypeDescription.Generic.UNDEFINED : new LazySuperClass(delegate));
&nbsp;                    }
&nbsp;
&nbsp;                    public AnnotationList getDeclaredAnnotations() {
&nbsp;                        return this.resolve().getDeclaredAnnotations();
&nbsp;                    }
&nbsp;
&nbsp;                    @SuppressFBWarnings(
&nbsp;                        value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;                        justification = &quot;Assuming super class for given instance.&quot;
<b class="fc">&nbsp;                    )</b>
<b class="fc">&nbsp;                    public TypeDescription asErasure() {</b>
<b class="fc">&nbsp;                        return this.delegate.asErasure().getSuperClass().asErasure();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Enhance(&quot;resolved&quot;)
&nbsp;                    @SuppressFBWarnings(
&nbsp;                        value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;                        justification = &quot;Assuming super class for given instance.&quot;
<b class="fc">&nbsp;                    )</b>
<b class="fc">&nbsp;                    protected Generic resolve() {</b>
&nbsp;                        Generic var1 = this.resolved;
&nbsp;                        Generic var2 = var1 != null ? null : this.delegate.resolve().getSuperClass();
&nbsp;                        if (var2 == null) {
&nbsp;                            var2 = (Generic)this.resolved;
&nbsp;                        } else {
&nbsp;                            this.resolved = var2;
&nbsp;                        }
&nbsp;
&nbsp;                        return var2;
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public abstract static class OfTypeVariable extends AbstractBase {
&nbsp;            public OfTypeVariable() {
&nbsp;            }
&nbsp;
&nbsp;            public TypeDefinition.Sort getSort() {
&nbsp;                return Sort.VARIABLE;
&nbsp;            }
&nbsp;
&nbsp;            public TypeDescription asErasure() {
&nbsp;                TypeList.Generic upperBounds = this.getUpperBounds();
&nbsp;                return upperBounds.isEmpty() ? TypeDescription.OBJECT : ((Generic)upperBounds.get(0)).asErasure();
&nbsp;            }
&nbsp;
&nbsp;            @Nonnull(
&nbsp;                when = When.MAYBE
&nbsp;            )
&nbsp;            public Generic getSuperClass() {
&nbsp;                throw new IllegalStateException(&quot;A type variable does not imply a super type definition: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            public TypeList.Generic getInterfaces() {
&nbsp;                throw new IllegalStateException(&quot;A type variable does not imply an interface type definition: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            public FieldList&lt;FieldDescription.InGenericShape&gt; getDeclaredFields() {
&nbsp;                throw new IllegalStateException(&quot;A type variable does not imply field definitions: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            public MethodList&lt;MethodDescription.InGenericShape&gt; getDeclaredMethods() {
&nbsp;                throw new IllegalStateException(&quot;A type variable does not imply method definitions: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            public RecordComponentList&lt;RecordComponentDescription.InGenericShape&gt; getRecordComponents() {
&nbsp;                throw new IllegalStateException(&quot;A type variable does not imply record component definitions: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            public Generic getComponentType() {
&nbsp;                throw new IllegalStateException(&quot;A type variable does not imply a component type: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            public TypeList.Generic getTypeArguments() {
&nbsp;                throw new IllegalStateException(&quot;A type variable does not imply type arguments: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            public Generic findBindingOf(Generic typeVariable) {
&nbsp;                throw new IllegalStateException(&quot;A type variable does not imply type arguments: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            public TypeList.Generic getLowerBounds() {
&nbsp;                throw new IllegalStateException(&quot;A type variable does not imply lower bounds: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            public Generic getOwnerType() {
&nbsp;                throw new IllegalStateException(&quot;A type variable does not imply an owner type: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            public String getTypeName() {
&nbsp;                return this.toString();
&nbsp;            }
&nbsp;
&nbsp;            public String getActualName() {
&nbsp;                return this.getSymbol();
&nbsp;            }
&nbsp;
&nbsp;            public &lt;T&gt; T accept(Visitor&lt;T&gt; visitor) {
&nbsp;                return visitor.onTypeVariable(this);
&nbsp;            }
&nbsp;
&nbsp;            public StackSize getStackSize() {
&nbsp;                return StackSize.SINGLE;
&nbsp;            }
&nbsp;
&nbsp;            public boolean isArray() {
&nbsp;                return false;
&nbsp;            }
&nbsp;
&nbsp;            public boolean isPrimitive() {
&nbsp;                return false;
&nbsp;            }
&nbsp;
&nbsp;            public boolean isRecord() {
&nbsp;                return false;
&nbsp;            }
&nbsp;
&nbsp;            public boolean represents(Type type) {
&nbsp;                return this.equals(Sort.describe(type));
&nbsp;            }
&nbsp;
&nbsp;            public Iterator&lt;TypeDefinition&gt; iterator() {
&nbsp;                throw new IllegalStateException(&quot;A type variable does not imply a super type definition: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            @Enhance(&quot;hashCode&quot;)
&nbsp;            public int hashCode() {
&nbsp;                int var1 = this.hashCode;
&nbsp;                int var2 = var1 != 0 ? 0 : this.getTypeVariableSource().hashCode() ^ this.getSymbol().hashCode();
&nbsp;                if (var2 == 0) {
&nbsp;                    var2 = this.hashCode;
&nbsp;                } else {
&nbsp;                    this.hashCode = var2;
&nbsp;                }
&nbsp;
&nbsp;                return var2;
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(@CheckForNull Object other) {
&nbsp;                if (this == other) {
&nbsp;                    return true;
&nbsp;                } else if (!(other instanceof Generic)) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    Generic typeDescription = (Generic)other;
&nbsp;                    return typeDescription.getSort().isTypeVariable() &amp;&amp; this.getSymbol().equals(typeDescription.getSymbol()) &amp;&amp; this.getTypeVariableSource().equals(typeDescription.getTypeVariableSource());
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public String toString() {
&nbsp;                return this.getSymbol();
&nbsp;            }
&nbsp;
&nbsp;            public static class WithAnnotationOverlay extends OfTypeVariable {
&nbsp;                private final Generic typeVariable;
&nbsp;                private final AnnotationSource annotationSource;
&nbsp;
&nbsp;                public WithAnnotationOverlay(Generic typeVariable, AnnotationSource annotationSource) {
&nbsp;                    this.typeVariable = typeVariable;
&nbsp;                    this.annotationSource = annotationSource;
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationList getDeclaredAnnotations() {
&nbsp;                    return this.annotationSource.getDeclaredAnnotations();
&nbsp;                }
&nbsp;
&nbsp;                public TypeList.Generic getUpperBounds() {
&nbsp;                    return this.typeVariable.getUpperBounds();
&nbsp;                }
&nbsp;
&nbsp;                public TypeVariableSource getTypeVariableSource() {
&nbsp;                    return this.typeVariable.getTypeVariableSource();
&nbsp;                }
&nbsp;
&nbsp;                public String getSymbol() {
&nbsp;                    return this.typeVariable.getSymbol();
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public static class ForLoadedType extends OfTypeVariable {
&nbsp;                private final TypeVariable&lt;?&gt; typeVariable;
&nbsp;                private final AnnotationReader annotationReader;
&nbsp;
&nbsp;                public ForLoadedType(TypeVariable&lt;?&gt; typeVariable) {
&nbsp;                    this(typeVariable, TypeDescription.Generic.AnnotationReader.NoOp.INSTANCE);
&nbsp;                }
&nbsp;
&nbsp;                protected ForLoadedType(TypeVariable&lt;?&gt; typeVariable, AnnotationReader annotationReader) {
&nbsp;                    this.typeVariable = typeVariable;
&nbsp;                    this.annotationReader = annotationReader;
&nbsp;                }
&nbsp;
&nbsp;                public TypeVariableSource getTypeVariableSource() {
&nbsp;                    GenericDeclaration genericDeclaration = this.typeVariable.getGenericDeclaration();
&nbsp;                    if (genericDeclaration instanceof Class) {
&nbsp;                        return TypeDescription.ForLoadedType.of((Class)genericDeclaration);
&nbsp;                    } else if (genericDeclaration instanceof Method) {
&nbsp;                        return new MethodDescription.ForLoadedMethod((Method)genericDeclaration);
&nbsp;                    } else if (genericDeclaration instanceof Constructor) {
&nbsp;                        return new MethodDescription.ForLoadedConstructor((Constructor)genericDeclaration);
&nbsp;                    } else {
&nbsp;                        throw new IllegalStateException(&quot;Unknown declaration: &quot; + genericDeclaration);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public TypeList.Generic getUpperBounds() {
&nbsp;                    return new TypeVariableBoundList(this.typeVariable.getBounds(), this.annotationReader);
&nbsp;                }
&nbsp;
&nbsp;                public String getSymbol() {
&nbsp;                    return this.typeVariable.getName();
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationList getDeclaredAnnotations() {
&nbsp;                    return this.annotationReader.asList();
&nbsp;                }
&nbsp;
&nbsp;                public boolean represents(Type type) {
&nbsp;                    return this.typeVariable == type || super.represents(type);
&nbsp;                }
&nbsp;
&nbsp;                protected static class TypeVariableBoundList extends TypeList.AbstractBase {
&nbsp;                    private final Type[] bound;
&nbsp;                    private final AnnotationReader annotationReader;
&nbsp;
&nbsp;                    protected TypeVariableBoundList(Type[] bound, AnnotationReader annotationReader) {
&nbsp;                        this.bound = bound;
&nbsp;                        this.annotationReader = annotationReader;
&nbsp;                    }
&nbsp;
&nbsp;                    public Generic get(int index) {
&nbsp;                        return Sort.describe(this.bound[index], this.annotationReader.ofTypeVariableBoundType(index));
&nbsp;                    }
&nbsp;
&nbsp;                    public int size() {
&nbsp;                        return this.bound.length;
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public static class Symbolic extends AbstractBase {
&nbsp;                private final String symbol;
&nbsp;                private final AnnotationSource annotationSource;
&nbsp;
&nbsp;                public Symbolic(String symbol, AnnotationSource annotationSource) {
&nbsp;                    this.symbol = symbol;
&nbsp;                    this.annotationSource = annotationSource;
&nbsp;                }
&nbsp;
&nbsp;                public TypeDefinition.Sort getSort() {
&nbsp;                    return Sort.VARIABLE_SYMBOLIC;
&nbsp;                }
&nbsp;
&nbsp;                public String getSymbol() {
&nbsp;                    return this.symbol;
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationList getDeclaredAnnotations() {
&nbsp;                    return this.annotationSource.getDeclaredAnnotations();
&nbsp;                }
&nbsp;
&nbsp;                public TypeDescription asErasure() {
&nbsp;                    throw new IllegalStateException(&quot;A symbolic type variable does not imply an erasure: &quot; + this);
&nbsp;                }
&nbsp;
&nbsp;                public TypeList.Generic getUpperBounds() {
&nbsp;                    throw new IllegalStateException(&quot;A symbolic type variable does not imply an upper type bound: &quot; + this);
&nbsp;                }
&nbsp;
&nbsp;                public TypeVariableSource getTypeVariableSource() {
&nbsp;                    throw new IllegalStateException(&quot;A symbolic type variable does not imply a variable source: &quot; + this);
&nbsp;                }
&nbsp;
&nbsp;                @Nonnull(
&nbsp;                    when = When.MAYBE
&nbsp;                )
&nbsp;                public Generic getSuperClass() {
&nbsp;                    throw new IllegalStateException(&quot;A symbolic type variable does not imply a super type definition: &quot; + this);
&nbsp;                }
&nbsp;
&nbsp;                public TypeList.Generic getInterfaces() {
&nbsp;                    throw new IllegalStateException(&quot;A symbolic type variable does not imply an interface type definition: &quot; + this);
&nbsp;                }
&nbsp;
&nbsp;                public FieldList&lt;FieldDescription.InGenericShape&gt; getDeclaredFields() {
&nbsp;                    throw new IllegalStateException(&quot;A symbolic type variable does not imply field definitions: &quot; + this);
&nbsp;                }
&nbsp;
&nbsp;                public MethodList&lt;MethodDescription.InGenericShape&gt; getDeclaredMethods() {
&nbsp;                    throw new IllegalStateException(&quot;A symbolic type variable does not imply method definitions: &quot; + this);
&nbsp;                }
&nbsp;
&nbsp;                public RecordComponentList&lt;RecordComponentDescription.InGenericShape&gt; getRecordComponents() {
&nbsp;                    throw new IllegalStateException(&quot;A symbolic type variable does not imply record component definitions: &quot; + this);
&nbsp;                }
&nbsp;
&nbsp;                public Generic getComponentType() {
&nbsp;                    throw new IllegalStateException(&quot;A symbolic type variable does not imply a component type: &quot; + this);
&nbsp;                }
&nbsp;
&nbsp;                public TypeList.Generic getTypeArguments() {
&nbsp;                    throw new IllegalStateException(&quot;A symbolic type variable does not imply type arguments: &quot; + this);
&nbsp;                }
&nbsp;
&nbsp;                public Generic findBindingOf(Generic typeVariable) {
&nbsp;                    throw new IllegalStateException(&quot;A symbolic type variable does not imply type arguments: &quot; + this);
&nbsp;                }
&nbsp;
&nbsp;                public TypeList.Generic getLowerBounds() {
&nbsp;                    throw new IllegalStateException(&quot;A symbolic type variable does not imply lower bounds: &quot; + this);
&nbsp;                }
&nbsp;
&nbsp;                public Generic getOwnerType() {
&nbsp;                    throw new IllegalStateException(&quot;A symbolic type variable does not imply an owner type: &quot; + this);
&nbsp;                }
&nbsp;
&nbsp;                public String getTypeName() {
&nbsp;                    return this.toString();
&nbsp;                }
&nbsp;
&nbsp;                public String getActualName() {
&nbsp;                    return this.getSymbol();
&nbsp;                }
&nbsp;
&nbsp;                public &lt;T&gt; T accept(Visitor&lt;T&gt; visitor) {
&nbsp;                    return visitor.onTypeVariable(this);
&nbsp;                }
&nbsp;
&nbsp;                public StackSize getStackSize() {
&nbsp;                    return StackSize.SINGLE;
&nbsp;                }
&nbsp;
&nbsp;                public boolean isArray() {
&nbsp;                    return false;
&nbsp;                }
<b class="fc">&nbsp;</b>
&nbsp;                public boolean isPrimitive() {
&nbsp;                    return false;
&nbsp;                }
&nbsp;
&nbsp;                public boolean isRecord() {
&nbsp;                    return false;
&nbsp;                }
&nbsp;
&nbsp;                public boolean represents(Type type) {
&nbsp;                    if (type == null) {
&nbsp;                        throw new NullPointerException();
&nbsp;                    } else {
&nbsp;                        return false;
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                public Iterator&lt;TypeDefinition&gt; iterator() {
&nbsp;                    throw new IllegalStateException(&quot;A symbolic type variable does not imply a super type definition: &quot; + this);
&nbsp;                }
<b class="fc">&nbsp;</b>
&nbsp;                public int hashCode() {
&nbsp;                    return this.symbol.hashCode();
&nbsp;                }
<b class="fc">&nbsp;</b>
&nbsp;                public boolean equals(@CheckForNull Object other) {
&nbsp;                    if (this == other) {
&nbsp;                        return true;
&nbsp;                    } else if (!(other instanceof Generic)) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        Generic typeDescription = (Generic)other;
&nbsp;                        return typeDescription.getSort().isTypeVariable() &amp;&amp; this.getSymbol().equals(typeDescription.getSymbol());
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public String toString() {
&nbsp;                    return this.getSymbol();
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public abstract static class OfParameterizedType extends AbstractBase {
&nbsp;            public OfParameterizedType() {
&nbsp;            }
&nbsp;
&nbsp;            public TypeDefinition.Sort getSort() {
&nbsp;                return Sort.PARAMETERIZED;
&nbsp;            }
&nbsp;
&nbsp;            @Nonnull(
&nbsp;                when = When.MAYBE
&nbsp;            )
&nbsp;            public Generic getSuperClass() {
&nbsp;                Generic superClass = this.asErasure().getSuperClass();
&nbsp;                return (Generic)(superClass == null ? TypeDescription.Generic.UNDEFINED : new LazyProjection.WithResolvedErasure(superClass, new Visitor.Substitutor.ForTypeVariableBinding(this)));
&nbsp;            }
&nbsp;
&nbsp;            public TypeList.Generic getInterfaces() {
&nbsp;                return new TypeList.ForDetachedTypes.WithResolvedErasure(this.asErasure().getInterfaces(), new Visitor.Substitutor.ForTypeVariableBinding(this));
&nbsp;            }
&nbsp;
&nbsp;            public FieldList&lt;FieldDescription.InGenericShape&gt; getDeclaredFields() {
<b class="fc">&nbsp;                return new FieldList.TypeSubstituting(this, this.asErasure().getDeclaredFields(), new Visitor.Substitutor.ForTypeVariableBinding(this));</b>
&nbsp;            }
&nbsp;
&nbsp;            public MethodList&lt;MethodDescription.InGenericShape&gt; getDeclaredMethods() {
&nbsp;                return new MethodList.TypeSubstituting(this, this.asErasure().getDeclaredMethods(), new Visitor.Substitutor.ForTypeVariableBinding(this));
&nbsp;            }
&nbsp;
&nbsp;            public RecordComponentList&lt;RecordComponentDescription.InGenericShape&gt; getRecordComponents() {
<b class="fc">&nbsp;                return new RecordComponentList.TypeSubstituting(this, this.asErasure().getRecordComponents(), new Visitor.Substitutor.ForTypeVariableBinding(this));</b>
&nbsp;            }
&nbsp;
&nbsp;            @Nonnull(
&nbsp;                when = When.MAYBE
&nbsp;            )
&nbsp;            public Generic findBindingOf(Generic typeVariable) {
&nbsp;                Generic typeDescription = this;
&nbsp;
&nbsp;                do {
&nbsp;                    TypeList.Generic typeArguments = ((Generic)typeDescription).getTypeArguments();
&nbsp;                    TypeList.Generic typeVariables = ((Generic)typeDescription).asErasure().getTypeVariables();
&nbsp;
&nbsp;                    for(int index = 0; index &lt; Math.min(typeArguments.size(), typeVariables.size()); ++index) {
&nbsp;                        if (typeVariable.equals(typeVariables.get(index))) {
&nbsp;                            return (Generic)typeArguments.get(index);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    typeDescription = ((Generic)typeDescription).getOwnerType();
&nbsp;                } while(typeDescription != null &amp;&amp; ((Generic)typeDescription).getSort().isParameterized());
&nbsp;
&nbsp;                return TypeDescription.Generic.UNDEFINED;
&nbsp;            }
&nbsp;
&nbsp;            public TypeList.Generic getUpperBounds() {
&nbsp;                throw new IllegalStateException(&quot;A parameterized type does not imply upper bounds: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            public TypeList.Generic getLowerBounds() {
&nbsp;                throw new IllegalStateException(&quot;A parameterized type does not imply lower bounds: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            public Generic getComponentType() {
&nbsp;                throw new IllegalStateException(&quot;A parameterized type does not imply a component type: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            public TypeVariableSource getTypeVariableSource() {
&nbsp;                throw new IllegalStateException(&quot;A parameterized type does not imply a type variable source: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            public String getSymbol() {
&nbsp;                throw new IllegalStateException(&quot;A parameterized type does not imply a symbol: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            public String getTypeName() {
&nbsp;                return this.toString();
&nbsp;            }
&nbsp;
&nbsp;            public String getActualName() {
&nbsp;                return this.toString();
&nbsp;            }
&nbsp;
&nbsp;            public boolean isPrimitive() {
&nbsp;                return false;
&nbsp;            }
&nbsp;
&nbsp;            public boolean isArray() {
&nbsp;                return false;
&nbsp;            }
&nbsp;
&nbsp;            public boolean isRecord() {
&nbsp;                return this.asErasure().isRecord();
&nbsp;            }
&nbsp;
&nbsp;            public boolean represents(Type type) {
&nbsp;                return this.equals(Sort.describe(type));
&nbsp;            }
&nbsp;
&nbsp;            public Iterator&lt;TypeDefinition&gt; iterator() {
&nbsp;                return new TypeDefinition.SuperClassIterator(this);
&nbsp;            }
&nbsp;
&nbsp;            public &lt;T&gt; T accept(Visitor&lt;T&gt; visitor) {
&nbsp;                return visitor.onParameterizedType(this);
&nbsp;            }
&nbsp;
&nbsp;            public StackSize getStackSize() {
&nbsp;                return StackSize.SINGLE;
&nbsp;            }
&nbsp;
&nbsp;            @Enhance(&quot;hashCode&quot;)
&nbsp;            public int hashCode() {
&nbsp;                int var1 = this.hashCode;
&nbsp;                int var10000;
&nbsp;                if (var1 != 0) {
&nbsp;                    var10000 = 0;
&nbsp;                } else {
&nbsp;                    int result = 1;
&nbsp;
&nbsp;                    Generic typeArgument;
&nbsp;                    for(Iterator var4 = this.getTypeArguments().iterator(); var4.hasNext(); result = 31 * result + typeArgument.hashCode()) {
&nbsp;                        typeArgument = (Generic)var4.next();
<b class="fc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    Generic ownerType = this.getOwnerType();
&nbsp;                    var10000 = result ^ (ownerType == null ? this.asErasure().hashCode() : ownerType.hashCode());
&nbsp;                }
&nbsp;
&nbsp;                int var2 = var10000;
&nbsp;                if (var2 == 0) {
&nbsp;                    var2 = this.hashCode;
&nbsp;                } else {
&nbsp;                    this.hashCode = var2;
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                return var2;</b>
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(@CheckForNull Object other) {
&nbsp;                if (this == other) {
&nbsp;                    return true;
&nbsp;                } else if (!(other instanceof Generic)) {
<b class="fc">&nbsp;                    return false;</b>
&nbsp;                } else {
&nbsp;                    Generic typeDescription = (Generic)other;
&nbsp;                    if (!typeDescription.getSort().isParameterized()) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        Generic ownerType = this.getOwnerType();
&nbsp;                        Generic otherOwnerType = typeDescription.getOwnerType();
&nbsp;                        return this.asErasure().equals(typeDescription.asErasure()) &amp;&amp; (ownerType != null || otherOwnerType == null) &amp;&amp; (ownerType == null || ownerType.equals(otherOwnerType)) &amp;&amp; this.getTypeArguments().equals(typeDescription.getTypeArguments());
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public String toString() {
&nbsp;                StringBuilder stringBuilder = new StringBuilder();
&nbsp;                TypeDescription.Generic.OfParameterizedType.RenderingDelegate.CURRENT.apply(stringBuilder, this.asErasure(), this.getOwnerType());
&nbsp;                TypeList.Generic typeArguments = this.getTypeArguments();
&nbsp;                if (!typeArguments.isEmpty()) {
&nbsp;                    stringBuilder.append(&#39;&lt;&#39;);
&nbsp;                    boolean multiple = false;
&nbsp;
<b class="fc">&nbsp;                    for(Iterator var4 = typeArguments.iterator(); var4.hasNext(); multiple = true) {</b>
&nbsp;                        Generic typeArgument = (Generic)var4.next();
&nbsp;                        if (multiple) {
&nbsp;                            stringBuilder.append(&quot;, &quot;);
&nbsp;                        }
&nbsp;
<b class="fc">&nbsp;                        stringBuilder.append(typeArgument.getTypeName());</b>
&nbsp;                    }
&nbsp;
&nbsp;                    stringBuilder.append(&#39;&gt;&#39;);
&nbsp;                }
&nbsp;
&nbsp;                return stringBuilder.toString();
&nbsp;            }
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;            public static class ForGenerifiedErasure extends OfParameterizedType {</b>
<b class="fc">&nbsp;                private final TypeDescription typeDescription;</b>
&nbsp;
&nbsp;                protected ForGenerifiedErasure(TypeDescription typeDescription) {
<b class="fc">&nbsp;                    this.typeDescription = typeDescription;</b>
&nbsp;                }
&nbsp;
&nbsp;                public static Generic of(TypeDescription typeDescription) {
&nbsp;                    return (Generic)(typeDescription.isGenerified() ? new ForGenerifiedErasure(typeDescription) : new OfNonGenericType.ForErasure(typeDescription));
&nbsp;                }
&nbsp;
&nbsp;                public TypeDescription asErasure() {
&nbsp;                    return this.typeDescription;
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;</b>
&nbsp;                public TypeList.Generic getTypeArguments() {
&nbsp;                    return new TypeList.ForDetachedTypes(this.typeDescription.getTypeVariables(), TypeDescription.Generic.Visitor.AnnotationStripper.INSTANCE);
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                @Nonnull(
&nbsp;                    when = When.MAYBE
&nbsp;                )
&nbsp;                public Generic getOwnerType() {
&nbsp;                    TypeDescription declaringType = this.typeDescription.getDeclaringType();
&nbsp;                    return declaringType == null ? TypeDescription.Generic.UNDEFINED : of(declaringType);
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationList getDeclaredAnnotations() {
&nbsp;                    return new AnnotationList.Empty();
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public static class ForReifiedType extends OfParameterizedType {
&nbsp;                private final Generic parameterizedType;
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                protected ForReifiedType(Generic parameterizedType) {</b>
&nbsp;                    this.parameterizedType = parameterizedType;
&nbsp;                }
&nbsp;
&nbsp;                @Nonnull(
&nbsp;                    when = When.MAYBE
&nbsp;                )
&nbsp;                public Generic getSuperClass() {
&nbsp;                    Generic superClass = super.getSuperClass();
&nbsp;                    return (Generic)(superClass == null ? TypeDescription.Generic.UNDEFINED : new LazyProjection.WithResolvedErasure(superClass, TypeDescription.Generic.Visitor.Reifying.INHERITING));
&nbsp;                }
&nbsp;
&nbsp;                public TypeList.Generic getInterfaces() {
&nbsp;                    return new TypeList.ForDetachedTypes.WithResolvedErasure(super.getInterfaces(), TypeDescription.Generic.Visitor.Reifying.INHERITING);
&nbsp;                }
&nbsp;
&nbsp;                public FieldList&lt;FieldDescription.InGenericShape&gt; getDeclaredFields() {
&nbsp;                    return new FieldList.TypeSubstituting(this, super.getDeclaredFields(), TypeDescription.Generic.Visitor.TypeErasing.INSTANCE);
&nbsp;                }
&nbsp;
&nbsp;                public MethodList&lt;MethodDescription.InGenericShape&gt; getDeclaredMethods() {
&nbsp;                    return new MethodList.TypeSubstituting(this, super.getDeclaredMethods(), TypeDescription.Generic.Visitor.TypeErasing.INSTANCE);
&nbsp;                }
&nbsp;
&nbsp;                public TypeList.Generic getTypeArguments() {
&nbsp;                    return new TypeList.ForDetachedTypes(this.parameterizedType.getTypeArguments(), TypeDescription.Generic.Visitor.TypeErasing.INSTANCE);
&nbsp;                }
&nbsp;
&nbsp;                @Nonnull(
&nbsp;                    when = When.MAYBE
&nbsp;                )
&nbsp;                public Generic getOwnerType() {
&nbsp;                    Generic ownerType = this.parameterizedType.getOwnerType();
<b class="fc">&nbsp;                    return ownerType == null ? TypeDescription.Generic.UNDEFINED : (Generic)ownerType.accept(TypeDescription.Generic.Visitor.Reifying.INHERITING);</b>
&nbsp;                }
&nbsp;
&nbsp;                public TypeDescription asErasure() {
&nbsp;                    return this.parameterizedType.asErasure();
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationList getDeclaredAnnotations() {
&nbsp;                    return new AnnotationList.Empty();
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public static class Latent extends OfParameterizedType {
&nbsp;                private final TypeDescription rawType;
&nbsp;                @Nonnull(
&nbsp;                    when = When.MAYBE
&nbsp;                )
&nbsp;                private final Generic ownerType;
&nbsp;                private final List&lt;? extends Generic&gt; parameters;
&nbsp;                private final AnnotationSource annotationSource;
&nbsp;
&nbsp;                public Latent(TypeDescription rawType, @Nonnull(when = When.MAYBE) Generic ownerType, List&lt;? extends Generic&gt; parameters, AnnotationSource annotationSource) {
&nbsp;                    this.rawType = rawType;
&nbsp;                    this.ownerType = ownerType;
&nbsp;                    this.parameters = parameters;
&nbsp;                    this.annotationSource = annotationSource;
&nbsp;                }
&nbsp;
&nbsp;                public TypeDescription asErasure() {
&nbsp;                    return this.rawType;
&nbsp;                }
&nbsp;
&nbsp;                @Nonnull(
&nbsp;                    when = When.MAYBE
&nbsp;                )
&nbsp;                public Generic getOwnerType() {
&nbsp;                    return this.ownerType;
&nbsp;                }
&nbsp;
&nbsp;                public TypeList.Generic getTypeArguments() {
&nbsp;                    return new TypeList.Explicit(this.parameters);
&nbsp;                }
<b class="fc">&nbsp;</b>
&nbsp;                public AnnotationList getDeclaredAnnotations() {
&nbsp;                    return this.annotationSource.getDeclaredAnnotations();
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public static class ForLoadedType extends OfParameterizedType {
&nbsp;                private final ParameterizedType parameterizedType;
&nbsp;                private final AnnotationReader annotationReader;
&nbsp;
&nbsp;                public ForLoadedType(ParameterizedType parameterizedType) {
&nbsp;                    this(parameterizedType, TypeDescription.Generic.AnnotationReader.NoOp.INSTANCE);
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                protected ForLoadedType(ParameterizedType parameterizedType, AnnotationReader annotationReader) {</b>
&nbsp;                    this.parameterizedType = parameterizedType;
&nbsp;                    this.annotationReader = annotationReader;
&nbsp;                }
&nbsp;
&nbsp;                public TypeList.Generic getTypeArguments() {
&nbsp;                    return new ParameterArgumentTypeList(this.parameterizedType.getActualTypeArguments(), this.annotationReader);
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                @Nonnull(
&nbsp;                    when = When.MAYBE
&nbsp;                )
&nbsp;                public Generic getOwnerType() {
&nbsp;                    Type ownerType = this.parameterizedType.getOwnerType();
&nbsp;                    return ownerType == null ? TypeDescription.Generic.UNDEFINED : Sort.describe(ownerType, this.annotationReader.ofOwnerType());
&nbsp;                }
&nbsp;
&nbsp;                public TypeDescription asErasure() {
&nbsp;                    return TypeDescription.ForLoadedType.of((Class)this.parameterizedType.getRawType());
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                public AnnotationList getDeclaredAnnotations() {</b>
&nbsp;                    return this.annotationReader.asList();
&nbsp;                }
&nbsp;
&nbsp;                public boolean represents(Type type) {
&nbsp;                    return this.parameterizedType == type || super.represents(type);
&nbsp;                }
&nbsp;
&nbsp;                protected static class ParameterArgumentTypeList extends TypeList.AbstractBase {
&nbsp;                    private final Type[] argumentType;
&nbsp;                    private final AnnotationReader annotationReader;
&nbsp;
&nbsp;                    protected ParameterArgumentTypeList(Type[] argumentType, AnnotationReader annotationReader) {
<b class="fc">&nbsp;                        this.argumentType = argumentType;</b>
&nbsp;                        this.annotationReader = annotationReader;
&nbsp;                    }
&nbsp;
&nbsp;                    public Generic get(int index) {
&nbsp;                        return Sort.describe(this.argumentType[index], this.annotationReader.ofTypeArgument(index));
<b class="fc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    public int size() {
&nbsp;                        return this.argumentType.length;
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            protected static enum RenderingDelegate {
&nbsp;                FOR_LEGACY_VM {
&nbsp;                    protected void apply(StringBuilder stringBuilder, TypeDescription erasure, @Nonnull(when = When.MAYBE) Generic ownerType) {
&nbsp;                        if (ownerType != null) {
&nbsp;                            stringBuilder.append(ownerType.getTypeName()).append(&#39;.&#39;).append(ownerType.getSort().isParameterized() ? erasure.getSimpleName() : erasure.getName());
&nbsp;                        } else {
&nbsp;                            stringBuilder.append(erasure.getName());
&nbsp;                        }
&nbsp;
&nbsp;                    }
&nbsp;                },
&nbsp;                FOR_JAVA_8_CAPABLE_VM {
&nbsp;                    protected void apply(StringBuilder stringBuilder, TypeDescription erasure, @Nonnull(when = When.MAYBE) Generic ownerType) {
&nbsp;                        if (ownerType != null) {
<b class="fc">&nbsp;                            stringBuilder.append(ownerType.getTypeName()).append(&#39;$&#39;);</b>
<b class="fc">&nbsp;                            if (ownerType.getSort().isParameterized()) {</b>
<b class="fc">&nbsp;                                stringBuilder.append(erasure.getName().replace(ownerType.asErasure().getName() + &quot;$&quot;, &quot;&quot;));</b>
<b class="fc">&nbsp;                            } else {</b>
<b class="fc">&nbsp;                                stringBuilder.append(erasure.getSimpleName());</b>
<b class="fc">&nbsp;                            }</b>
<b class="fc">&nbsp;                        } else {</b>
<b class="fc">&nbsp;                            stringBuilder.append(erasure.getName());</b>
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                };</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                protected static final RenderingDelegate CURRENT = ClassFileVersion.ofThisVm(ClassFileVersion.JAVA_V5).isAtLeast(ClassFileVersion.JAVA_V8) ? FOR_JAVA_8_CAPABLE_VM : FOR_LEGACY_VM;</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                private RenderingDelegate() {</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                protected abstract void apply(StringBuilder var1, TypeDescription var2, @Nonnull(when = When.MAYBE) Generic var3);</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        public abstract static class OfWildcardType extends AbstractBase {
&nbsp;            public static final String SYMBOL = &quot;?&quot;;
&nbsp;
&nbsp;            public OfWildcardType() {
&nbsp;            }
&nbsp;
&nbsp;            public TypeDefinition.Sort getSort() {
&nbsp;                return Sort.WILDCARD;
&nbsp;            }
&nbsp;
&nbsp;            public TypeDescription asErasure() {
&nbsp;                throw new IllegalStateException(&quot;A wildcard does not represent an erasable type: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            @Nonnull(
&nbsp;                when = When.MAYBE
&nbsp;            )
&nbsp;            public Generic getSuperClass() {
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;A wildcard does not imply a super type definition: &quot; + this);</b>
&nbsp;            }
&nbsp;
&nbsp;            public TypeList.Generic getInterfaces() {
&nbsp;                throw new IllegalStateException(&quot;A wildcard does not imply an interface type definition: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            public FieldList&lt;FieldDescription.InGenericShape&gt; getDeclaredFields() {
&nbsp;                throw new IllegalStateException(&quot;A wildcard does not imply field definitions: &quot; + this);
&nbsp;            }
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;            public MethodList&lt;MethodDescription.InGenericShape&gt; getDeclaredMethods() {</b>
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;A wildcard does not imply method definitions: &quot; + this);</b>
&nbsp;            }
&nbsp;
&nbsp;            public RecordComponentList&lt;RecordComponentDescription.InGenericShape&gt; getRecordComponents() {
&nbsp;                throw new IllegalStateException(&quot;A wildcard does not imply record component definitions: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            public Generic getComponentType() {
&nbsp;                throw new IllegalStateException(&quot;A wildcard does not imply a component type: &quot; + this);
&nbsp;            }
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;            public TypeVariableSource getTypeVariableSource() {</b>
&nbsp;                throw new IllegalStateException(&quot;A wildcard does not imply a type variable source: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            public TypeList.Generic getTypeArguments() {
&nbsp;                throw new IllegalStateException(&quot;A wildcard does not imply type arguments: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            public Generic findBindingOf(Generic typeVariable) {
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;A wildcard does not imply type arguments: &quot; + this);</b>
&nbsp;            }
&nbsp;
&nbsp;            public Generic getOwnerType() {
&nbsp;                throw new IllegalStateException(&quot;A wildcard does not imply an owner type: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            public String getSymbol() {
&nbsp;                throw new IllegalStateException(&quot;A wildcard does not imply a symbol: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            public String getTypeName() {
&nbsp;                return this.toString();
&nbsp;            }
&nbsp;
&nbsp;            public String getActualName() {
&nbsp;                return this.toString();
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            public boolean isPrimitive() {</b>
<b class="fc">&nbsp;                return false;</b>
&nbsp;            }
<b class="fc">&nbsp;</b>
&nbsp;            public boolean isArray() {
&nbsp;                return false;
&nbsp;            }
&nbsp;
&nbsp;            public boolean isRecord() {
&nbsp;                return false;
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            public boolean represents(Type type) {
&nbsp;                return this.equals(Sort.describe(type));
&nbsp;            }
&nbsp;
&nbsp;            public Iterator&lt;TypeDefinition&gt; iterator() {
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;A wildcard does not imply a super type definition: &quot; + this);</b>
&nbsp;            }
&nbsp;
&nbsp;            public &lt;T&gt; T accept(Visitor&lt;T&gt; visitor) {
&nbsp;                return visitor.onWildcard(this);
&nbsp;            }
&nbsp;
&nbsp;            public StackSize getStackSize() {
&nbsp;                throw new IllegalStateException(&quot;A wildcard does not imply an operand stack size: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            @Enhance(&quot;hashCode&quot;)
&nbsp;            public int hashCode() {
&nbsp;                int var1 = this.hashCode;
&nbsp;                int var10000;
&nbsp;                if (var1 != 0) {
&nbsp;                    var10000 = 0;
&nbsp;                } else {
&nbsp;                    int lowerHash = 1;
&nbsp;                    int upperHash = 1;
&nbsp;
<b class="fc">&nbsp;                    Iterator var5;</b>
<b class="fc">&nbsp;                    Generic upperBound;</b>
&nbsp;                    for(var5 = this.getLowerBounds().iterator(); var5.hasNext(); lowerHash = 31 * lowerHash + upperBound.hashCode()) {
&nbsp;                        upperBound = (Generic)var5.next();
&nbsp;                    }
&nbsp;
&nbsp;                    for(var5 = this.getUpperBounds().iterator(); var5.hasNext(); upperHash = 31 * upperHash + upperBound.hashCode()) {
&nbsp;                        upperBound = (Generic)var5.next();
<b class="fc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    var10000 = lowerHash ^ upperHash;
&nbsp;                }
&nbsp;
&nbsp;                int var2 = var10000;
&nbsp;                if (var2 == 0) {
&nbsp;                    var2 = this.hashCode;
&nbsp;                } else {
&nbsp;                    this.hashCode = var2;
&nbsp;                }
&nbsp;
&nbsp;                return var2;
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(@CheckForNull Object other) {
&nbsp;                if (this == other) {
&nbsp;                    return true;
&nbsp;                } else if (!(other instanceof Generic)) {
<b class="fc">&nbsp;                    return false;</b>
<b class="fc">&nbsp;                } else {</b>
&nbsp;                    Generic typeDescription = (Generic)other;
&nbsp;                    return typeDescription.getSort().isWildcard() &amp;&amp; this.getUpperBounds().equals(typeDescription.getUpperBounds()) &amp;&amp; this.getLowerBounds().equals(typeDescription.getLowerBounds());
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public String toString() {
&nbsp;                StringBuilder stringBuilder = new StringBuilder(&quot;?&quot;);
&nbsp;                TypeList.Generic bounds = this.getLowerBounds();
<b class="fc">&nbsp;                if (!bounds.isEmpty()) {</b>
&nbsp;                    stringBuilder.append(&quot; super &quot;);
&nbsp;                } else {
&nbsp;                    bounds = this.getUpperBounds();
&nbsp;                    if (((Generic)bounds.getOnly()).equals(TypeDescription.Generic.OBJECT)) {
&nbsp;                        return &quot;?&quot;;
&nbsp;                    }
&nbsp;
&nbsp;                    stringBuilder.append(&quot; extends &quot;);
&nbsp;                }
&nbsp;
&nbsp;                return stringBuilder.append(((Generic)bounds.getOnly()).getTypeName()).toString();
&nbsp;            }
&nbsp;
&nbsp;            public static class Latent extends OfWildcardType {
&nbsp;                private final List&lt;? extends Generic&gt; upperBounds;
&nbsp;                private final List&lt;? extends Generic&gt; lowerBounds;
&nbsp;                private final AnnotationSource annotationSource;
&nbsp;
&nbsp;                protected Latent(List&lt;? extends Generic&gt; upperBounds, List&lt;? extends Generic&gt; lowerBounds, AnnotationSource annotationSource) {
&nbsp;                    this.upperBounds = upperBounds;
&nbsp;                    this.lowerBounds = lowerBounds;
&nbsp;                    this.annotationSource = annotationSource;
&nbsp;                }
&nbsp;
&nbsp;                public static Generic unbounded(AnnotationSource annotationSource) {
&nbsp;                    return new Latent(Collections.singletonList(TypeDescription.Generic.OBJECT), Collections.emptyList(), annotationSource);
&nbsp;                }
&nbsp;
&nbsp;                public static Generic boundedAbove(Generic upperBound, AnnotationSource annotationSource) {
&nbsp;                    return new Latent(Collections.singletonList(upperBound), Collections.emptyList(), annotationSource);
&nbsp;                }
&nbsp;
&nbsp;                public static Generic boundedBelow(Generic lowerBound, AnnotationSource annotationSource) {
&nbsp;                    return new Latent(Collections.singletonList(TypeDescription.Generic.OBJECT), Collections.singletonList(lowerBound), annotationSource);
&nbsp;                }
&nbsp;
&nbsp;                public TypeList.Generic getUpperBounds() {
&nbsp;                    return new TypeList.Explicit(this.upperBounds);
&nbsp;                }
&nbsp;
&nbsp;                public TypeList.Generic getLowerBounds() {
&nbsp;                    return new TypeList.Explicit(this.lowerBounds);
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationList getDeclaredAnnotations() {
&nbsp;                    return this.annotationSource.getDeclaredAnnotations();
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public static class ForLoadedType extends OfWildcardType {
&nbsp;                private final WildcardType wildcardType;
&nbsp;                private final AnnotationReader annotationReader;
&nbsp;
&nbsp;                public ForLoadedType(WildcardType wildcardType) {
&nbsp;                    this(wildcardType, TypeDescription.Generic.AnnotationReader.NoOp.INSTANCE);
&nbsp;                }
&nbsp;
&nbsp;                protected ForLoadedType(WildcardType wildcardType, AnnotationReader annotationReader) {
&nbsp;                    this.wildcardType = wildcardType;
&nbsp;                    this.annotationReader = annotationReader;
&nbsp;                }
&nbsp;
&nbsp;                public TypeList.Generic getUpperBounds() {
&nbsp;                    return new WildcardUpperBoundTypeList(this.wildcardType.getUpperBounds(), this.annotationReader);
&nbsp;                }
&nbsp;
&nbsp;                public TypeList.Generic getLowerBounds() {
&nbsp;                    return new WildcardLowerBoundTypeList(this.wildcardType.getLowerBounds(), this.annotationReader);
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationList getDeclaredAnnotations() {
&nbsp;                    return this.annotationReader.asList();
&nbsp;                }
&nbsp;
&nbsp;                public boolean represents(Type type) {
&nbsp;                    return this.wildcardType == type || super.represents(type);
&nbsp;                }
&nbsp;
&nbsp;                protected static class WildcardLowerBoundTypeList extends TypeList.AbstractBase {
&nbsp;                    private final Type[] lowerBound;
&nbsp;                    private final AnnotationReader annotationReader;
&nbsp;
&nbsp;                    protected WildcardLowerBoundTypeList(Type[] lowerBound, AnnotationReader annotationReader) {
&nbsp;                        this.lowerBound = lowerBound;
&nbsp;                        this.annotationReader = annotationReader;
&nbsp;                    }
&nbsp;
&nbsp;                    public Generic get(int index) {
&nbsp;                        return Sort.describe(this.lowerBound[index], this.annotationReader.ofWildcardLowerBoundType(index));
&nbsp;                    }
&nbsp;
&nbsp;                    public int size() {
&nbsp;                        return this.lowerBound.length;
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                protected static class WildcardUpperBoundTypeList extends TypeList.AbstractBase {
&nbsp;                    private final Type[] upperBound;
&nbsp;                    private final AnnotationReader annotationReader;
&nbsp;
&nbsp;                    protected WildcardUpperBoundTypeList(Type[] upperBound, AnnotationReader annotationReader) {
&nbsp;                        this.upperBound = upperBound;
&nbsp;                        this.annotationReader = annotationReader;
&nbsp;                    }
&nbsp;
&nbsp;                    public Generic get(int index) {
&nbsp;                        return Sort.describe(this.upperBound[index], this.annotationReader.ofWildcardUpperBoundType(index));
&nbsp;                    }
&nbsp;
&nbsp;                    public int size() {
&nbsp;                        return this.upperBound.length;
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public abstract static class OfGenericArray extends AbstractBase {
&nbsp;            public OfGenericArray() {
&nbsp;            }
&nbsp;
&nbsp;            @SuppressFBWarnings(
&nbsp;                value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;                justification = &quot;Assuming component type for array type.&quot;
&nbsp;            )
&nbsp;            public TypeDefinition.Sort getSort() {
&nbsp;                return this.getComponentType().getSort().isNonGeneric() ? Sort.NON_GENERIC : Sort.GENERIC_ARRAY;
&nbsp;            }
&nbsp;
&nbsp;            @SuppressFBWarnings(
&nbsp;                value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;                justification = &quot;Assuming component type for array type.&quot;
&nbsp;            )
&nbsp;            public TypeDescription asErasure() {
&nbsp;                return TypeDescription.ArrayProjection.of(this.getComponentType().asErasure(), 1);
&nbsp;            }
&nbsp;
&nbsp;            @Nonnull(
&nbsp;                when = When.MAYBE
&nbsp;            )
&nbsp;            public Generic getSuperClass() {
&nbsp;                return TypeDescription.Generic.OBJECT;
&nbsp;            }
&nbsp;
&nbsp;            public TypeList.Generic getInterfaces() {
&nbsp;                return TypeDescription.ARRAY_INTERFACES;
&nbsp;            }
&nbsp;
&nbsp;            public FieldList&lt;FieldDescription.InGenericShape&gt; getDeclaredFields() {
&nbsp;                return new FieldList.Empty();
&nbsp;            }
&nbsp;
&nbsp;            public MethodList&lt;MethodDescription.InGenericShape&gt; getDeclaredMethods() {
&nbsp;                return new MethodList.Empty();
&nbsp;            }
&nbsp;
&nbsp;            public RecordComponentList&lt;RecordComponentDescription.InGenericShape&gt; getRecordComponents() {
&nbsp;                return new RecordComponentList.Empty();
&nbsp;            }
&nbsp;
&nbsp;            public TypeList.Generic getUpperBounds() {
&nbsp;                throw new IllegalStateException(&quot;A generic array type does not imply upper type bounds: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            public TypeList.Generic getLowerBounds() {
&nbsp;                throw new IllegalStateException(&quot;A generic array type does not imply lower type bounds: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            public TypeVariableSource getTypeVariableSource() {
&nbsp;                throw new IllegalStateException(&quot;A generic array type does not imply a type variable source: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            public TypeList.Generic getTypeArguments() {
&nbsp;                throw new IllegalStateException(&quot;A generic array type does not imply type arguments: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            public Generic findBindingOf(Generic typeVariable) {
&nbsp;                throw new IllegalStateException(&quot;A generic array type does not imply type arguments: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            @Nonnull(
&nbsp;                when = When.MAYBE
&nbsp;            )
&nbsp;            public Generic getOwnerType() {
&nbsp;                return TypeDescription.Generic.UNDEFINED;
&nbsp;            }
&nbsp;
&nbsp;            public String getSymbol() {
&nbsp;                throw new IllegalStateException(&quot;A generic array type does not imply a symbol: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            public String getTypeName() {
&nbsp;                return this.getSort().isNonGeneric() ? this.asErasure().getTypeName() : this.toString();
&nbsp;            }
&nbsp;
&nbsp;            public String getActualName() {
&nbsp;                return this.getSort().isNonGeneric() ? this.asErasure().getActualName() : this.toString();
&nbsp;            }
&nbsp;
&nbsp;            public boolean isArray() {
&nbsp;                return true;
&nbsp;            }
&nbsp;
&nbsp;            public boolean isPrimitive() {
&nbsp;                return false;
&nbsp;            }
&nbsp;
&nbsp;            public boolean isRecord() {
&nbsp;                return false;
&nbsp;            }
&nbsp;
&nbsp;            public Iterator&lt;TypeDefinition&gt; iterator() {
&nbsp;                return new TypeDefinition.SuperClassIterator(this);
&nbsp;            }
&nbsp;
&nbsp;            public &lt;T&gt; T accept(Visitor&lt;T&gt; visitor) {
&nbsp;                return this.getSort().isNonGeneric() ? visitor.onNonGenericType(this) : visitor.onGenericArray(this);
&nbsp;            }
&nbsp;
&nbsp;            public StackSize getStackSize() {
&nbsp;                return StackSize.SINGLE;
&nbsp;            }
&nbsp;
&nbsp;            @Enhance(&quot;hashCode&quot;)
&nbsp;            @SuppressFBWarnings(
&nbsp;                value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;                justification = &quot;Assuming component type for array type.&quot;
&nbsp;            )
&nbsp;            public int hashCode() {
&nbsp;                int var1 = this.hashCode;
&nbsp;                int var2 = var1 != 0 ? 0 : (this.getSort().isNonGeneric() ? this.asErasure().hashCode() : this.getComponentType().hashCode());
&nbsp;                if (var2 == 0) {
&nbsp;                    var2 = this.hashCode;
&nbsp;                } else {
&nbsp;                    this.hashCode = var2;
&nbsp;                }
&nbsp;
&nbsp;                return var2;
&nbsp;            }
&nbsp;
&nbsp;            @SuppressFBWarnings(
&nbsp;                value = {&quot;EQ_CHECK_FOR_OPERAND_NOT_COMPATIBLE_WITH_THIS&quot;, &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;                justification = &quot;Type check is performed by erasure implementation. Assuming component type for array type.&quot;
&nbsp;            )
&nbsp;            public boolean equals(@CheckForNull Object other) {
&nbsp;                if (this == other) {
&nbsp;                    return true;
&nbsp;                } else if (this.getSort().isNonGeneric()) {
&nbsp;                    return this.asErasure().equals(other);
&nbsp;                } else if (!(other instanceof Generic)) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    Generic typeDescription = (Generic)other;
&nbsp;                    return typeDescription.getSort().isGenericArray() &amp;&amp; this.getComponentType().equals(typeDescription.getComponentType());
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @SuppressFBWarnings(
&nbsp;                value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;                justification = &quot;Assuming component type for array type.&quot;
&nbsp;            )
&nbsp;            public String toString() {
&nbsp;                return this.getSort().isNonGeneric() ? this.asErasure().toString() : this.getComponentType().getTypeName() + &quot;[]&quot;;
&nbsp;            }
&nbsp;
&nbsp;            public static class Latent extends OfGenericArray {
&nbsp;                private final Generic componentType;
&nbsp;                private final AnnotationSource annotationSource;
&nbsp;
&nbsp;                public Latent(Generic componentType, AnnotationSource annotationSource) {
&nbsp;                    this.componentType = componentType;
&nbsp;                    this.annotationSource = annotationSource;
&nbsp;                }
&nbsp;
&nbsp;                public Generic getComponentType() {
&nbsp;                    return this.componentType;
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationList getDeclaredAnnotations() {
&nbsp;                    return this.annotationSource.getDeclaredAnnotations();
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public static class ForLoadedType extends OfGenericArray {
&nbsp;                private final GenericArrayType genericArrayType;
&nbsp;                private final AnnotationReader annotationReader;
&nbsp;
&nbsp;                public ForLoadedType(GenericArrayType genericArrayType) {
&nbsp;                    this(genericArrayType, TypeDescription.Generic.AnnotationReader.NoOp.INSTANCE);
&nbsp;                }
&nbsp;
&nbsp;                protected ForLoadedType(GenericArrayType genericArrayType, AnnotationReader annotationReader) {
&nbsp;                    this.genericArrayType = genericArrayType;
&nbsp;                    this.annotationReader = annotationReader;
&nbsp;                }
&nbsp;
&nbsp;                @Nonnull(
&nbsp;                    when = When.MAYBE
&nbsp;                )
&nbsp;                public Generic getComponentType() {
&nbsp;                    return Sort.describe(this.genericArrayType.getGenericComponentType(), this.annotationReader.ofComponentType());
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationList getDeclaredAnnotations() {
&nbsp;                    return this.annotationReader.asList();
&nbsp;                }
&nbsp;
&nbsp;                public boolean represents(Type type) {
&nbsp;                    return this.genericArrayType == type || super.represents(type);
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public abstract static class OfNonGenericType extends AbstractBase {
&nbsp;            public OfNonGenericType() {
&nbsp;            }
&nbsp;
&nbsp;            public TypeDefinition.Sort getSort() {
&nbsp;                return Sort.NON_GENERIC;
&nbsp;            }
&nbsp;
&nbsp;            @Nonnull(
&nbsp;                when = When.MAYBE
&nbsp;            )
&nbsp;            public Generic getSuperClass() {
&nbsp;                TypeDescription erasure = this.asErasure();
&nbsp;                Generic superClass = erasure.getSuperClass();
&nbsp;                if (TypeDescription.AbstractBase.RAW_TYPES) {
&nbsp;                    return superClass;
&nbsp;                } else {
&nbsp;                    return (Generic)(superClass == null ? TypeDescription.Generic.UNDEFINED : new LazyProjection.WithResolvedErasure(superClass, new Visitor.ForRawType(erasure), Empty.INSTANCE));
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public TypeList.Generic getInterfaces() {
&nbsp;                TypeDescription erasure = this.asErasure();
&nbsp;                return (TypeList.Generic)(TypeDescription.AbstractBase.RAW_TYPES ? erasure.getInterfaces() : new TypeList.ForDetachedTypes.WithResolvedErasure(erasure.getInterfaces(), new Visitor.ForRawType(erasure)));
&nbsp;            }
&nbsp;
&nbsp;            public FieldList&lt;FieldDescription.InGenericShape&gt; getDeclaredFields() {
&nbsp;                TypeDescription erasure = this.asErasure();
&nbsp;                return new FieldList.TypeSubstituting(this, erasure.getDeclaredFields(), (Visitor)(TypeDescription.AbstractBase.RAW_TYPES ? TypeDescription.Generic.Visitor.NoOp.INSTANCE : new Visitor.ForRawType(erasure)));
&nbsp;            }
&nbsp;
&nbsp;            public MethodList&lt;MethodDescription.InGenericShape&gt; getDeclaredMethods() {
&nbsp;                TypeDescription erasure = this.asErasure();
&nbsp;                return new MethodList.TypeSubstituting(this, erasure.getDeclaredMethods(), (Visitor)(TypeDescription.AbstractBase.RAW_TYPES ? TypeDescription.Generic.Visitor.NoOp.INSTANCE : new Visitor.ForRawType(erasure)));
&nbsp;            }
&nbsp;
&nbsp;            public RecordComponentList&lt;RecordComponentDescription.InGenericShape&gt; getRecordComponents() {
&nbsp;                TypeDescription erasure = this.asErasure();
&nbsp;                return new RecordComponentList.TypeSubstituting(this, erasure.getRecordComponents(), (Visitor)(TypeDescription.AbstractBase.RAW_TYPES ? TypeDescription.Generic.Visitor.NoOp.INSTANCE : new Visitor.ForRawType(erasure)));
&nbsp;            }
&nbsp;
&nbsp;            public TypeList.Generic getTypeArguments() {
&nbsp;                throw new IllegalStateException(&quot;A non-generic type does not imply type arguments: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            public Generic findBindingOf(Generic typeVariable) {
&nbsp;                throw new IllegalStateException(&quot;A non-generic type does not imply type arguments: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            public &lt;T&gt; T accept(Visitor&lt;T&gt; visitor) {
&nbsp;                return visitor.onNonGenericType(this);
&nbsp;            }
&nbsp;
&nbsp;            public String getTypeName() {
&nbsp;                return this.asErasure().getTypeName();
&nbsp;            }
&nbsp;
&nbsp;            public TypeList.Generic getUpperBounds() {
&nbsp;                throw new IllegalStateException(&quot;A non-generic type does not imply upper type bounds: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            public TypeList.Generic getLowerBounds() {
&nbsp;                throw new IllegalStateException(&quot;A non-generic type does not imply lower type bounds: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            public TypeVariableSource getTypeVariableSource() {
&nbsp;                throw new IllegalStateException(&quot;A non-generic type does not imply a type variable source: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            public String getSymbol() {
&nbsp;                throw new IllegalStateException(&quot;A non-generic type does not imply a symbol: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            public StackSize getStackSize() {
&nbsp;                return this.asErasure().getStackSize();
&nbsp;            }
&nbsp;
&nbsp;            public String getActualName() {
&nbsp;                return this.asErasure().getActualName();
&nbsp;            }
&nbsp;
&nbsp;            public boolean isArray() {
&nbsp;                return this.asErasure().isArray();
&nbsp;            }
&nbsp;
&nbsp;            public boolean isPrimitive() {
&nbsp;                return this.asErasure().isPrimitive();
&nbsp;            }
&nbsp;
&nbsp;            public boolean isRecord() {
&nbsp;                return this.asErasure().isRecord();
&nbsp;            }
&nbsp;
&nbsp;            public boolean represents(Type type) {
&nbsp;                return this.asErasure().represents(type);
&nbsp;            }
&nbsp;
&nbsp;            public Iterator&lt;TypeDefinition&gt; iterator() {
&nbsp;                return new TypeDefinition.SuperClassIterator(this);
&nbsp;            }
&nbsp;
&nbsp;            @Enhance(&quot;hashCode&quot;)
&nbsp;            public int hashCode() {
&nbsp;                int var1 = this.hashCode;
&nbsp;                int var2 = var1 != 0 ? 0 : this.asErasure().hashCode();
&nbsp;                if (var2 == 0) {
&nbsp;                    var2 = this.hashCode;
&nbsp;                } else {
&nbsp;                    this.hashCode = var2;
&nbsp;                }
&nbsp;
&nbsp;                return var2;
&nbsp;            }
&nbsp;
&nbsp;            @SuppressFBWarnings(
&nbsp;                value = {&quot;EQ_CHECK_FOR_OPERAND_NOT_COMPATIBLE_WITH_THIS&quot;},
&nbsp;                justification = &quot;Type check is performed by erasure implementation.&quot;
&nbsp;            )
&nbsp;            public boolean equals(@CheckForNull Object other) {
&nbsp;                return this == other || this.asErasure().equals(other);
&nbsp;            }
&nbsp;
&nbsp;            public String toString() {
&nbsp;                return this.asErasure().toString();
&nbsp;            }
&nbsp;
&nbsp;            public static class ForReifiedErasure extends OfNonGenericType {
&nbsp;                private final TypeDescription typeDescription;
&nbsp;
&nbsp;                protected ForReifiedErasure(TypeDescription typeDescription) {
&nbsp;                    this.typeDescription = typeDescription;
&nbsp;                }
&nbsp;
&nbsp;                protected static Generic of(TypeDescription typeDescription) {
&nbsp;                    return (Generic)(typeDescription.isGenerified() ? new ForReifiedErasure(typeDescription) : new ForErasure(typeDescription));
&nbsp;                }
&nbsp;
&nbsp;                @Nonnull(
&nbsp;                    when = When.MAYBE
&nbsp;                )
&nbsp;                public Generic getSuperClass() {
&nbsp;                    Generic superClass = this.typeDescription.getSuperClass();
&nbsp;                    return (Generic)(superClass == null ? TypeDescription.Generic.UNDEFINED : new LazyProjection.WithResolvedErasure(superClass, TypeDescription.Generic.Visitor.Reifying.INHERITING));
&nbsp;                }
&nbsp;
&nbsp;                public TypeList.Generic getInterfaces() {
&nbsp;                    return new TypeList.ForDetachedTypes.WithResolvedErasure(this.typeDescription.getInterfaces(), TypeDescription.Generic.Visitor.Reifying.INHERITING);
&nbsp;                }
&nbsp;
&nbsp;                public FieldList&lt;FieldDescription.InGenericShape&gt; getDeclaredFields() {
&nbsp;                    return new FieldList.TypeSubstituting(this, this.typeDescription.getDeclaredFields(), TypeDescription.Generic.Visitor.TypeErasing.INSTANCE);
&nbsp;                }
&nbsp;
&nbsp;                public MethodList&lt;MethodDescription.InGenericShape&gt; getDeclaredMethods() {
&nbsp;                    return new MethodList.TypeSubstituting(this, this.typeDescription.getDeclaredMethods(), TypeDescription.Generic.Visitor.TypeErasing.INSTANCE);
&nbsp;                }
&nbsp;
&nbsp;                public TypeDescription asErasure() {
&nbsp;                    return this.typeDescription;
&nbsp;                }
&nbsp;
&nbsp;                @Nonnull(
&nbsp;                    when = When.MAYBE
&nbsp;                )
&nbsp;                public Generic getOwnerType() {
&nbsp;                    TypeDescription declaringType = this.typeDescription.getDeclaringType();
&nbsp;                    return declaringType == null ? TypeDescription.Generic.UNDEFINED : of(declaringType);
&nbsp;                }
&nbsp;
&nbsp;                @Nonnull(
&nbsp;                    when = When.MAYBE
&nbsp;                )
&nbsp;                public Generic getComponentType() {
&nbsp;                    TypeDescription componentType = this.typeDescription.getComponentType();
&nbsp;                    return componentType == null ? TypeDescription.Generic.UNDEFINED : of(componentType);
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationList getDeclaredAnnotations() {
&nbsp;                    return new AnnotationList.Empty();
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public static class Latent extends OfNonGenericType {
&nbsp;                private final TypeDescription typeDescription;
&nbsp;                @Nonnull(
&nbsp;                    when = When.MAYBE
&nbsp;                )
&nbsp;                private final Generic declaringType;
&nbsp;                private final AnnotationSource annotationSource;
&nbsp;
&nbsp;                public Latent(TypeDescription typeDescription, AnnotationSource annotationSource) {
&nbsp;                    this(typeDescription, typeDescription.getDeclaringType(), annotationSource);
&nbsp;                }
&nbsp;
&nbsp;                private Latent(TypeDescription typeDescription, @Nonnull(when = When.MAYBE) TypeDescription declaringType, AnnotationSource annotationSource) {
&nbsp;                    this(typeDescription, declaringType == null ? TypeDescription.Generic.UNDEFINED : declaringType.asGenericType(), annotationSource);
&nbsp;                }
&nbsp;
&nbsp;                protected Latent(TypeDescription typeDescription, @Nonnull(when = When.MAYBE) Generic declaringType, AnnotationSource annotationSource) {
&nbsp;                    this.typeDescription = typeDescription;
&nbsp;                    this.declaringType = declaringType;
&nbsp;                    this.annotationSource = annotationSource;
&nbsp;                }
&nbsp;
&nbsp;                @Nonnull(
&nbsp;                    when = When.MAYBE
&nbsp;                )
&nbsp;                public Generic getOwnerType() {
&nbsp;                    return this.declaringType;
&nbsp;                }
&nbsp;
&nbsp;                @Nonnull(
&nbsp;                    when = When.MAYBE
&nbsp;                )
&nbsp;                public Generic getComponentType() {
&nbsp;                    TypeDescription componentType = this.typeDescription.getComponentType();
&nbsp;                    return componentType == null ? TypeDescription.Generic.UNDEFINED : componentType.asGenericType();
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationList getDeclaredAnnotations() {
&nbsp;                    return this.annotationSource.getDeclaredAnnotations();
&nbsp;                }
&nbsp;
&nbsp;                public TypeDescription asErasure() {
&nbsp;                    return this.typeDescription;
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public static class ForErasure extends OfNonGenericType {
&nbsp;                private final TypeDescription typeDescription;
&nbsp;
&nbsp;                public ForErasure(TypeDescription typeDescription) {
&nbsp;                    this.typeDescription = typeDescription;
&nbsp;                }
&nbsp;
&nbsp;                public TypeDescription asErasure() {
&nbsp;                    return this.typeDescription;
&nbsp;                }
&nbsp;
&nbsp;                @Nonnull(
&nbsp;                    when = When.MAYBE
&nbsp;                )
&nbsp;                public Generic getOwnerType() {
&nbsp;                    TypeDescription declaringType = this.typeDescription.getDeclaringType();
&nbsp;                    return declaringType == null ? TypeDescription.Generic.UNDEFINED : declaringType.asGenericType();
&nbsp;                }
&nbsp;
&nbsp;                @Nonnull(
&nbsp;                    when = When.MAYBE
&nbsp;                )
&nbsp;                public Generic getComponentType() {
&nbsp;                    TypeDescription componentType = this.typeDescription.getComponentType();
&nbsp;                    return componentType == null ? TypeDescription.Generic.UNDEFINED : componentType.asGenericType();
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationList getDeclaredAnnotations() {
&nbsp;                    return new AnnotationList.Empty();
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public static class ForLoadedType extends OfNonGenericType {
&nbsp;                private static final Map&lt;Class&lt;?&gt;, Generic&gt; TYPE_CACHE = new HashMap();
&nbsp;                private final Class&lt;?&gt; type;
&nbsp;                private final AnnotationReader annotationReader;
&nbsp;
&nbsp;                public ForLoadedType(Class&lt;?&gt; type) {
&nbsp;                    this(type, TypeDescription.Generic.AnnotationReader.NoOp.INSTANCE);
&nbsp;                }
&nbsp;
&nbsp;                protected ForLoadedType(Class&lt;?&gt; type, AnnotationReader annotationReader) {
&nbsp;                    this.type = type;
&nbsp;                    this.annotationReader = annotationReader;
&nbsp;                }
&nbsp;
&nbsp;                public static Generic of(Class&lt;?&gt; type) {
&nbsp;                    Generic typeDescription = (Generic)TYPE_CACHE.get(type);
&nbsp;                    return (Generic)(typeDescription == null ? new ForLoadedType(type) : typeDescription);
&nbsp;                }
&nbsp;
&nbsp;                public TypeDescription asErasure() {
&nbsp;                    return TypeDescription.ForLoadedType.of(this.type);
&nbsp;                }
&nbsp;
&nbsp;                @Nonnull(
&nbsp;                    when = When.MAYBE
&nbsp;                )
&nbsp;                public Generic getOwnerType() {
&nbsp;                    Class&lt;?&gt; declaringClass = this.type.getDeclaringClass();
&nbsp;                    return (Generic)(declaringClass == null ? TypeDescription.Generic.UNDEFINED : new ForLoadedType(declaringClass, this.annotationReader.ofOuterClass()));
&nbsp;                }
&nbsp;
&nbsp;                @Nonnull(
&nbsp;                    when = When.MAYBE
&nbsp;                )
&nbsp;                public Generic getComponentType() {
&nbsp;                    Class&lt;?&gt; componentType = this.type.getComponentType();
&nbsp;                    return (Generic)(componentType == null ? TypeDescription.Generic.UNDEFINED : new ForLoadedType(componentType, this.annotationReader.ofComponentType()));
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationList getDeclaredAnnotations() {
&nbsp;                    return this.annotationReader.asList();
&nbsp;                }
&nbsp;
&nbsp;                public boolean represents(Type type) {
&nbsp;                    return this.type == type || super.represents(type);
&nbsp;                }
&nbsp;
&nbsp;                static {
&nbsp;                    TYPE_CACHE.put(TargetType.class, new ForLoadedType(TargetType.class));
&nbsp;                    TYPE_CACHE.put(Object.class, new ForLoadedType(Object.class));
&nbsp;                    TYPE_CACHE.put(String.class, new ForLoadedType(String.class));
&nbsp;                    TYPE_CACHE.put(Boolean.class, new ForLoadedType(Boolean.class));
&nbsp;                    TYPE_CACHE.put(Byte.class, new ForLoadedType(Byte.class));
&nbsp;                    TYPE_CACHE.put(Short.class, new ForLoadedType(Short.class));
&nbsp;                    TYPE_CACHE.put(Character.class, new ForLoadedType(Character.class));
&nbsp;                    TYPE_CACHE.put(Integer.class, new ForLoadedType(Integer.class));
&nbsp;                    TYPE_CACHE.put(Long.class, new ForLoadedType(Long.class));
&nbsp;                    TYPE_CACHE.put(Float.class, new ForLoadedType(Float.class));
&nbsp;                    TYPE_CACHE.put(Double.class, new ForLoadedType(Double.class));
&nbsp;                    TYPE_CACHE.put(Void.TYPE, new ForLoadedType(Void.TYPE));
&nbsp;                    TYPE_CACHE.put(Boolean.TYPE, new ForLoadedType(Boolean.TYPE));
&nbsp;                    TYPE_CACHE.put(Byte.TYPE, new ForLoadedType(Byte.TYPE));
&nbsp;                    TYPE_CACHE.put(Short.TYPE, new ForLoadedType(Short.TYPE));
&nbsp;                    TYPE_CACHE.put(Character.TYPE, new ForLoadedType(Character.TYPE));
&nbsp;                    TYPE_CACHE.put(Integer.TYPE, new ForLoadedType(Integer.TYPE));
&nbsp;                    TYPE_CACHE.put(Long.TYPE, new ForLoadedType(Long.TYPE));
&nbsp;                    TYPE_CACHE.put(Float.TYPE, new ForLoadedType(Float.TYPE));
&nbsp;                    TYPE_CACHE.put(Double.TYPE, new ForLoadedType(Double.TYPE));
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public abstract static class AbstractBase extends ModifierReviewable.AbstractBase implements Generic {
&nbsp;            public AbstractBase() {
&nbsp;            }
&nbsp;
&nbsp;            public int getModifiers() {
&nbsp;                return this.asErasure().getModifiers();
&nbsp;            }
&nbsp;
&nbsp;            public Generic asGenericType() {
&nbsp;                return this;
&nbsp;            }
&nbsp;
&nbsp;            public Generic asRawType() {
&nbsp;                return this.asErasure().asGenericType();
&nbsp;            }
&nbsp;
&nbsp;            public boolean represents(Type type) {
&nbsp;                return this.equals(Sort.describe(type));
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public interface AnnotationReader {
&nbsp;            AnnotatedElement resolve();
&nbsp;
&nbsp;            AnnotationList asList();
&nbsp;
&nbsp;            AnnotationReader ofWildcardUpperBoundType(int var1);
&nbsp;
&nbsp;            AnnotationReader ofWildcardLowerBoundType(int var1);
&nbsp;
&nbsp;            AnnotationReader ofTypeVariableBoundType(int var1);
&nbsp;
&nbsp;            AnnotationReader ofTypeArgument(int var1);
&nbsp;
&nbsp;            AnnotationReader ofOwnerType();
&nbsp;
&nbsp;            AnnotationReader ofOuterClass();
&nbsp;
&nbsp;            AnnotationReader ofComponentType();
&nbsp;
&nbsp;            public static class ForOwnerType extends Delegator.Chained {
&nbsp;                private static final AnnotatedType ANNOTATED_TYPE = (AnnotatedType)doPrivileged(JavaDispatcher.of(AnnotatedType.class));
&nbsp;
&nbsp;                protected ForOwnerType(AnnotationReader annotationReader) {
&nbsp;                    super(annotationReader);
&nbsp;                }
&nbsp;
&nbsp;                protected AnnotatedElement resolve(AnnotatedElement annotatedElement) {
&nbsp;                    try {
&nbsp;                        AnnotatedElement annotatedOwnerType = ANNOTATED_TYPE.getAnnotatedOwnerType(annotatedElement);
&nbsp;                        return (AnnotatedElement)(annotatedOwnerType == null ? TypeDescription.Generic.AnnotationReader.NoOp.INSTANCE : annotatedOwnerType);
&nbsp;                    } catch (ClassCastException var3) {
&nbsp;                        return TypeDescription.Generic.AnnotationReader.NoOp.INSTANCE;
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Proxied(&quot;java.lang.reflect.AnnotatedType&quot;)
&nbsp;                protected interface AnnotatedType {
&nbsp;                    @Nonnull(
&nbsp;                        when = When.MAYBE
&nbsp;                    )
&nbsp;                    @Defaults
&nbsp;                    @Proxied(&quot;getAnnotatedOwnerType&quot;)
&nbsp;                    AnnotatedElement getAnnotatedOwnerType(AnnotatedElement var1);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public static class ForComponentType extends Delegator.Chained {
&nbsp;                private static final AnnotatedParameterizedType ANNOTATED_PARAMETERIZED_TYPE = (AnnotatedParameterizedType)doPrivileged(JavaDispatcher.of(AnnotatedParameterizedType.class));
&nbsp;
&nbsp;                protected ForComponentType(AnnotationReader annotationReader) {
&nbsp;                    super(annotationReader);
&nbsp;                }
&nbsp;
&nbsp;                protected AnnotatedElement resolve(AnnotatedElement annotatedElement) {
&nbsp;                    if (!ANNOTATED_PARAMETERIZED_TYPE.isInstance(annotatedElement)) {
&nbsp;                        return TypeDescription.Generic.AnnotationReader.NoOp.INSTANCE;
&nbsp;                    } else {
&nbsp;                        try {
&nbsp;                            return ANNOTATED_PARAMETERIZED_TYPE.getAnnotatedGenericComponentType(annotatedElement);
&nbsp;                        } catch (ClassCastException var3) {
&nbsp;                            return TypeDescription.Generic.AnnotationReader.NoOp.INSTANCE;
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Proxied(&quot;java.lang.reflect.AnnotatedArrayType&quot;)
&nbsp;                protected interface AnnotatedParameterizedType {
&nbsp;                    @Instance
&nbsp;                    @Proxied(&quot;isInstance&quot;)
&nbsp;                    boolean isInstance(AnnotatedElement var1);
&nbsp;
&nbsp;                    @Proxied(&quot;getAnnotatedGenericComponentType&quot;)
&nbsp;                    AnnotatedElement getAnnotatedGenericComponentType(AnnotatedElement var1);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;            public static class ForTypeArgument extends Delegator.Chained {
&nbsp;                private static final AnnotatedParameterizedType ANNOTATED_PARAMETERIZED_TYPE = (AnnotatedParameterizedType)doPrivileged(JavaDispatcher.of(AnnotatedParameterizedType.class));
&nbsp;                private final int index;
&nbsp;
&nbsp;                protected ForTypeArgument(AnnotationReader annotationReader, int index) {
&nbsp;                    super(annotationReader);
&nbsp;                    this.index = index;
&nbsp;                }
&nbsp;
&nbsp;                protected AnnotatedElement resolve(AnnotatedElement annotatedElement) {
&nbsp;                    if (!ANNOTATED_PARAMETERIZED_TYPE.isInstance(annotatedElement)) {
&nbsp;                        return TypeDescription.Generic.AnnotationReader.NoOp.INSTANCE;
&nbsp;                    } else {
&nbsp;                        try {
&nbsp;                            return ANNOTATED_PARAMETERIZED_TYPE.getAnnotatedActualTypeArguments(annotatedElement)[this.index];
&nbsp;                        } catch (ClassCastException var3) {
&nbsp;                            return TypeDescription.Generic.AnnotationReader.NoOp.INSTANCE;
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(Object var1) {
&nbsp;                    if (!super.equals(var1)) {
&nbsp;                        return false;
&nbsp;                    } else if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.index == ((ForTypeArgument)var1).index;
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return super.hashCode() * 31 + this.index;
&nbsp;                }
&nbsp;
&nbsp;                @Proxied(&quot;java.lang.reflect.AnnotatedParameterizedType&quot;)
&nbsp;                protected interface AnnotatedParameterizedType {
&nbsp;                    @Instance
&nbsp;                    @Proxied(&quot;isInstance&quot;)
&nbsp;                    boolean isInstance(AnnotatedElement var1);
&nbsp;
&nbsp;                    @Proxied(&quot;getAnnotatedActualTypeArguments&quot;)
&nbsp;                    AnnotatedElement[] getAnnotatedActualTypeArguments(AnnotatedElement var1);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;            public static class ForTypeVariableBoundType extends Delegator.Chained {
&nbsp;                private static final AnnotatedTypeVariable ANNOTATED_TYPE_VARIABLE = (AnnotatedTypeVariable)doPrivileged(JavaDispatcher.of(AnnotatedTypeVariable.class));
&nbsp;                private final int index;
&nbsp;
&nbsp;                protected ForTypeVariableBoundType(AnnotationReader annotationReader, int index) {
&nbsp;                    super(annotationReader);
&nbsp;                    this.index = index;
&nbsp;                }
&nbsp;
&nbsp;                protected AnnotatedElement resolve(AnnotatedElement annotatedElement) {
&nbsp;                    if (!ANNOTATED_TYPE_VARIABLE.isInstance(annotatedElement)) {
&nbsp;                        return TypeDescription.Generic.AnnotationReader.NoOp.INSTANCE;
&nbsp;                    } else {
&nbsp;                        try {
&nbsp;                            return ANNOTATED_TYPE_VARIABLE.getAnnotatedBounds(annotatedElement)[this.index];
&nbsp;                        } catch (ClassCastException var3) {
&nbsp;                            return TypeDescription.Generic.AnnotationReader.NoOp.INSTANCE;
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(Object var1) {
&nbsp;                    if (!super.equals(var1)) {
&nbsp;                        return false;
&nbsp;                    } else if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.index == ((ForTypeVariableBoundType)var1).index;
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return super.hashCode() * 31 + this.index;
&nbsp;                }
&nbsp;
&nbsp;                @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;                protected static class OfFormalTypeVariable extends Delegator {
&nbsp;                    private static final FormalTypeVariable TYPE_VARIABLE = (FormalTypeVariable)doPrivileged(JavaDispatcher.of(FormalTypeVariable.class));
&nbsp;                    private final TypeVariable&lt;?&gt; typeVariable;
&nbsp;                    private final int index;
&nbsp;
&nbsp;                    protected OfFormalTypeVariable(TypeVariable&lt;?&gt; typeVariable, int index) {
&nbsp;                        this.typeVariable = typeVariable;
&nbsp;                        this.index = index;
&nbsp;                    }
&nbsp;
&nbsp;                    public AnnotatedElement resolve() {
&nbsp;                        try {
&nbsp;                            AnnotatedElement[] annotatedBound = TYPE_VARIABLE.getAnnotatedBounds(this.typeVariable);
&nbsp;                            return (AnnotatedElement)(annotatedBound.length == 0 ? TypeDescription.Generic.AnnotationReader.NoOp.INSTANCE : annotatedBound[this.index]);
&nbsp;                        } catch (ClassCastException var2) {
&nbsp;                            return TypeDescription.Generic.AnnotationReader.NoOp.INSTANCE;
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(Object var1) {
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else if (this.index != ((OfFormalTypeVariable)var1).index) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return this.typeVariable.equals(((OfFormalTypeVariable)var1).typeVariable);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return (this.getClass().hashCode() * 31 + this.typeVariable.hashCode()) * 31 + this.index;
&nbsp;                    }
&nbsp;
&nbsp;                    @Proxied(&quot;java.lang.reflect.TypeVariable&quot;)
&nbsp;                    protected interface FormalTypeVariable {
&nbsp;                        @Defaults
&nbsp;                        @Proxied(&quot;getAnnotatedBounds&quot;)
&nbsp;                        AnnotatedElement[] getAnnotatedBounds(Object var1);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Proxied(&quot;java.lang.reflect.AnnotatedTypeVariable&quot;)
&nbsp;                protected interface AnnotatedTypeVariable {
&nbsp;                    @Instance
&nbsp;                    @Proxied(&quot;isInstance&quot;)
&nbsp;                    boolean isInstance(AnnotatedElement var1);
&nbsp;
&nbsp;                    @Proxied(&quot;getAnnotatedBounds&quot;)
&nbsp;                    AnnotatedElement[] getAnnotatedBounds(AnnotatedElement var1);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;            public static class ForWildcardLowerBoundType extends Delegator.Chained {
&nbsp;                private static final AnnotatedWildcardType ANNOTATED_WILDCARD_TYPE = (AnnotatedWildcardType)doPrivileged(JavaDispatcher.of(AnnotatedWildcardType.class));
&nbsp;                private final int index;
&nbsp;
&nbsp;                protected ForWildcardLowerBoundType(AnnotationReader annotationReader, int index) {
&nbsp;                    super(annotationReader);
&nbsp;                    this.index = index;
&nbsp;                }
&nbsp;
&nbsp;                protected AnnotatedElement resolve(AnnotatedElement annotatedElement) {
&nbsp;                    if (!ANNOTATED_WILDCARD_TYPE.isInstance(annotatedElement)) {
&nbsp;                        return TypeDescription.Generic.AnnotationReader.NoOp.INSTANCE;
&nbsp;                    } else {
&nbsp;                        try {
&nbsp;                            return ANNOTATED_WILDCARD_TYPE.getAnnotatedLowerBounds(annotatedElement)[this.index];
&nbsp;                        } catch (ClassCastException var3) {
&nbsp;                            return TypeDescription.Generic.AnnotationReader.NoOp.INSTANCE;
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(Object var1) {
&nbsp;                    if (!super.equals(var1)) {
&nbsp;                        return false;
&nbsp;                    } else if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.index == ((ForWildcardLowerBoundType)var1).index;
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return super.hashCode() * 31 + this.index;
&nbsp;                }
&nbsp;
&nbsp;                @Proxied(&quot;java.lang.reflect.AnnotatedWildcardType&quot;)
&nbsp;                protected interface AnnotatedWildcardType {
&nbsp;                    @Instance
&nbsp;                    @Proxied(&quot;isInstance&quot;)
&nbsp;                    boolean isInstance(AnnotatedElement var1);
&nbsp;
&nbsp;                    @Proxied(&quot;getAnnotatedLowerBounds&quot;)
&nbsp;                    AnnotatedElement[] getAnnotatedLowerBounds(AnnotatedElement var1);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;            public static class ForWildcardUpperBoundType extends Delegator.Chained {
&nbsp;                private static final AnnotatedWildcardType ANNOTATED_WILDCARD_TYPE = (AnnotatedWildcardType)doPrivileged(JavaDispatcher.of(AnnotatedWildcardType.class));
&nbsp;                private final int index;
&nbsp;
&nbsp;                protected ForWildcardUpperBoundType(AnnotationReader annotationReader, int index) {
&nbsp;                    super(annotationReader);
&nbsp;                    this.index = index;
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                protected AnnotatedElement resolve(AnnotatedElement annotatedElement) {
&nbsp;                    if (!ANNOTATED_WILDCARD_TYPE.isInstance(annotatedElement)) {
&nbsp;                        return TypeDescription.Generic.AnnotationReader.NoOp.INSTANCE;
&nbsp;                    } else {
<b class="fc">&nbsp;                        try {</b>
&nbsp;                            AnnotatedElement[] annotatedUpperBound = ANNOTATED_WILDCARD_TYPE.getAnnotatedUpperBounds(annotatedElement);
&nbsp;                            return (AnnotatedElement)(annotatedUpperBound.length == 0 ? TypeDescription.Generic.AnnotationReader.NoOp.INSTANCE : annotatedUpperBound[this.index]);
&nbsp;                        } catch (ClassCastException var3) {
&nbsp;                            return TypeDescription.Generic.AnnotationReader.NoOp.INSTANCE;
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(Object var1) {
&nbsp;                    if (!super.equals(var1)) {
&nbsp;                        return false;
&nbsp;                    } else if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.index == ((ForWildcardUpperBoundType)var1).index;
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return super.hashCode() * 31 + this.index;
&nbsp;                }
&nbsp;
&nbsp;                @Proxied(&quot;java.lang.reflect.AnnotatedWildcardType&quot;)
&nbsp;                protected interface AnnotatedWildcardType {
&nbsp;                    @Instance
&nbsp;                    @Proxied(&quot;isInstance&quot;)
&nbsp;                    boolean isInstance(AnnotatedElement var1);
&nbsp;
&nbsp;                    @Proxied(&quot;getAnnotatedUpperBounds&quot;)
&nbsp;                    AnnotatedElement[] getAnnotatedUpperBounds(AnnotatedElement var1);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public abstract static class Delegator implements AnnotationReader {
&nbsp;                private static final boolean ACCESS_CONTROLLER;
&nbsp;
&nbsp;                public Delegator() {
&nbsp;                }
&nbsp;
&nbsp;                @net.bytebuddy.build.AccessControllerPlugin.Enhance
&nbsp;                static &lt;T&gt; T doPrivileged(PrivilegedAction&lt;T&gt; action) {
&nbsp;                    return ACCESS_CONTROLLER ? AccessController.doPrivileged(action) : action.run();
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationReader ofWildcardUpperBoundType(int index) {
&nbsp;                    return new ForWildcardUpperBoundType(this, index);
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationReader ofWildcardLowerBoundType(int index) {
&nbsp;                    return new ForWildcardLowerBoundType(this, index);
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationReader ofTypeVariableBoundType(int index) {
&nbsp;                    return new ForTypeVariableBoundType(this, index);
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationReader ofTypeArgument(int index) {
&nbsp;                    return new ForTypeArgument(this, index);
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationReader ofOwnerType() {
&nbsp;                    return new ForOwnerType(this);
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationReader ofOuterClass() {
&nbsp;                    return new ForOwnerType(this);
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationReader ofComponentType() {
&nbsp;                    return new ForComponentType(this);
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationList asList() {
&nbsp;                    return new AnnotationList.ForLoadedAnnotations(this.resolve().getDeclaredAnnotations());
&nbsp;                }
&nbsp;
&nbsp;                static {
&nbsp;                    try {
&nbsp;                        Class.forName(&quot;java.security.AccessController&quot;, false, (ClassLoader)null);
&nbsp;                        ACCESS_CONTROLLER = Boolean.parseBoolean(System.getProperty(&quot;net.bytebuddy.securitymanager&quot;, &quot;true&quot;));
&nbsp;                    } catch (ClassNotFoundException var0) {
&nbsp;                        ACCESS_CONTROLLER = false;
&nbsp;                    } catch (SecurityException var1) {
&nbsp;                        ACCESS_CONTROLLER = true;
&nbsp;                    }
&nbsp;
&nbsp;                }
&nbsp;
&nbsp;                public static class ForLoadedRecordComponent extends Delegator {
&nbsp;                    private final Object recordComponent;
&nbsp;
&nbsp;                    public ForLoadedRecordComponent(Object recordComponent) {
&nbsp;                        this.recordComponent = recordComponent;
&nbsp;                    }
&nbsp;
&nbsp;                    public AnnotatedElement resolve() {
&nbsp;                        return net.bytebuddy.description.type.RecordComponentDescription.ForLoadedRecordComponent.RECORD_COMPONENT.getAnnotatedType(this.recordComponent);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance(
&nbsp;                    includeSyntheticFields = true
&nbsp;                )
&nbsp;                public static class ForLoadedExecutableExceptionType extends Delegator {
&nbsp;                    protected static final Dispatcher DISPATCHER = (Dispatcher)doPrivileged(JavaDispatcher.of(Dispatcher.class));
&nbsp;                    private final AccessibleObject executable;
&nbsp;                    private final int index;
&nbsp;
<b class="fc">&nbsp;                    public ForLoadedExecutableExceptionType(AccessibleObject executable, int index) {</b>
&nbsp;                        this.executable = executable;
&nbsp;                        this.index = index;
&nbsp;                    }
&nbsp;
&nbsp;                    public AnnotatedElement resolve() {
&nbsp;                        AnnotatedElement[] element = DISPATCHER.getAnnotatedExceptionTypes(this.executable);
&nbsp;                        return (AnnotatedElement)(element.length == 0 ? TypeDescription.Generic.AnnotationReader.NoOp.INSTANCE : element[this.index]);
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(Object var1) {
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else if (this.index != ((ForLoadedExecutableExceptionType)var1).index) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return this.executable.equals(((ForLoadedExecutableExceptionType)var1).executable);
<b class="fc">&nbsp;                        }</b>
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return (this.getClass().hashCode() * 31 + this.executable.hashCode()) * 31 + this.index;
&nbsp;                    }
&nbsp;
&nbsp;                    @Proxied(&quot;java.lang.reflect.Executable&quot;)
&nbsp;                    protected interface Dispatcher {
&nbsp;                        @Defaults
&nbsp;                        @Proxied(&quot;getAnnotatedExceptionTypes&quot;)
&nbsp;                        AnnotatedElement[] getAnnotatedExceptionTypes(Object var1);
&nbsp;                    }
&nbsp;                }
<b class="fc">&nbsp;</b>
&nbsp;                @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance(
&nbsp;                    includeSyntheticFields = true
&nbsp;                )
&nbsp;                public static class ForLoadedExecutableParameterType extends Delegator {
&nbsp;                    protected static final Dispatcher DISPATCHER = (Dispatcher)doPrivileged(JavaDispatcher.of(Dispatcher.class));
&nbsp;                    private final AccessibleObject executable;
<b class="fc">&nbsp;                    private final int index;</b>
&nbsp;
&nbsp;                    public ForLoadedExecutableParameterType(AccessibleObject executable, int index) {
&nbsp;                        this.executable = executable;
&nbsp;                        this.index = index;
&nbsp;                    }
&nbsp;
&nbsp;                    public AnnotatedElement resolve() {
&nbsp;                        AnnotatedElement[] element = DISPATCHER.getAnnotatedParameterTypes(this.executable);
&nbsp;                        return (AnnotatedElement)(element.length == 0 ? TypeDescription.Generic.AnnotationReader.NoOp.INSTANCE : element[this.index]);
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(Object var1) {
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
<b class="fc">&nbsp;                            return false;</b>
&nbsp;                        } else if (this.index != ((ForLoadedExecutableParameterType)var1).index) {
<b class="fc">&nbsp;                            return false;</b>
&nbsp;                        } else {
&nbsp;                            return this.executable.equals(((ForLoadedExecutableParameterType)var1).executable);
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;</b>
&nbsp;                    public int hashCode() {
&nbsp;                        return (this.getClass().hashCode() * 31 + this.executable.hashCode()) * 31 + this.index;
&nbsp;                    }
&nbsp;
&nbsp;                    @Proxied(&quot;java.lang.reflect.Executable&quot;)
&nbsp;                    protected interface Dispatcher {
&nbsp;                        @Defaults
&nbsp;                        @Proxied(&quot;getAnnotatedParameterTypes&quot;)
&nbsp;                        AnnotatedElement[] getAnnotatedParameterTypes(Object var1);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance(
&nbsp;                    includeSyntheticFields = true
&nbsp;                )
&nbsp;                public static class ForLoadedMethodReturnType extends Delegator {
&nbsp;                    protected static final Dispatcher DISPATCHER = (Dispatcher)doPrivileged(JavaDispatcher.of(Dispatcher.class));
&nbsp;                    private final Method method;
&nbsp;
&nbsp;                    public ForLoadedMethodReturnType(Method method) {
&nbsp;                        this.method = method;
&nbsp;                    }
&nbsp;
&nbsp;                    public AnnotatedElement resolve() {
&nbsp;                        AnnotatedElement element = DISPATCHER.getAnnotatedReturnType(this.method);
&nbsp;                        return (AnnotatedElement)(element == null ? TypeDescription.Generic.AnnotationReader.NoOp.INSTANCE : element);
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(Object var1) {
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return this.method.equals(((ForLoadedMethodReturnType)var1).method);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return this.getClass().hashCode() * 31 + this.method.hashCode();
&nbsp;                    }
&nbsp;
&nbsp;                    @Proxied(&quot;java.lang.reflect.Method&quot;)
&nbsp;                    protected interface Dispatcher {
&nbsp;                        @Nonnull(
&nbsp;                            when = When.MAYBE
&nbsp;                        )
&nbsp;                        @Defaults
&nbsp;                        @Proxied(&quot;getAnnotatedReturnType&quot;)
&nbsp;                        AnnotatedElement getAnnotatedReturnType(Method var1);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance(
&nbsp;                    includeSyntheticFields = true
&nbsp;                )
&nbsp;                public static class ForLoadedField extends Delegator {
&nbsp;                    protected static final Dispatcher DISPATCHER = (Dispatcher)doPrivileged(JavaDispatcher.of(Dispatcher.class));
&nbsp;                    private final Field field;
&nbsp;
&nbsp;                    public ForLoadedField(Field field) {
&nbsp;                        this.field = field;
&nbsp;                    }
&nbsp;
&nbsp;                    public AnnotatedElement resolve() {
&nbsp;                        AnnotatedElement element = DISPATCHER.getAnnotatedType(this.field);
&nbsp;                        return (AnnotatedElement)(element == null ? TypeDescription.Generic.AnnotationReader.NoOp.INSTANCE : element);
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(Object var1) {
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return this.field.equals(((ForLoadedField)var1).field);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return this.getClass().hashCode() * 31 + this.field.hashCode();
&nbsp;                    }
&nbsp;
&nbsp;                    @Proxied(&quot;java.lang.reflect.Field&quot;)
&nbsp;                    protected interface Dispatcher {
&nbsp;                        @Nonnull(
&nbsp;                            when = When.MAYBE
&nbsp;                        )
&nbsp;                        @Defaults
&nbsp;                        @Proxied(&quot;getAnnotatedType&quot;)
&nbsp;                        AnnotatedElement getAnnotatedType(Field var1);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance(
&nbsp;                    includeSyntheticFields = true
&nbsp;                )
&nbsp;                public static class ForLoadedInterface extends Delegator {
&nbsp;                    private final Class&lt;?&gt; type;
&nbsp;                    private final int index;
&nbsp;
&nbsp;                    public ForLoadedInterface(Class&lt;?&gt; type, int index) {
&nbsp;                        this.type = type;
&nbsp;                        this.index = index;
&nbsp;                    }
&nbsp;
&nbsp;                    public AnnotatedElement resolve() {
&nbsp;                        AnnotatedElement[] element = TypeDescription.ForLoadedType.DISPATCHER.getAnnotatedInterfaces(this.type);
&nbsp;                        return (AnnotatedElement)(element.length == 0 ? TypeDescription.Generic.AnnotationReader.NoOp.INSTANCE : element[this.index]);
&nbsp;                    }
&nbsp;
<b class="fc">&nbsp;                    public boolean equals(Object var1) {</b>
<b class="fc">&nbsp;                        if (this == var1) {</b>
<b class="fc">&nbsp;                            return true;</b>
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else if (this.index != ((ForLoadedInterface)var1).index) {
&nbsp;                            return false;
<b class="fc">&nbsp;                        } else {</b>
&nbsp;                            return this.type.equals(((ForLoadedInterface)var1).type);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return (this.getClass().hashCode() * 31 + this.type.hashCode()) * 31 + this.index;
&nbsp;                    }
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;</b>
&nbsp;                @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance(
&nbsp;                    includeSyntheticFields = true
&nbsp;                )
&nbsp;                public static class ForLoadedSuperClass extends Delegator {
&nbsp;                    private final Class&lt;?&gt; type;
&nbsp;
&nbsp;                    public ForLoadedSuperClass(Class&lt;?&gt; type) {
&nbsp;                        this.type = type;
<b class="fc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    public AnnotatedElement resolve() {
&nbsp;                        AnnotatedElement element = TypeDescription.ForLoadedType.DISPATCHER.getAnnotatedSuperclass(this.type);
&nbsp;                        return (AnnotatedElement)(element == null ? TypeDescription.Generic.AnnotationReader.NoOp.INSTANCE : element);
&nbsp;                    }
&nbsp;
<b class="fc">&nbsp;                    public boolean equals(Object var1) {</b>
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return this.type.equals(((ForLoadedSuperClass)var1).type);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return this.getClass().hashCode() * 31 + this.type.hashCode();
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;                public static class ForLoadedTypeVariable extends Delegator {
&nbsp;                    private final TypeVariable&lt;?&gt; typeVariable;
&nbsp;
&nbsp;                    public ForLoadedTypeVariable(TypeVariable&lt;?&gt; typeVariable) {
&nbsp;                        this.typeVariable = typeVariable;
&nbsp;                    }
&nbsp;
&nbsp;                    @SuppressFBWarnings(
&nbsp;                        value = {&quot;BC_VACUOUS_INSTANCEOF&quot;},
&nbsp;                        justification = &quot;Cast is required for JVMs before Java 8.&quot;
&nbsp;                    )
&nbsp;                    public AnnotatedElement resolve() {
&nbsp;                        return (AnnotatedElement)(this.typeVariable instanceof AnnotatedElement ? this.typeVariable : TypeDescription.Generic.AnnotationReader.NoOp.INSTANCE);
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                    public AnnotationReader ofTypeVariableBoundType(int index) {</b>
&nbsp;                        return new ForTypeVariableBoundType.OfFormalTypeVariable(this.typeVariable, index);
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(Object var1) {
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
<b class="fc">&nbsp;                            return false;</b>
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return this.typeVariable.equals(((ForLoadedTypeVariable)var1).typeVariable);
&nbsp;                        }
&nbsp;                    }
<b class="fc">&nbsp;</b>
&nbsp;                    public int hashCode() {
&nbsp;                        return this.getClass().hashCode() * 31 + this.typeVariable.hashCode();
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;                protected abstract static class Chained extends Delegator {
&nbsp;                    protected final AnnotationReader annotationReader;
&nbsp;
&nbsp;                    protected Chained(AnnotationReader annotationReader) {
&nbsp;                        this.annotationReader = annotationReader;
&nbsp;                    }
&nbsp;
&nbsp;                    public AnnotatedElement resolve() {
&nbsp;                        return this.resolve(this.annotationReader.resolve());
&nbsp;                    }
&nbsp;
&nbsp;                    protected abstract AnnotatedElement resolve(AnnotatedElement var1);
&nbsp;
&nbsp;                    public boolean equals(Object var1) {
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return this.annotationReader.equals(((Chained)var1).annotationReader);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return this.getClass().hashCode() * 31 + this.annotationReader.hashCode();
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;                public static class Simple extends Delegator {
&nbsp;                    private final AnnotatedElement annotatedElement;
&nbsp;
&nbsp;                    public Simple(AnnotatedElement annotatedElement) {
<b class="fc">&nbsp;                        this.annotatedElement = annotatedElement;</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                    public AnnotatedElement resolve() {</b>
<b class="fc">&nbsp;                        return this.annotatedElement;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(Object var1) {
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
<b class="fc">&nbsp;                            return false;</b>
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return this.annotatedElement.equals(((Simple)var1).annotatedElement);
&nbsp;                        }
&nbsp;                    }
&nbsp;
<b class="fc">&nbsp;                    public int hashCode() {</b>
&nbsp;                        return this.getClass().hashCode() * 31 + this.annotatedElement.hashCode();
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public static enum NoOp implements AnnotationReader, AnnotatedElement {
<b class="fc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                private NoOp() {
&nbsp;                }
&nbsp;
&nbsp;                public AnnotatedElement resolve() {
&nbsp;                    return this;
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                public AnnotationList asList() {
&nbsp;                    return new AnnotationList.Empty();
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationReader ofWildcardUpperBoundType(int index) {
&nbsp;                    return this;
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationReader ofWildcardLowerBoundType(int index) {
&nbsp;                    return this;
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationReader ofTypeVariableBoundType(int index) {
&nbsp;                    return this;
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationReader ofTypeArgument(int index) {
&nbsp;                    return this;
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationReader ofOwnerType() {
&nbsp;                    return this;
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationReader ofOuterClass() {
&nbsp;                    return this;
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationReader ofComponentType() {
&nbsp;                    return this;
&nbsp;                }
&nbsp;
&nbsp;                public boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) {
&nbsp;                    throw new IllegalStateException(&quot;Cannot resolve annotations for no-op reader: &quot; + this);
&nbsp;                }
&nbsp;
&nbsp;                public &lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass) {
&nbsp;                    throw new IllegalStateException(&quot;Cannot resolve annotations for no-op reader: &quot; + this);
&nbsp;                }
&nbsp;
&nbsp;                public Annotation[] getAnnotations() {
&nbsp;                    throw new IllegalStateException(&quot;Cannot resolve annotations for no-op reader: &quot; + this);
&nbsp;                }
&nbsp;
&nbsp;                public Annotation[] getDeclaredAnnotations() {
&nbsp;                    return new Annotation[0];
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public interface Visitor&lt;T&gt; {
&nbsp;            T onGenericArray(Generic var1);
&nbsp;
&nbsp;            T onWildcard(Generic var1);
&nbsp;
&nbsp;            T onParameterizedType(Generic var1);
&nbsp;
&nbsp;            T onTypeVariable(Generic var1);
&nbsp;
&nbsp;            T onNonGenericType(Generic var1);
&nbsp;
&nbsp;            @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;            public static class Reducing implements Visitor&lt;TypeDescription&gt; {
&nbsp;                private final TypeDescription declaringType;
&nbsp;                private final List&lt;? extends TypeVariableToken&gt; typeVariableTokens;
&nbsp;
&nbsp;                public Reducing(TypeDescription declaringType, TypeVariableToken... typeVariableToken) {
&nbsp;                    this(declaringType, Arrays.asList(typeVariableToken));
&nbsp;                }
&nbsp;
&nbsp;                public Reducing(TypeDescription declaringType, List&lt;? extends TypeVariableToken&gt; typeVariableTokens) {
&nbsp;                    this.declaringType = declaringType;
&nbsp;                    this.typeVariableTokens = typeVariableTokens;
&nbsp;                }
&nbsp;
&nbsp;                @SuppressFBWarnings(
&nbsp;                    value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;                    justification = &quot;Assuming component type for array type.&quot;
&nbsp;                )
&nbsp;                public TypeDescription onGenericArray(Generic genericArray) {
&nbsp;                    Generic targetType = genericArray;
&nbsp;                    int arity = 0;
&nbsp;
&nbsp;                    do {
&nbsp;                        targetType = targetType.getComponentType();
&nbsp;                        ++arity;
&nbsp;                    } while(targetType.isArray());
&nbsp;
&nbsp;                    if (targetType.getSort().isTypeVariable()) {
&nbsp;                        Iterator var4 = this.typeVariableTokens.iterator();
&nbsp;
&nbsp;                        TypeVariableToken typeVariableToken;
&nbsp;                        do {
&nbsp;                            if (!var4.hasNext()) {
&nbsp;                                return TargetType.resolve(TypeDescription.ArrayProjection.of(this.declaringType.findExpectedVariable(targetType.getSymbol()).asErasure(), arity), this.declaringType);
&nbsp;                            }
&nbsp;
&nbsp;                            typeVariableToken = (TypeVariableToken)var4.next();
&nbsp;                        } while(!targetType.getSymbol().equals(typeVariableToken.getSymbol()));
&nbsp;
&nbsp;                        return TypeDescription.ArrayProjection.of((TypeDescription)((Generic)typeVariableToken.getBounds().get(0)).accept(this), arity);
&nbsp;                    } else {
&nbsp;                        return TargetType.resolve(genericArray.asErasure(), this.declaringType);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public TypeDescription onWildcard(Generic wildcard) {
&nbsp;                    throw new IllegalStateException(&quot;A wildcard cannot be a top-level type: &quot; + wildcard);
&nbsp;                }
&nbsp;
&nbsp;                public TypeDescription onParameterizedType(Generic parameterizedType) {
&nbsp;                    return TargetType.resolve(parameterizedType.asErasure(), this.declaringType);
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                public TypeDescription onTypeVariable(Generic typeVariable) {</b>
&nbsp;                    Iterator var2 = this.typeVariableTokens.iterator();
&nbsp;
&nbsp;                    TypeVariableToken typeVariableToken;
&nbsp;                    do {
&nbsp;                        if (!var2.hasNext()) {
&nbsp;                            return TargetType.resolve(this.declaringType.findExpectedVariable(typeVariable.getSymbol()).asErasure(), this.declaringType);
&nbsp;                        }
&nbsp;
&nbsp;                        typeVariableToken = (TypeVariableToken)var2.next();
&nbsp;                    } while(!typeVariable.getSymbol().equals(typeVariableToken.getSymbol()));
&nbsp;
&nbsp;                    return (TypeDescription)((Generic)typeVariableToken.getBounds().get(0)).accept(this);
&nbsp;                }
&nbsp;
&nbsp;                public TypeDescription onNonGenericType(Generic typeDescription) {
&nbsp;                    return TargetType.resolve(typeDescription.asErasure(), this.declaringType);
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(Object var1) {
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.declaringType.equals(((Reducing)var1).declaringType)) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.typeVariableTokens.equals(((Reducing)var1).typeVariableTokens);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return (this.getClass().hashCode() * 31 + this.declaringType.hashCode()) * 31 + this.typeVariableTokens.hashCode();
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public static class ForRawType implements Visitor&lt;Generic&gt; {
&nbsp;                private final TypeDescription declaringType;
&nbsp;
&nbsp;                public ForRawType(TypeDescription declaringType) {
&nbsp;                    this.declaringType = declaringType;
&nbsp;                }
&nbsp;
&nbsp;                public Generic onGenericArray(Generic genericArray) {
&nbsp;                    return (Generic)(this.declaringType.isGenerified() ? new OfNonGenericType.Latent(genericArray.asErasure(), genericArray) : genericArray);
&nbsp;                }
&nbsp;
&nbsp;                public Generic onWildcard(Generic wildcard) {
&nbsp;                    throw new IllegalStateException(&quot;Did not expect wildcard on top-level: &quot; + wildcard);
&nbsp;                }
&nbsp;
&nbsp;                public Generic onParameterizedType(Generic parameterizedType) {
&nbsp;                    return (Generic)(this.declaringType.isGenerified() ? new OfNonGenericType.Latent(parameterizedType.asErasure(), parameterizedType) : parameterizedType);
&nbsp;                }
&nbsp;
&nbsp;                public Generic onTypeVariable(Generic typeVariable) {
&nbsp;                    return (Generic)(this.declaringType.isGenerified() ? new OfNonGenericType.Latent(typeVariable.asErasure(), typeVariable) : typeVariable);
&nbsp;                }
&nbsp;
&nbsp;                public Generic onNonGenericType(Generic typeDescription) {
&nbsp;                    return typeDescription;
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public abstract static class Substitutor implements Visitor&lt;Generic&gt; {
&nbsp;                public Substitutor() {
&nbsp;                }
&nbsp;
&nbsp;                public Generic onParameterizedType(Generic parameterizedType) {
&nbsp;                    Generic ownerType = parameterizedType.getOwnerType();
&nbsp;                    List&lt;Generic&gt; typeArguments = new ArrayList(parameterizedType.getTypeArguments().size());
&nbsp;                    Iterator var4 = parameterizedType.getTypeArguments().iterator();
&nbsp;
&nbsp;                    while(var4.hasNext()) {
&nbsp;                        Generic typeArgument = (Generic)var4.next();
&nbsp;                        typeArguments.add(typeArgument.accept(this));
&nbsp;                    }
&nbsp;
&nbsp;                    return new OfParameterizedType.Latent(((Generic)parameterizedType.asRawType().accept(this)).asErasure(), ownerType == null ? TypeDescription.Generic.UNDEFINED : (Generic)ownerType.accept(this), typeArguments, parameterizedType);
&nbsp;                }
&nbsp;
&nbsp;                @SuppressFBWarnings(
&nbsp;                    value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;                    justification = &quot;Assuming component type for array type.&quot;
&nbsp;                )
&nbsp;                public Generic onGenericArray(Generic genericArray) {
&nbsp;                    return new OfGenericArray.Latent((Generic)genericArray.getComponentType().accept(this), genericArray);
&nbsp;                }
&nbsp;
&nbsp;                public Generic onWildcard(Generic wildcard) {
&nbsp;                    return new OfWildcardType.Latent(wildcard.getUpperBounds().accept(this), wildcard.getLowerBounds().accept(this), wildcard);
&nbsp;                }
&nbsp;
&nbsp;                @SuppressFBWarnings(
&nbsp;                    value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;                    justification = &quot;Assuming component type for array type.&quot;
&nbsp;                )
&nbsp;                public Generic onNonGenericType(Generic typeDescription) {
&nbsp;                    return (Generic)(typeDescription.isArray() ? new OfGenericArray.Latent((Generic)typeDescription.getComponentType().accept(this), typeDescription) : this.onSimpleType(typeDescription));
&nbsp;                }
&nbsp;
&nbsp;                protected abstract Generic onSimpleType(Generic var1);
&nbsp;
&nbsp;                @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;                public static class ForReplacement extends Substitutor {
&nbsp;                    private final TypeDescription typeDescription;
&nbsp;
&nbsp;                    public ForReplacement(TypeDescription typeDescription) {
&nbsp;                        this.typeDescription = typeDescription;
&nbsp;                    }
&nbsp;
&nbsp;                    public Generic onTypeVariable(Generic typeVariable) {
&nbsp;                        return typeVariable;
&nbsp;                    }
&nbsp;
&nbsp;                    protected Generic onSimpleType(Generic typeDescription) {
&nbsp;                        return (Generic)(typeDescription.asErasure().equals(this.typeDescription) ? new OfNonGenericType.Latent(this.typeDescription, typeDescription) : typeDescription);
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(Object var1) {
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return this.typeDescription.equals(((ForReplacement)var1).typeDescription);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return this.getClass().hashCode() * 31 + this.typeDescription.hashCode();
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;                public static class ForTokenNormalization extends Substitutor {
&nbsp;                    private final TypeDescription typeDescription;
&nbsp;
&nbsp;                    public ForTokenNormalization(TypeDescription typeDescription) {
&nbsp;                        this.typeDescription = typeDescription;
&nbsp;                    }
&nbsp;
&nbsp;                    protected Generic onSimpleType(Generic typeDescription) {
&nbsp;                        return (Generic)(typeDescription.represents(TargetType.class) ? new OfNonGenericType.Latent(this.typeDescription, typeDescription) : typeDescription);
&nbsp;                    }
&nbsp;
&nbsp;                    public Generic onTypeVariable(Generic typeVariable) {
&nbsp;                        return new OfTypeVariable.Symbolic(typeVariable.getSymbol(), typeVariable);
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(Object var1) {
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return this.typeDescription.equals(((ForTokenNormalization)var1).typeDescription);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return this.getClass().hashCode() * 31 + this.typeDescription.hashCode();
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;                public static class ForTypeVariableBinding extends WithoutTypeSubstitution {
&nbsp;                    private final Generic parameterizedType;
&nbsp;
&nbsp;                    protected ForTypeVariableBinding(Generic parameterizedType) {
&nbsp;                        this.parameterizedType = parameterizedType;
&nbsp;                    }
&nbsp;
&nbsp;                    public Generic onTypeVariable(Generic typeVariable) {
&nbsp;                        return (Generic)typeVariable.getTypeVariableSource().accept(new TypeVariableSubstitutor(typeVariable));
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(Object var1) {
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return this.parameterizedType.equals(((ForTypeVariableBinding)var1).parameterizedType);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return this.getClass().hashCode() * 31 + this.parameterizedType.hashCode();
&nbsp;                    }
&nbsp;
&nbsp;                    protected class RetainedMethodTypeVariable extends OfTypeVariable {
&nbsp;                        private final Generic typeVariable;
&nbsp;
&nbsp;                        protected RetainedMethodTypeVariable(Generic typeVariable) {
&nbsp;                            this.typeVariable = typeVariable;
&nbsp;                        }
&nbsp;
&nbsp;                        public TypeList.Generic getUpperBounds() {
&nbsp;                            return this.typeVariable.getUpperBounds().accept(ForTypeVariableBinding.this);
&nbsp;                        }
&nbsp;
&nbsp;                        public TypeVariableSource getTypeVariableSource() {
&nbsp;                            return this.typeVariable.getTypeVariableSource();
&nbsp;                        }
&nbsp;
&nbsp;                        public String getSymbol() {
&nbsp;                            return this.typeVariable.getSymbol();
&nbsp;                        }
&nbsp;
&nbsp;                        public AnnotationList getDeclaredAnnotations() {
&nbsp;                            return this.typeVariable.getDeclaredAnnotations();
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance(
&nbsp;                        includeSyntheticFields = true
&nbsp;                    )
&nbsp;                    protected class TypeVariableSubstitutor implements TypeVariableSource.Visitor&lt;Generic&gt; {
&nbsp;                        private final Generic typeVariable;
&nbsp;
&nbsp;                        protected TypeVariableSubstitutor(Generic typeVariable) {
&nbsp;                            this.typeVariable = typeVariable;
&nbsp;                        }
&nbsp;
&nbsp;                        public Generic onType(TypeDescription typeDescription) {
&nbsp;                            Generic typeArgument = ForTypeVariableBinding.this.parameterizedType.findBindingOf(this.typeVariable);
&nbsp;                            return typeArgument == null ? this.typeVariable.asRawType() : typeArgument;
&nbsp;                        }
&nbsp;
&nbsp;                        public Generic onMethod(MethodDescription.InDefinedShape methodDescription) {
&nbsp;                            return ForTypeVariableBinding.this.new RetainedMethodTypeVariable(this.typeVariable);
&nbsp;                        }
&nbsp;
&nbsp;                        public boolean equals(Object var1) {
&nbsp;                            if (this == var1) {
&nbsp;                                return true;
&nbsp;                            } else if (var1 == null) {
&nbsp;                                return false;
&nbsp;                            } else if (this.getClass() != var1.getClass()) {
&nbsp;                                return false;
&nbsp;                            } else if (!this.typeVariable.equals(((TypeVariableSubstitutor)var1).typeVariable)) {
&nbsp;                                return false;
&nbsp;                            } else {
&nbsp;                                return ForTypeVariableBinding.this.equals(ForTypeVariableBinding.this);
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        public int hashCode() {
&nbsp;                            return (this.getClass().hashCode() * 31 + this.typeVariable.hashCode()) * 31 + ForTypeVariableBinding.this.hashCode();
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;                public static class ForDetachment extends Substitutor {
&nbsp;                    private final ElementMatcher&lt;? super TypeDescription&gt; typeMatcher;
&nbsp;
&nbsp;                    public ForDetachment(ElementMatcher&lt;? super TypeDescription&gt; typeMatcher) {
&nbsp;                        this.typeMatcher = typeMatcher;
&nbsp;                    }
&nbsp;
&nbsp;                    public static Visitor&lt;Generic&gt; of(TypeDefinition typeDefinition) {
&nbsp;                        return new ForDetachment(ElementMatchers.is(typeDefinition));
&nbsp;                    }
&nbsp;
&nbsp;                    public Generic onTypeVariable(Generic typeVariable) {
&nbsp;                        return new OfTypeVariable.Symbolic(typeVariable.getSymbol(), typeVariable);
&nbsp;                    }
&nbsp;
&nbsp;                    protected Generic onSimpleType(Generic typeDescription) {
&nbsp;                        return (Generic)(this.typeMatcher.matches(typeDescription.asErasure()) ? new OfNonGenericType.Latent(TargetType.DESCRIPTION, typeDescription.getOwnerType(), typeDescription) : typeDescription);
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(Object var1) {
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return this.typeMatcher.equals(((ForDetachment)var1).typeMatcher);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return this.getClass().hashCode() * 31 + this.typeMatcher.hashCode();
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;                public static class ForAttachment extends Substitutor {
&nbsp;                    private final TypeDescription declaringType;
&nbsp;                    private final TypeVariableSource typeVariableSource;
&nbsp;
&nbsp;                    protected ForAttachment(TypeDefinition declaringType, TypeVariableSource typeVariableSource) {
&nbsp;                        this(declaringType.asErasure(), typeVariableSource);
&nbsp;                    }
&nbsp;
&nbsp;                    protected ForAttachment(TypeDescription declaringType, TypeVariableSource typeVariableSource) {
&nbsp;                        this.declaringType = declaringType;
&nbsp;                        this.typeVariableSource = typeVariableSource;
&nbsp;                    }
&nbsp;
&nbsp;                    public static ForAttachment of(TypeDescription typeDescription) {
&nbsp;                        return new ForAttachment(typeDescription, typeDescription);
&nbsp;                    }
&nbsp;
&nbsp;                    @SuppressFBWarnings(
&nbsp;                        value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;                        justification = &quot;Assuming declaring type for type member.&quot;
&nbsp;                    )
&nbsp;                    public static ForAttachment of(FieldDescription fieldDescription) {
&nbsp;                        return new ForAttachment(fieldDescription.getDeclaringType(), fieldDescription.getDeclaringType().asErasure());
&nbsp;                    }
&nbsp;
&nbsp;                    public static ForAttachment of(MethodDescription methodDescription) {
&nbsp;                        return new ForAttachment(methodDescription.getDeclaringType(), methodDescription);
&nbsp;                    }
&nbsp;
&nbsp;                    public static ForAttachment of(ParameterDescription parameterDescription) {
&nbsp;                        return new ForAttachment(parameterDescription.getDeclaringMethod().getDeclaringType(), parameterDescription.getDeclaringMethod());
&nbsp;                    }
&nbsp;
&nbsp;                    public static ForAttachment of(RecordComponentDescription recordComponentDescription) {
&nbsp;                        return new ForAttachment(recordComponentDescription.getDeclaringType(), recordComponentDescription.getDeclaringType().asErasure());
&nbsp;                    }
&nbsp;
&nbsp;                    public Generic onTypeVariable(Generic typeVariable) {
&nbsp;                        return new OfTypeVariable.WithAnnotationOverlay(this.typeVariableSource.findExpectedVariable(typeVariable.getSymbol()), typeVariable);
&nbsp;                    }
&nbsp;
&nbsp;                    protected Generic onSimpleType(Generic typeDescription) {
&nbsp;                        return (Generic)(typeDescription.represents(TargetType.class) ? new OfNonGenericType.Latent(this.declaringType, typeDescription) : typeDescription);
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(Object var1) {
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else if (!this.declaringType.equals(((ForAttachment)var1).declaringType)) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return this.typeVariableSource.equals(((ForAttachment)var1).typeVariableSource);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return (this.getClass().hashCode() * 31 + this.declaringType.hashCode()) * 31 + this.typeVariableSource.hashCode();
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public abstract static class WithoutTypeSubstitution extends Substitutor {
&nbsp;                    public WithoutTypeSubstitution() {
&nbsp;                    }
&nbsp;
&nbsp;                    public Generic onNonGenericType(Generic typeDescription) {
&nbsp;                        return typeDescription;
&nbsp;                    }
&nbsp;
&nbsp;                    protected Generic onSimpleType(Generic typeDescription) {
&nbsp;                        return typeDescription;
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;            public static class ForSignatureVisitor implements Visitor&lt;SignatureVisitor&gt; {
&nbsp;                private static final int ONLY_CHARACTER = 0;
&nbsp;                protected final SignatureVisitor signatureVisitor;
&nbsp;
&nbsp;                public ForSignatureVisitor(SignatureVisitor signatureVisitor) {
&nbsp;                    this.signatureVisitor = signatureVisitor;
&nbsp;                }
&nbsp;
&nbsp;                @SuppressFBWarnings(
&nbsp;                    value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;                    justification = &quot;Assuming component type for array type.&quot;
&nbsp;                )
&nbsp;                public SignatureVisitor onGenericArray(Generic genericArray) {
&nbsp;                    genericArray.getComponentType().accept(new ForSignatureVisitor(this.signatureVisitor.visitArrayType()));
&nbsp;                    return this.signatureVisitor;
&nbsp;                }
&nbsp;
&nbsp;                public SignatureVisitor onWildcard(Generic wildcard) {
&nbsp;                    throw new IllegalStateException(&quot;Unexpected wildcard: &quot; + wildcard);
&nbsp;                }
&nbsp;
&nbsp;                public SignatureVisitor onParameterizedType(Generic parameterizedType) {
&nbsp;                    this.onOwnableType(parameterizedType);
&nbsp;                    this.signatureVisitor.visitEnd();
&nbsp;                    return this.signatureVisitor;
&nbsp;                }
&nbsp;
&nbsp;                private void onOwnableType(Generic ownableType) {
&nbsp;                    Generic ownerType = ownableType.getOwnerType();
&nbsp;                    if (ownerType != null &amp;&amp; ownerType.getSort().isParameterized()) {
&nbsp;                        this.onOwnableType(ownerType);
&nbsp;                        this.signatureVisitor.visitInnerClassType(ownableType.asErasure().getSimpleName());
&nbsp;                    } else {
&nbsp;                        this.signatureVisitor.visitClassType(ownableType.asErasure().getInternalName());
&nbsp;                    }
&nbsp;
&nbsp;                    Iterator var3 = ownableType.getTypeArguments().iterator();
&nbsp;
&nbsp;                    while(var3.hasNext()) {
&nbsp;                        Generic typeArgument = (Generic)var3.next();
&nbsp;                        typeArgument.accept(new OfTypeArgument(this.signatureVisitor));
&nbsp;                    }
&nbsp;
&nbsp;                }
&nbsp;
&nbsp;                public SignatureVisitor onTypeVariable(Generic typeVariable) {
&nbsp;                    this.signatureVisitor.visitTypeVariable(typeVariable.getSymbol());
&nbsp;                    return this.signatureVisitor;
&nbsp;                }
&nbsp;
&nbsp;                @SuppressFBWarnings(
&nbsp;                    value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;                    justification = &quot;Assuming component type for array type.&quot;
&nbsp;                )
&nbsp;                public SignatureVisitor onNonGenericType(Generic typeDescription) {
&nbsp;                    if (typeDescription.isArray()) {
&nbsp;                        typeDescription.getComponentType().accept(new ForSignatureVisitor(this.signatureVisitor.visitArrayType()));
&nbsp;                    } else if (typeDescription.isPrimitive()) {
&nbsp;                        this.signatureVisitor.visitBaseType(typeDescription.asErasure().getDescriptor().charAt(0));
&nbsp;                    } else {
&nbsp;                        this.signatureVisitor.visitClassType(typeDescription.asErasure().getInternalName());
&nbsp;                        this.signatureVisitor.visitEnd();
&nbsp;                    }
&nbsp;
&nbsp;                    return this.signatureVisitor;
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(Object var1) {
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.signatureVisitor.equals(((ForSignatureVisitor)var1).signatureVisitor);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return this.getClass().hashCode() * 31 + this.signatureVisitor.hashCode();
&nbsp;                }
&nbsp;
&nbsp;                protected static class OfTypeArgument extends ForSignatureVisitor {
&nbsp;                    protected OfTypeArgument(SignatureVisitor signatureVisitor) {
&nbsp;                        super(signatureVisitor);
&nbsp;                    }
&nbsp;
&nbsp;                    public SignatureVisitor onWildcard(Generic wildcard) {
&nbsp;                        TypeList.Generic upperBounds = wildcard.getUpperBounds();
&nbsp;                        TypeList.Generic lowerBounds = wildcard.getLowerBounds();
&nbsp;                        if (lowerBounds.isEmpty() &amp;&amp; ((Generic)upperBounds.getOnly()).represents(Object.class)) {
&nbsp;                            this.signatureVisitor.visitTypeArgument();
&nbsp;                        } else if (!lowerBounds.isEmpty()) {
&nbsp;                            ((Generic)lowerBounds.getOnly()).accept(new ForSignatureVisitor(this.signatureVisitor.visitTypeArgument(&#39;-&#39;)));
&nbsp;                        } else {
&nbsp;                            ((Generic)upperBounds.getOnly()).accept(new ForSignatureVisitor(this.signatureVisitor.visitTypeArgument(&#39;+&#39;)));
&nbsp;                        }
&nbsp;
&nbsp;                        return this.signatureVisitor;
&nbsp;                    }
&nbsp;
&nbsp;                    public SignatureVisitor onGenericArray(Generic genericArray) {
&nbsp;                        genericArray.accept(new ForSignatureVisitor(this.signatureVisitor.visitTypeArgument(&#39;=&#39;)));
&nbsp;                        return this.signatureVisitor;
&nbsp;                    }
&nbsp;
&nbsp;                    public SignatureVisitor onParameterizedType(Generic parameterizedType) {
&nbsp;                        parameterizedType.accept(new ForSignatureVisitor(this.signatureVisitor.visitTypeArgument(&#39;=&#39;)));
&nbsp;                        return this.signatureVisitor;
&nbsp;                    }
&nbsp;
&nbsp;                    public SignatureVisitor onTypeVariable(Generic typeVariable) {
&nbsp;                        typeVariable.accept(new ForSignatureVisitor(this.signatureVisitor.visitTypeArgument(&#39;=&#39;)));
&nbsp;                        return this.signatureVisitor;
&nbsp;                    }
&nbsp;
&nbsp;                    public SignatureVisitor onNonGenericType(Generic typeDescription) {
&nbsp;                        typeDescription.accept(new ForSignatureVisitor(this.signatureVisitor.visitTypeArgument(&#39;=&#39;)));
&nbsp;                        return this.signatureVisitor;
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public static enum Reifying implements Visitor&lt;Generic&gt; {
&nbsp;                INITIATING {
&nbsp;                    public Generic onParameterizedType(Generic parameterizedType) {
&nbsp;                        return parameterizedType;
&nbsp;                    }
&nbsp;                },
&nbsp;                INHERITING {
&nbsp;                    public Generic onParameterizedType(Generic parameterizedType) {
&nbsp;                        return new OfParameterizedType.ForReifiedType(parameterizedType);
&nbsp;                    }
&nbsp;                };
&nbsp;
&nbsp;                private Reifying() {
&nbsp;                }
&nbsp;
&nbsp;                public Generic onGenericArray(Generic genericArray) {
&nbsp;                    throw new IllegalArgumentException(&quot;Cannot reify a generic array: &quot; + genericArray);
&nbsp;                }
&nbsp;
&nbsp;                public Generic onWildcard(Generic wildcard) {
&nbsp;                    throw new IllegalArgumentException(&quot;Cannot reify a wildcard: &quot; + wildcard);
&nbsp;                }
&nbsp;
&nbsp;                public Generic onTypeVariable(Generic typeVariable) {
&nbsp;                    throw new IllegalArgumentException(&quot;Cannot reify a type variable: &quot; + typeVariable);
&nbsp;                }
&nbsp;
&nbsp;                public Generic onNonGenericType(Generic typeDescription) {
&nbsp;                    TypeDescription erasure = typeDescription.asErasure();
&nbsp;                    return (Generic)(erasure.isGenerified() ? new OfNonGenericType.ForReifiedErasure(erasure) : typeDescription);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public static enum Validator implements Visitor&lt;Boolean&gt; {
&nbsp;                SUPER_CLASS(false, false, false, false) {
&nbsp;                    public Boolean onNonGenericType(Generic typeDescription) {
&nbsp;                        return super.onNonGenericType(typeDescription) &amp;&amp; !typeDescription.isInterface();
&nbsp;                    }
&nbsp;
&nbsp;                    public Boolean onParameterizedType(Generic parameterizedType) {
&nbsp;                        return !parameterizedType.isInterface();
&nbsp;                    }
&nbsp;                },
&nbsp;                INTERFACE(false, false, false, false) {
&nbsp;                    public Boolean onNonGenericType(Generic typeDescription) {
&nbsp;                        return super.onNonGenericType(typeDescription) &amp;&amp; typeDescription.isInterface();
&nbsp;                    }
&nbsp;
&nbsp;                    public Boolean onParameterizedType(Generic parameterizedType) {
&nbsp;                        return parameterizedType.isInterface();
&nbsp;                    }
&nbsp;                },
&nbsp;                TYPE_VARIABLE(false, false, true, false),
&nbsp;                FIELD(true, true, true, false),
&nbsp;                METHOD_RETURN(true, true, true, true),
&nbsp;                METHOD_PARAMETER(true, true, true, false),
&nbsp;                EXCEPTION(false, false, true, false) {
&nbsp;                    public Boolean onParameterizedType(Generic parameterizedType) {
&nbsp;                        return false;
&nbsp;                    }
&nbsp;
&nbsp;                    public Boolean onTypeVariable(Generic typeVariable) {
&nbsp;                        Iterator var2 = typeVariable.getUpperBounds().iterator();
&nbsp;
&nbsp;                        Generic bound;
&nbsp;                        do {
&nbsp;                            if (!var2.hasNext()) {
&nbsp;                                return false;
&nbsp;                            }
&nbsp;
&nbsp;                            bound = (Generic)var2.next();
&nbsp;                        } while(!(Boolean)bound.accept(this));
&nbsp;
&nbsp;                        return true;
&nbsp;                    }
&nbsp;
&nbsp;                    public Boolean onNonGenericType(Generic typeDescription) {
&nbsp;                        return typeDescription.asErasure().isAssignableTo(Throwable.class);
&nbsp;                    }
&nbsp;                },
&nbsp;                RECEIVER(false, false, false, false);
&nbsp;
&nbsp;                private final boolean acceptsArray;
&nbsp;                private final boolean acceptsPrimitive;
&nbsp;                private final boolean acceptsVariable;
&nbsp;                private final boolean acceptsVoid;
&nbsp;
&nbsp;                private Validator(boolean acceptsArray, boolean acceptsPrimitive, boolean acceptsVariable, boolean acceptsVoid) {
&nbsp;                    this.acceptsArray = acceptsArray;
&nbsp;                    this.acceptsPrimitive = acceptsPrimitive;
&nbsp;                    this.acceptsVariable = acceptsVariable;
&nbsp;                    this.acceptsVoid = acceptsVoid;
&nbsp;                }
&nbsp;
&nbsp;                public Boolean onGenericArray(Generic genericArray) {
&nbsp;                    return this.acceptsArray;
&nbsp;                }
&nbsp;
&nbsp;                public Boolean onWildcard(Generic wildcard) {
&nbsp;                    return false;
&nbsp;                }
&nbsp;
&nbsp;                public Boolean onParameterizedType(Generic parameterizedType) {
&nbsp;                    return true;
&nbsp;                }
&nbsp;
&nbsp;                public Boolean onTypeVariable(Generic typeVariable) {
&nbsp;                    return this.acceptsVariable;
&nbsp;                }
&nbsp;
&nbsp;                public Boolean onNonGenericType(Generic typeDescription) {
&nbsp;                    return (this.acceptsArray || !typeDescription.isArray()) &amp;&amp; (this.acceptsPrimitive || !typeDescription.isPrimitive()) &amp;&amp; (this.acceptsVoid || !typeDescription.represents(Void.TYPE));
&nbsp;                }
&nbsp;
&nbsp;                public static enum ForTypeAnnotations implements Visitor&lt;Boolean&gt; {
&nbsp;                    INSTANCE;
&nbsp;
&nbsp;                    @Nonnull(
&nbsp;                        when = When.MAYBE
&nbsp;                    )
&nbsp;                    private final ElementType typeUse;
&nbsp;                    @Nonnull(
&nbsp;                        when = When.MAYBE
&nbsp;                    )
&nbsp;                    private final ElementType typeParameter;
<b class="fc">&nbsp;</b>
&nbsp;                    private ForTypeAnnotations() {
&nbsp;                        ElementType typeUse;
&nbsp;                        ElementType typeParameter;
&nbsp;                        try {
&nbsp;                            typeUse = (ElementType)Enum.valueOf(ElementType.class, &quot;TYPE_USE&quot;);
&nbsp;                            typeParameter = (ElementType)Enum.valueOf(ElementType.class, &quot;TYPE_PARAMETER&quot;);
&nbsp;                        } catch (IllegalArgumentException var6) {
&nbsp;                            typeUse = null;
&nbsp;                            typeParameter = null;
&nbsp;                        }
&nbsp;
&nbsp;                        this.typeUse = typeUse;
<b class="fc">&nbsp;                        this.typeParameter = typeParameter;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    public static boolean ofFormalTypeVariable(Generic typeVariable) {
&nbsp;                        Set&lt;TypeDescription&gt; annotationTypes = new HashSet();
&nbsp;                        Iterator var2 = typeVariable.getDeclaredAnnotations().iterator();
&nbsp;
&nbsp;                        AnnotationDescription annotationDescription;
&nbsp;                        do {
&nbsp;                            if (!var2.hasNext()) {
&nbsp;                                return true;
&nbsp;                            }
&nbsp;
&nbsp;                            annotationDescription = (AnnotationDescription)var2.next();
<b class="fc">&nbsp;                        } while(annotationDescription.getElementTypes().contains(INSTANCE.typeParameter) &amp;&amp; annotationTypes.add(annotationDescription.getAnnotationType()));</b>
&nbsp;
&nbsp;                        return false;
&nbsp;                    }
&nbsp;
&nbsp;                    @SuppressFBWarnings(
&nbsp;                        value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;                        justification = &quot;Assuming component type for array type.&quot;
&nbsp;                    )
&nbsp;                    public Boolean onGenericArray(Generic genericArray) {
&nbsp;                        return this.isValid(genericArray) &amp;&amp; (Boolean)genericArray.getComponentType().accept(this);
&nbsp;                    }
&nbsp;
&nbsp;                    public Boolean onWildcard(Generic wildcard) {
&nbsp;                        if (!this.isValid(wildcard)) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            TypeList.Generic lowerBounds = wildcard.getLowerBounds();
&nbsp;                            return (Boolean)((Generic)(lowerBounds.isEmpty() ? wildcard.getUpperBounds() : lowerBounds).getOnly()).accept(this);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public Boolean onParameterizedType(Generic parameterizedType) {
&nbsp;                        if (!this.isValid(parameterizedType)) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            Generic ownerType = parameterizedType.getOwnerType();
&nbsp;                            if (ownerType != null &amp;&amp; !(Boolean)ownerType.accept(this)) {
&nbsp;                                return false;
<b class="fc">&nbsp;                            } else {</b>
&nbsp;                                Iterator var3 = parameterizedType.getTypeArguments().iterator();
&nbsp;
&nbsp;                                Generic typeArgument;
&nbsp;                                do {
&nbsp;                                    if (!var3.hasNext()) {
&nbsp;                                        return true;
&nbsp;                                    }
&nbsp;
&nbsp;                                    typeArgument = (Generic)var3.next();
&nbsp;                                } while((Boolean)typeArgument.accept(this));
&nbsp;
&nbsp;                                return false;
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public Boolean onTypeVariable(Generic typeVariable) {
&nbsp;                        return this.isValid(typeVariable);
&nbsp;                    }
&nbsp;
&nbsp;                    @SuppressFBWarnings(
&nbsp;                        value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;                        justification = &quot;Assuming component type for array type.&quot;
&nbsp;                    )
&nbsp;                    public Boolean onNonGenericType(Generic typeDescription) {
&nbsp;                        return this.isValid(typeDescription) &amp;&amp; (!typeDescription.isArray() || (Boolean)typeDescription.getComponentType().accept(this));
&nbsp;                    }
&nbsp;
&nbsp;                    private boolean isValid(Generic typeDescription) {
&nbsp;                        Set&lt;TypeDescription&gt; annotationTypes = new HashSet();
&nbsp;                        Iterator var3 = typeDescription.getDeclaredAnnotations().iterator();
&nbsp;
&nbsp;                        AnnotationDescription annotationDescription;
&nbsp;                        do {
&nbsp;                            if (!var3.hasNext()) {
&nbsp;                                return true;
&nbsp;                            }
&nbsp;
&nbsp;                            annotationDescription = (AnnotationDescription)var3.next();
&nbsp;                        } while(annotationDescription.getElementTypes().contains(this.typeUse) &amp;&amp; annotationTypes.add(annotationDescription.getAnnotationType()));
&nbsp;
&nbsp;                        return false;
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public static enum Assigner implements Visitor&lt;Dispatcher&gt; {
&nbsp;                INSTANCE;
&nbsp;
&nbsp;                private Assigner() {
&nbsp;                }
&nbsp;
&nbsp;                public Dispatcher onGenericArray(Generic genericArray) {
&nbsp;                    return new Dispatcher.ForGenericArray(genericArray);
&nbsp;                }
&nbsp;
&nbsp;                public Dispatcher onWildcard(Generic wildcard) {
<b class="fc">&nbsp;                    throw new IllegalArgumentException(&quot;A wildcard is not a first level type: &quot; + this);</b>
&nbsp;                }
&nbsp;
&nbsp;                public Dispatcher onParameterizedType(Generic parameterizedType) {
&nbsp;                    return new Dispatcher.ForParameterizedType(parameterizedType);
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                public Dispatcher onTypeVariable(Generic typeVariable) {</b>
&nbsp;                    return new Dispatcher.ForTypeVariable(typeVariable);
&nbsp;                }
&nbsp;
&nbsp;                public Dispatcher onNonGenericType(Generic typeDescription) {
&nbsp;                    return new Dispatcher.ForNonGenericType(typeDescription.asErasure());
&nbsp;                }
<b class="fc">&nbsp;</b>
&nbsp;                public interface Dispatcher {
&nbsp;                    boolean isAssignableFrom(Generic var1);
&nbsp;
&nbsp;                    @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;                    public static class ForGenericArray extends AbstractBase {
&nbsp;                        private final Generic genericArray;
<b class="fc">&nbsp;</b>
&nbsp;                        protected ForGenericArray(Generic genericArray) {
&nbsp;                            this.genericArray = genericArray;
&nbsp;                        }
&nbsp;
&nbsp;                        @SuppressFBWarnings(
&nbsp;                            value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;                            justification = &quot;Assuming component type for array type.&quot;
&nbsp;                        )
&nbsp;                        public Boolean onGenericArray(Generic genericArray) {
&nbsp;                            return ((Dispatcher)this.genericArray.getComponentType().accept(TypeDescription.Generic.Visitor.Assigner.INSTANCE)).isAssignableFrom(genericArray.getComponentType());
&nbsp;                        }
&nbsp;
&nbsp;                        public Boolean onWildcard(Generic wildcard) {
<b class="fc">&nbsp;                            throw new IllegalArgumentException(&quot;A wildcard is not a first-level type: &quot; + wildcard);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        public Boolean onParameterizedType(Generic parameterizedType) {
&nbsp;                            return false;
&nbsp;                        }
<b class="fc">&nbsp;</b>
&nbsp;                        public Boolean onTypeVariable(Generic typeVariable) {
&nbsp;                            return false;
&nbsp;                        }
&nbsp;
<b class="fc">&nbsp;                        @SuppressFBWarnings(</b>
&nbsp;                            value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;                            justification = &quot;Assuming component type for array type.&quot;
&nbsp;                        )
&nbsp;                        public Boolean onNonGenericType(Generic typeDescription) {
&nbsp;                            return typeDescription.isArray() &amp;&amp; ((Dispatcher)this.genericArray.getComponentType().accept(TypeDescription.Generic.Visitor.Assigner.INSTANCE)).isAssignableFrom(typeDescription.getComponentType());
&nbsp;                        }
&nbsp;
&nbsp;                        public boolean equals(Object var1) {
&nbsp;                            if (this == var1) {
&nbsp;                                return true;
&nbsp;                            } else if (var1 == null) {
&nbsp;                                return false;
&nbsp;                            } else if (this.getClass() != var1.getClass()) {
&nbsp;                                return false;
&nbsp;                            } else {
&nbsp;                                return this.genericArray.equals(((ForGenericArray)var1).genericArray);
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        public int hashCode() {
&nbsp;                            return this.getClass().hashCode() * 31 + this.genericArray.hashCode();
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;                    public static class ForParameterizedType extends AbstractBase {
&nbsp;                        private final Generic parameterizedType;
&nbsp;
&nbsp;                        protected ForParameterizedType(Generic parameterizedType) {
&nbsp;                            this.parameterizedType = parameterizedType;
&nbsp;                        }
&nbsp;
&nbsp;                        public Boolean onGenericArray(Generic genericArray) {
&nbsp;                            return false;
&nbsp;                        }
&nbsp;
&nbsp;                        public Boolean onWildcard(Generic wildcard) {
&nbsp;                            throw new IllegalArgumentException(&quot;A wildcard is not a first-level type: &quot; + wildcard);
&nbsp;                        }
&nbsp;
&nbsp;                        public Boolean onParameterizedType(Generic parameterizedType) {
&nbsp;                            Generic superClass;
&nbsp;                            if (this.parameterizedType.asErasure().equals(parameterizedType.asErasure())) {
&nbsp;                                superClass = this.parameterizedType.getOwnerType();
&nbsp;                                Generic toOwner = parameterizedType.getOwnerType();
&nbsp;                                if (superClass != null &amp;&amp; toOwner != null &amp;&amp; !((Dispatcher)superClass.accept(TypeDescription.Generic.Visitor.Assigner.INSTANCE)).isAssignableFrom(toOwner)) {
&nbsp;                                    return false;
&nbsp;                                } else {
&nbsp;                                    TypeList.Generic fromArguments = this.parameterizedType.getTypeArguments();
&nbsp;                                    TypeList.Generic toArguments = parameterizedType.getTypeArguments();
&nbsp;                                    if (fromArguments.size() == toArguments.size()) {
&nbsp;                                        for(int index = 0; index &lt; fromArguments.size(); ++index) {
&nbsp;                                            if (!((Dispatcher)((Generic)fromArguments.get(index)).accept(TypeDescription.Generic.Visitor.Assigner.Dispatcher.ForParameterizedType.ParameterAssigner.INSTANCE)).isAssignableFrom((Generic)toArguments.get(index))) {
&nbsp;                                                return false;
&nbsp;                                            }
&nbsp;                                        }
&nbsp;
&nbsp;                                        return true;
&nbsp;                                    } else {
&nbsp;                                        throw new IllegalArgumentException(&quot;Incompatible generic types: &quot; + parameterizedType + &quot; and &quot; + this.parameterizedType);
&nbsp;                                    }
&nbsp;                                }
&nbsp;                            } else {
&nbsp;                                superClass = parameterizedType.getSuperClass();
&nbsp;                                if (superClass != null &amp;&amp; this.isAssignableFrom(superClass)) {
&nbsp;                                    return true;
&nbsp;                                } else {
&nbsp;                                    Iterator var3 = parameterizedType.getInterfaces().iterator();
&nbsp;
&nbsp;                                    Generic interfaceType;
&nbsp;                                    do {
&nbsp;                                        if (!var3.hasNext()) {
&nbsp;                                            return false;
&nbsp;                                        }
&nbsp;
&nbsp;                                        interfaceType = (Generic)var3.next();
&nbsp;                                    } while(!this.isAssignableFrom(interfaceType));
&nbsp;
&nbsp;                                    return true;
&nbsp;                                }
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        public Boolean onTypeVariable(Generic typeVariable) {
&nbsp;                            Iterator var2 = typeVariable.getUpperBounds().iterator();
&nbsp;
&nbsp;                            Generic upperBound;
&nbsp;                            do {
&nbsp;                                if (!var2.hasNext()) {
&nbsp;                                    return false;
&nbsp;                                }
&nbsp;
&nbsp;                                upperBound = (Generic)var2.next();
&nbsp;                            } while(!this.isAssignableFrom(upperBound));
&nbsp;
&nbsp;                            return true;
&nbsp;                        }
&nbsp;
&nbsp;                        public Boolean onNonGenericType(Generic typeDescription) {
&nbsp;                            if (this.parameterizedType.asErasure().equals(typeDescription.asErasure())) {
&nbsp;                                return true;
&nbsp;                            } else {
&nbsp;                                Generic superClass = typeDescription.getSuperClass();
&nbsp;                                if (superClass != null &amp;&amp; this.isAssignableFrom(superClass)) {
&nbsp;                                    return true;
&nbsp;                                } else {
&nbsp;                                    Iterator var3 = typeDescription.getInterfaces().iterator();
&nbsp;
&nbsp;                                    Generic interfaceType;
&nbsp;                                    do {
&nbsp;                                        if (!var3.hasNext()) {
&nbsp;                                            return false;
&nbsp;                                        }
&nbsp;
&nbsp;                                        interfaceType = (Generic)var3.next();
&nbsp;                                    } while(!this.isAssignableFrom(interfaceType));
&nbsp;
&nbsp;                                    return true;
&nbsp;                                }
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        public boolean equals(Object var1) {
&nbsp;                            if (this == var1) {
&nbsp;                                return true;
&nbsp;                            } else if (var1 == null) {
&nbsp;                                return false;
&nbsp;                            } else if (this.getClass() != var1.getClass()) {
&nbsp;                                return false;
&nbsp;                            } else {
&nbsp;                                return this.parameterizedType.equals(((ForParameterizedType)var1).parameterizedType);
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        public int hashCode() {
&nbsp;                            return this.getClass().hashCode() * 31 + this.parameterizedType.hashCode();
&nbsp;                        }
&nbsp;
&nbsp;                        protected static enum ParameterAssigner implements Visitor&lt;Dispatcher&gt; {
&nbsp;                            INSTANCE;
&nbsp;
&nbsp;                            private ParameterAssigner() {
&nbsp;                            }
&nbsp;
&nbsp;                            public Dispatcher onGenericArray(Generic genericArray) {
&nbsp;                                return new InvariantBinding(genericArray);
&nbsp;                            }
&nbsp;
&nbsp;                            public Dispatcher onWildcard(Generic wildcard) {
&nbsp;                                TypeList.Generic lowerBounds = wildcard.getLowerBounds();
&nbsp;                                return (Dispatcher)(lowerBounds.isEmpty() ? new CovariantBinding((Generic)wildcard.getUpperBounds().getOnly()) : new ContravariantBinding((Generic)lowerBounds.getOnly()));
&nbsp;                            }
&nbsp;
&nbsp;                            public Dispatcher onParameterizedType(Generic parameterizedType) {
&nbsp;                                return new InvariantBinding(parameterizedType);
&nbsp;                            }
&nbsp;
&nbsp;                            public Dispatcher onTypeVariable(Generic typeVariable) {
&nbsp;                                return new InvariantBinding(typeVariable);
&nbsp;                            }
&nbsp;
&nbsp;                            public Dispatcher onNonGenericType(Generic typeDescription) {
&nbsp;                                return new InvariantBinding(typeDescription);
&nbsp;                            }
&nbsp;
&nbsp;                            @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;                            protected static class ContravariantBinding implements Dispatcher {
&nbsp;                                private final Generic lowerBound;
&nbsp;
&nbsp;                                protected ContravariantBinding(Generic lowerBound) {
&nbsp;                                    this.lowerBound = lowerBound;
&nbsp;                                }
&nbsp;
&nbsp;                                public boolean isAssignableFrom(Generic typeDescription) {
&nbsp;                                    if (typeDescription.getSort().isWildcard()) {
&nbsp;                                        TypeList.Generic lowerBounds = typeDescription.getLowerBounds();
&nbsp;                                        return !lowerBounds.isEmpty() &amp;&amp; ((Dispatcher)((Generic)lowerBounds.getOnly()).accept(TypeDescription.Generic.Visitor.Assigner.INSTANCE)).isAssignableFrom(this.lowerBound);
&nbsp;                                    } else {
&nbsp;                                        return typeDescription.getSort().isWildcard() || ((Dispatcher)typeDescription.accept(TypeDescription.Generic.Visitor.Assigner.INSTANCE)).isAssignableFrom(this.lowerBound);
&nbsp;                                    }
&nbsp;                                }
&nbsp;
&nbsp;                                public boolean equals(Object var1) {
&nbsp;                                    if (this == var1) {
&nbsp;                                        return true;
&nbsp;                                    } else if (var1 == null) {
&nbsp;                                        return false;
&nbsp;                                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                                        return false;
&nbsp;                                    } else {
&nbsp;                                        return this.lowerBound.equals(((ContravariantBinding)var1).lowerBound);
&nbsp;                                    }
&nbsp;                                }
&nbsp;
&nbsp;                                public int hashCode() {
&nbsp;                                    return this.getClass().hashCode() * 31 + this.lowerBound.hashCode();
&nbsp;                                }
&nbsp;                            }
&nbsp;
&nbsp;                            @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;                            protected static class CovariantBinding implements Dispatcher {
&nbsp;                                private final Generic upperBound;
&nbsp;
&nbsp;                                protected CovariantBinding(Generic upperBound) {
&nbsp;                                    this.upperBound = upperBound;
&nbsp;                                }
&nbsp;
&nbsp;                                public boolean isAssignableFrom(Generic typeDescription) {
&nbsp;                                    if (!typeDescription.getSort().isWildcard()) {
&nbsp;                                        return ((Dispatcher)this.upperBound.accept(TypeDescription.Generic.Visitor.Assigner.INSTANCE)).isAssignableFrom(typeDescription);
&nbsp;                                    } else {
&nbsp;                                        return typeDescription.getLowerBounds().isEmpty() &amp;&amp; ((Dispatcher)this.upperBound.accept(TypeDescription.Generic.Visitor.Assigner.INSTANCE)).isAssignableFrom((Generic)typeDescription.getUpperBounds().getOnly());
&nbsp;                                    }
&nbsp;                                }
&nbsp;
&nbsp;                                public boolean equals(Object var1) {
&nbsp;                                    if (this == var1) {
&nbsp;                                        return true;
&nbsp;                                    } else if (var1 == null) {
&nbsp;                                        return false;
&nbsp;                                    } else if (this.getClass() != var1.getClass()) {
<b class="fc">&nbsp;                                        return false;</b>
&nbsp;                                    } else {
&nbsp;                                        return this.upperBound.equals(((CovariantBinding)var1).upperBound);
&nbsp;                                    }
&nbsp;                                }
&nbsp;
&nbsp;                                public int hashCode() {
&nbsp;                                    return this.getClass().hashCode() * 31 + this.upperBound.hashCode();
&nbsp;                                }
&nbsp;                            }
&nbsp;
&nbsp;                            @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;                            protected static class InvariantBinding implements Dispatcher {
&nbsp;                                private final Generic typeDescription;
&nbsp;
&nbsp;                                protected InvariantBinding(Generic typeDescription) {
&nbsp;                                    this.typeDescription = typeDescription;
&nbsp;                                }
&nbsp;
&nbsp;                                public boolean isAssignableFrom(Generic typeDescription) {
&nbsp;                                    return typeDescription.equals(this.typeDescription);
&nbsp;                                }
&nbsp;
&nbsp;                                public boolean equals(Object var1) {
&nbsp;                                    if (this == var1) {
&nbsp;                                        return true;
&nbsp;                                    } else if (var1 == null) {
<b class="fc">&nbsp;                                        return false;</b>
&nbsp;                                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                                        return false;
&nbsp;                                    } else {
&nbsp;                                        return this.typeDescription.equals(((InvariantBinding)var1).typeDescription);
&nbsp;                                    }
&nbsp;                                }
&nbsp;
&nbsp;                                public int hashCode() {
&nbsp;                                    return this.getClass().hashCode() * 31 + this.typeDescription.hashCode();
&nbsp;                                }
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;                    public static class ForTypeVariable extends AbstractBase {
&nbsp;                        private final Generic typeVariable;
&nbsp;
&nbsp;                        protected ForTypeVariable(Generic typeVariable) {
&nbsp;                            this.typeVariable = typeVariable;
&nbsp;                        }
&nbsp;
&nbsp;                        public Boolean onGenericArray(Generic genericArray) {
&nbsp;                            return false;
&nbsp;                        }
&nbsp;
&nbsp;                        public Boolean onWildcard(Generic wildcard) {
&nbsp;                            throw new IllegalArgumentException(&quot;A wildcard is not a first-level type: &quot; + wildcard);
&nbsp;                        }
&nbsp;
&nbsp;                        public Boolean onParameterizedType(Generic parameterizedType) {
&nbsp;                            return false;
&nbsp;                        }
&nbsp;
&nbsp;                        public Boolean onTypeVariable(Generic typeVariable) {
&nbsp;                            if (typeVariable.equals(this.typeVariable)) {
&nbsp;                                return true;
&nbsp;                            } else {
&nbsp;                                Iterator var2 = typeVariable.getUpperBounds().iterator();
&nbsp;
&nbsp;                                Generic upperBound;
&nbsp;                                do {
&nbsp;                                    if (!var2.hasNext()) {
&nbsp;                                        return false;
<b class="fc">&nbsp;                                    }</b>
&nbsp;
&nbsp;                                    upperBound = (Generic)var2.next();
&nbsp;                                } while(!this.isAssignableFrom(upperBound));
&nbsp;
&nbsp;                                return true;
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        public Boolean onNonGenericType(Generic typeDescription) {
&nbsp;                            return false;
&nbsp;                        }
&nbsp;
&nbsp;                        public boolean equals(Object var1) {
&nbsp;                            if (this == var1) {
&nbsp;                                return true;
&nbsp;                            } else if (var1 == null) {
&nbsp;                                return false;
&nbsp;                            } else if (this.getClass() != var1.getClass()) {
&nbsp;                                return false;
&nbsp;                            } else {
&nbsp;                                return this.typeVariable.equals(((ForTypeVariable)var1).typeVariable);
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        public int hashCode() {
&nbsp;                            return this.getClass().hashCode() * 31 + this.typeVariable.hashCode();
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;                    public static class ForNonGenericType extends AbstractBase {
&nbsp;                        private final TypeDescription typeDescription;
&nbsp;
&nbsp;                        protected ForNonGenericType(TypeDescription typeDescription) {
&nbsp;                            this.typeDescription = typeDescription;
&nbsp;                        }
&nbsp;
&nbsp;                        @SuppressFBWarnings(
&nbsp;                            value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;                            justification = &quot;Assuming component type for array type.&quot;
&nbsp;                        )
&nbsp;                        public Boolean onGenericArray(Generic genericArray) {
&nbsp;                            return this.typeDescription.isArray() ? (Boolean)genericArray.getComponentType().accept(new ForNonGenericType(this.typeDescription.getComponentType())) : this.typeDescription.represents(Object.class) || TypeDescription.ARRAY_INTERFACES.contains(this.typeDescription.asGenericType());
&nbsp;                        }
&nbsp;
&nbsp;                        public Boolean onWildcard(Generic wildcard) {
&nbsp;                            throw new IllegalArgumentException(&quot;A wildcard is not a first-level type: &quot; + wildcard);
&nbsp;                        }
&nbsp;
&nbsp;                        public Boolean onParameterizedType(Generic parameterizedType) {
&nbsp;                            if (this.typeDescription.equals(parameterizedType.asErasure())) {
&nbsp;                                return true;
&nbsp;                            } else {
&nbsp;                                Generic superClass = parameterizedType.getSuperClass();
&nbsp;                                if (superClass != null &amp;&amp; this.isAssignableFrom(superClass)) {
&nbsp;                                    return true;
&nbsp;                                } else {
&nbsp;                                    Iterator var3 = parameterizedType.getInterfaces().iterator();
&nbsp;
&nbsp;                                    Generic interfaceType;
&nbsp;                                    do {
&nbsp;                                        if (!var3.hasNext()) {
&nbsp;                                            return this.typeDescription.represents(Object.class);
&nbsp;                                        }
&nbsp;
&nbsp;                                        interfaceType = (Generic)var3.next();
&nbsp;                                    } while(!this.isAssignableFrom(interfaceType));
&nbsp;
&nbsp;                                    return true;
&nbsp;                                }
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        public Boolean onTypeVariable(Generic typeVariable) {
&nbsp;                            Iterator var2 = typeVariable.getUpperBounds().iterator();
&nbsp;
&nbsp;                            Generic upperBound;
&nbsp;                            do {
<b class="fc">&nbsp;                                if (!var2.hasNext()) {</b>
<b class="fc">&nbsp;                                    return false;</b>
&nbsp;                                }
&nbsp;
&nbsp;                                upperBound = (Generic)var2.next();
&nbsp;                            } while(!this.isAssignableFrom(upperBound));
&nbsp;
<b class="fc">&nbsp;                            return true;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        public Boolean onNonGenericType(Generic typeDescription) {
&nbsp;                            return this.typeDescription.isAssignableFrom(typeDescription.asErasure());
&nbsp;                        }
&nbsp;
<b class="fc">&nbsp;                        public boolean equals(Object var1) {</b>
&nbsp;                            if (this == var1) {
&nbsp;                                return true;
&nbsp;                            } else if (var1 == null) {
&nbsp;                                return false;
<b class="fc">&nbsp;                            } else if (this.getClass() != var1.getClass()) {</b>
&nbsp;                                return false;
&nbsp;                            } else {
&nbsp;                                return this.typeDescription.equals(((ForNonGenericType)var1).typeDescription);
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        public int hashCode() {
&nbsp;                            return this.getClass().hashCode() * 31 + this.typeDescription.hashCode();
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public abstract static class AbstractBase implements Dispatcher, Visitor&lt;Boolean&gt; {
&nbsp;                        public AbstractBase() {
&nbsp;                        }
&nbsp;
&nbsp;                        public boolean isAssignableFrom(Generic typeDescription) {
&nbsp;                            return (Boolean)typeDescription.accept(this);
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public static enum AnnotationStripper implements Visitor&lt;Generic&gt; {
&nbsp;                INSTANCE;
&nbsp;
&nbsp;                private AnnotationStripper() {
&nbsp;                }
&nbsp;
&nbsp;                @SuppressFBWarnings(
&nbsp;                    value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;                    justification = &quot;Assuming component type for array type.&quot;
&nbsp;                )
&nbsp;                public Generic onGenericArray(Generic genericArray) {
&nbsp;                    return new OfGenericArray.Latent((Generic)genericArray.getComponentType().accept(this), Empty.INSTANCE);
&nbsp;                }
&nbsp;
&nbsp;                public Generic onWildcard(Generic wildcard) {
&nbsp;                    return new OfWildcardType.Latent(wildcard.getUpperBounds().accept(this), wildcard.getLowerBounds().accept(this), Empty.INSTANCE);
&nbsp;                }
&nbsp;
&nbsp;                public Generic onParameterizedType(Generic parameterizedType) {
&nbsp;                    Generic ownerType = parameterizedType.getOwnerType();
&nbsp;                    return new OfParameterizedType.Latent(parameterizedType.asErasure(), ownerType == null ? TypeDescription.Generic.UNDEFINED : (Generic)ownerType.accept(this), parameterizedType.getTypeArguments().accept(this), Empty.INSTANCE);
&nbsp;                }
&nbsp;
&nbsp;                public Generic onTypeVariable(Generic typeVariable) {
&nbsp;                    return new NonAnnotatedTypeVariable(typeVariable);
&nbsp;                }
&nbsp;
&nbsp;                @SuppressFBWarnings(
&nbsp;                    value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;                    justification = &quot;Assuming component type for array type.&quot;
&nbsp;                )
&nbsp;                public Generic onNonGenericType(Generic typeDescription) {
&nbsp;                    return (Generic)(typeDescription.isArray() ? new OfGenericArray.Latent(this.onNonGenericType(typeDescription.getComponentType()), Empty.INSTANCE) : new OfNonGenericType.Latent(typeDescription.asErasure(), Empty.INSTANCE));
&nbsp;                }
&nbsp;
&nbsp;                protected static class NonAnnotatedTypeVariable extends OfTypeVariable {
&nbsp;                    private final Generic typeVariable;
&nbsp;
&nbsp;                    protected NonAnnotatedTypeVariable(Generic typeVariable) {
&nbsp;                        this.typeVariable = typeVariable;
&nbsp;                    }
&nbsp;
&nbsp;                    public TypeList.Generic getUpperBounds() {
&nbsp;                        return this.typeVariable.getUpperBounds();
&nbsp;                    }
&nbsp;
&nbsp;                    public TypeVariableSource getTypeVariableSource() {
&nbsp;                        return this.typeVariable.getTypeVariableSource();
&nbsp;                    }
&nbsp;
&nbsp;                    public String getSymbol() {
&nbsp;                        return this.typeVariable.getSymbol();
&nbsp;                    }
&nbsp;
&nbsp;                    public AnnotationList getDeclaredAnnotations() {
&nbsp;                        return new AnnotationList.Empty();
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public static enum TypeErasing implements Visitor&lt;Generic&gt; {
&nbsp;                INSTANCE;
&nbsp;
&nbsp;                private TypeErasing() {
&nbsp;                }
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                public Generic onGenericArray(Generic genericArray) {</b>
<b class="fc">&nbsp;                    return genericArray.asRawType();</b>
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                public Generic onWildcard(Generic wildcard) {
&nbsp;                    throw new IllegalArgumentException(&quot;Cannot erase a wildcard type: &quot; + wildcard);
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                public Generic onParameterizedType(Generic parameterizedType) {</b>
<b class="fc">&nbsp;                    return parameterizedType.asRawType();</b>
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                public Generic onTypeVariable(Generic typeVariable) {
&nbsp;                    return typeVariable.asRawType();
&nbsp;                }
&nbsp;
&nbsp;                public Generic onNonGenericType(Generic typeDescription) {
&nbsp;                    return typeDescription.asRawType();
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            public static enum NoOp implements Visitor&lt;Generic&gt; {
&nbsp;                INSTANCE;
<b class="fc">&nbsp;</b>
&nbsp;                private NoOp() {
&nbsp;                }
&nbsp;
&nbsp;                public Generic onGenericArray(Generic genericArray) {
&nbsp;                    return genericArray;
&nbsp;                }
&nbsp;
&nbsp;                public Generic onWildcard(Generic wildcard) {
&nbsp;                    return wildcard;
&nbsp;                }
&nbsp;
&nbsp;                public Generic onParameterizedType(Generic parameterizedType) {
&nbsp;                    return parameterizedType;
&nbsp;                }
&nbsp;
&nbsp;                public Generic onTypeVariable(Generic typeVariable) {
&nbsp;                    return typeVariable;
&nbsp;                }
&nbsp;
&nbsp;                public Generic onNonGenericType(Generic typeDescription) {
&nbsp;                    return typeDescription;
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-22 12:48</div>
</div>
</body>
</html>
