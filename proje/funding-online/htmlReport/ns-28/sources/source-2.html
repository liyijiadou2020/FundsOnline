


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=GBK"> 
  <title>Coverage Report > Implementation</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.implementation</a>
</div>

<h1>Coverage Summary for Class: Implementation (net.bytebuddy.implementation)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
  <tr>
    <td class="name">Implementation$Context$Default</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (48/48)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Context$Default$AbstractPropertyAccessorMethod</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Context$Default$AccessorMethod</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (13/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Context$Default$AccessorMethodDelegation</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (11/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Context$Default$CacheValueField</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (8/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Context$Default$DelegationRecord</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (11/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Context$Default$Factory</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Context$Default$FieldCacheEntry</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (8/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Context$ExtractableView$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$SpecialMethodInvocation$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$SpecialMethodInvocation$Illegal</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$SpecialMethodInvocation$Simple</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (11/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Target$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (15/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Target$AbstractBase$DefaultMethodInvocation</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Target$AbstractBase$DefaultMethodInvocation$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Target$AbstractBase$DefaultMethodInvocation$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (22/22)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (149/149)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;//
&nbsp;// Source code recreated from a .class file by IntelliJ IDEA
&nbsp;// (powered by FernFlower decompiler)
&nbsp;//
&nbsp;
&nbsp;package net.bytebuddy.implementation;
&nbsp;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Collections;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.Iterator;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Set;
&nbsp;import javax.annotation.CheckForNull;
&nbsp;import javax.annotation.Nonnull;
&nbsp;import javax.annotation.meta.When;
&nbsp;import net.bytebuddy.ClassFileVersion;
&nbsp;import net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance;
&nbsp;import net.bytebuddy.description.annotation.AnnotationList;
&nbsp;import net.bytebuddy.description.annotation.AnnotationValue;
&nbsp;import net.bytebuddy.description.field.FieldDescription;
&nbsp;import net.bytebuddy.description.method.MethodDescription;
&nbsp;import net.bytebuddy.description.method.ParameterDescription;
&nbsp;import net.bytebuddy.description.method.ParameterList;
&nbsp;import net.bytebuddy.description.modifier.Visibility;
&nbsp;import net.bytebuddy.description.type.TypeDefinition;
&nbsp;import net.bytebuddy.description.type.TypeDescription;
&nbsp;import net.bytebuddy.description.type.TypeList;
&nbsp;import net.bytebuddy.description.type.TypeDescription.Generic;
&nbsp;import net.bytebuddy.dynamic.DynamicType;
&nbsp;import net.bytebuddy.dynamic.scaffold.InstrumentedType;
&nbsp;import net.bytebuddy.dynamic.scaffold.MethodGraph;
&nbsp;import net.bytebuddy.dynamic.scaffold.TypeInitializer;
&nbsp;import net.bytebuddy.dynamic.scaffold.TypeWriter;
&nbsp;import net.bytebuddy.dynamic.scaffold.InstrumentedType.Prepareable.NoOp;
&nbsp;import net.bytebuddy.dynamic.scaffold.TypeInitializer.None;
&nbsp;import net.bytebuddy.dynamic.scaffold.TypeWriter.MethodPool.Record.Sort;
&nbsp;import net.bytebuddy.implementation.attribute.AnnotationValueFilter;
&nbsp;import net.bytebuddy.implementation.auxiliary.AuxiliaryType;
&nbsp;import net.bytebuddy.implementation.bytecode.ByteCodeAppender;
&nbsp;import net.bytebuddy.implementation.bytecode.StackManipulation;
&nbsp;import net.bytebuddy.implementation.bytecode.StackManipulation.Trivial;
&nbsp;import net.bytebuddy.implementation.bytecode.member.FieldAccess;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodInvocation;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodReturn;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodVariableAccess;
&nbsp;import net.bytebuddy.jar.asm.ClassVisitor;
&nbsp;import net.bytebuddy.jar.asm.FieldVisitor;
&nbsp;import net.bytebuddy.jar.asm.MethodVisitor;
&nbsp;import net.bytebuddy.utility.CompoundList;
&nbsp;import net.bytebuddy.utility.RandomString;
&nbsp;
&nbsp;public interface Implementation extends InstrumentedType.Prepareable {
&nbsp;    ByteCodeAppender appender(Target var1);
&nbsp;
&nbsp;    @Enhance
&nbsp;    public static class Simple implements Implementation {
&nbsp;        private static final int NO_ADDITIONAL_VARIABLES = 0;
&nbsp;        private final ByteCodeAppender byteCodeAppender;
&nbsp;
&nbsp;        public Simple(ByteCodeAppender... byteCodeAppender) {
&nbsp;            this.byteCodeAppender = new ByteCodeAppender.Compound(byteCodeAppender);
&nbsp;        }
&nbsp;
&nbsp;        public Simple(StackManipulation... stackManipulation) {
&nbsp;            this.byteCodeAppender = new ByteCodeAppender.Simple(stackManipulation);
&nbsp;        }
&nbsp;
&nbsp;        public static Implementation of(Dispatcher dispatcher) {
&nbsp;            return of(dispatcher, 0);
&nbsp;        }
&nbsp;
&nbsp;        public static Implementation of(Dispatcher dispatcher, int additionalVariableLength) {
&nbsp;            return of(dispatcher, NoOp.INSTANCE, additionalVariableLength);
&nbsp;        }
&nbsp;
&nbsp;        public static Implementation of(Dispatcher dispatcher, InstrumentedType.Prepareable prepareable) {
&nbsp;            return of(dispatcher, prepareable, 0);
&nbsp;        }
&nbsp;
&nbsp;        public static Implementation of(Dispatcher dispatcher, InstrumentedType.Prepareable prepareable, int additionalVariableLength) {
&nbsp;            if (additionalVariableLength &lt; 0) {
&nbsp;                throw new IllegalArgumentException(&quot;Additional variable length cannot be negative: &quot; + additionalVariableLength);
&nbsp;            } else {
&nbsp;                return new ForDispatcher(dispatcher, prepareable, additionalVariableLength);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public InstrumentedType prepare(InstrumentedType instrumentedType) {
&nbsp;            return instrumentedType;
&nbsp;        }
&nbsp;
&nbsp;        public ByteCodeAppender appender(Target implementationTarget) {
&nbsp;            return this.byteCodeAppender;
&nbsp;        }
&nbsp;
&nbsp;        public boolean equals(Object var1) {
&nbsp;            if (this == var1) {
&nbsp;                return true;
&nbsp;            } else if (var1 == null) {
&nbsp;                return false;
&nbsp;            } else if (this.getClass() != var1.getClass()) {
&nbsp;                return false;
&nbsp;            } else {
&nbsp;                return this.byteCodeAppender.equals(((Simple)var1).byteCodeAppender);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public int hashCode() {
&nbsp;            return this.getClass().hashCode() * 31 + this.byteCodeAppender.hashCode();
&nbsp;        }
&nbsp;
&nbsp;        @Enhance
&nbsp;        protected static class ForDispatcher implements Implementation {
&nbsp;            private final Dispatcher dispatcher;
&nbsp;            private final InstrumentedType.Prepareable prepareable;
&nbsp;            private final int additionalVariableLength;
&nbsp;
&nbsp;            protected ForDispatcher(Dispatcher dispatcher, InstrumentedType.Prepareable prepareable, int additionalVariableLength) {
&nbsp;                this.dispatcher = dispatcher;
&nbsp;                this.prepareable = prepareable;
&nbsp;                this.additionalVariableLength = additionalVariableLength;
&nbsp;            }
&nbsp;
&nbsp;            public InstrumentedType prepare(InstrumentedType instrumentedType) {
&nbsp;                return this.prepareable.prepare(instrumentedType);
&nbsp;            }
&nbsp;
&nbsp;            public ByteCodeAppender appender(Target implementationTarget) {
&nbsp;                return new Appender(implementationTarget);
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(Object var1) {
&nbsp;                if (this == var1) {
&nbsp;                    return true;
&nbsp;                } else if (var1 == null) {
<b class="fc">&nbsp;                    return false;</b>
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
&nbsp;                } else if (this.additionalVariableLength != ((ForDispatcher)var1).additionalVariableLength) {
&nbsp;                    return false;
<b class="fc">&nbsp;                } else if (!this.dispatcher.equals(((ForDispatcher)var1).dispatcher)) {</b>
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return this.prepareable.equals(((ForDispatcher)var1).prepareable);
&nbsp;                }
&nbsp;            }
<b class="fc">&nbsp;</b>
&nbsp;            public int hashCode() {
&nbsp;                return ((this.getClass().hashCode() * 31 + this.dispatcher.hashCode()) * 31 + this.prepareable.hashCode()) * 31 + this.additionalVariableLength;
&nbsp;            }
&nbsp;
&nbsp;            @Enhance(
&nbsp;                includeSyntheticFields = true
&nbsp;            )
&nbsp;            protected class Appender implements ByteCodeAppender {
&nbsp;                private final Target implementationTarget;
&nbsp;
&nbsp;                protected Appender(Target implementationTarget) {
&nbsp;                    this.implementationTarget = implementationTarget;
&nbsp;                }
&nbsp;
&nbsp;                public ByteCodeAppender.Size apply(MethodVisitor methodVisitor, Context implementationContext, MethodDescription instrumentedMethod) {
&nbsp;                    return new ByteCodeAppender.Size(ForDispatcher.this.dispatcher.apply(this.implementationTarget, instrumentedMethod).apply(methodVisitor, implementationContext).getMaximalSize(), instrumentedMethod.getStackSize() + ForDispatcher.this.additionalVariableLength);
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(Object var1) {
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.implementationTarget.equals(((Appender)var1).implementationTarget)) {
&nbsp;                        return false;
<b class="fc">&nbsp;                    } else {</b>
&nbsp;                        return ForDispatcher.this.equals(ForDispatcher.this);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return (this.getClass().hashCode() * 31 + this.implementationTarget.hashCode()) * 31 + ForDispatcher.this.hashCode();
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public interface Dispatcher {
<b class="fc">&nbsp;            StackManipulation apply(Target var1, MethodDescription var2);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Enhance
&nbsp;    public static class Compound implements Implementation {
&nbsp;        private final List&lt;Implementation&gt; implementations;
&nbsp;
&nbsp;        public Compound(Implementation... implementation) {
&nbsp;            this(Arrays.asList(implementation));
&nbsp;        }
&nbsp;
&nbsp;        public Compound(List&lt;? extends Implementation&gt; implementations) {
&nbsp;            this.implementations = new ArrayList();
&nbsp;            Iterator var2 = implementations.iterator();
&nbsp;
&nbsp;            while(var2.hasNext()) {
&nbsp;                Implementation implementation = (Implementation)var2.next();
&nbsp;                if (implementation instanceof Composable) {
&nbsp;                    this.implementations.addAll(((Composable)implementation).implementations);
&nbsp;                    this.implementations.add(((Composable)implementation).composable);
&nbsp;                } else if (implementation instanceof Compound) {
&nbsp;                    this.implementations.addAll(((Compound)implementation).implementations);
&nbsp;                } else {
&nbsp;                    this.implementations.add(implementation);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;        }
&nbsp;
&nbsp;        public InstrumentedType prepare(InstrumentedType instrumentedType) {
&nbsp;            Implementation implementation;
&nbsp;            for(Iterator var2 = this.implementations.iterator(); var2.hasNext(); instrumentedType = implementation.prepare(instrumentedType)) {
&nbsp;                implementation = (Implementation)var2.next();
&nbsp;            }
&nbsp;
&nbsp;            return instrumentedType;
&nbsp;        }
&nbsp;
&nbsp;        public ByteCodeAppender appender(Target implementationTarget) {
&nbsp;            ByteCodeAppender[] byteCodeAppender = new ByteCodeAppender[this.implementations.size()];
&nbsp;            int index = 0;
&nbsp;
&nbsp;            Implementation implementation;
<b class="fc">&nbsp;            for(Iterator var4 = this.implementations.iterator(); var4.hasNext(); byteCodeAppender[index++] = implementation.appender(implementationTarget)) {</b>
<b class="fc">&nbsp;                implementation = (Implementation)var4.next();</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;</b>
&nbsp;            return new ByteCodeAppender.Compound(byteCodeAppender);
&nbsp;        }
&nbsp;
&nbsp;        public boolean equals(Object var1) {
&nbsp;            if (this == var1) {
&nbsp;                return true;
&nbsp;            } else if (var1 == null) {
&nbsp;                return false;
&nbsp;            } else if (this.getClass() != var1.getClass()) {
&nbsp;                return false;
&nbsp;            } else {
&nbsp;                return this.implementations.equals(((Compound)var1).implementations);
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        public int hashCode() {
&nbsp;            return this.getClass().hashCode() * 31 + this.implementations.hashCode();
&nbsp;        }
&nbsp;
&nbsp;        @Enhance
&nbsp;        public static class Composable implements Composable {
&nbsp;            private final Composable composable;
<b class="fc">&nbsp;            private final List&lt;Implementation&gt; implementations;</b>
&nbsp;
&nbsp;            public Composable(Implementation implementation, Composable composable) {
&nbsp;                this(Collections.singletonList(implementation), composable);
&nbsp;            }
&nbsp;
&nbsp;            public Composable(List&lt;? extends Implementation&gt; implementations, Composable composable) {
<b class="fc">&nbsp;                this.implementations = new ArrayList();</b>
&nbsp;                Iterator var3 = implementations.iterator();
&nbsp;
&nbsp;                while(var3.hasNext()) {
&nbsp;                    Implementation implementation = (Implementation)var3.next();
&nbsp;                    if (implementation instanceof Composable) {
&nbsp;                        this.implementations.addAll(((Composable)implementation).implementations);
<b class="fc">&nbsp;                        this.implementations.add(((Composable)implementation).composable);</b>
&nbsp;                    } else if (implementation instanceof Compound) {
&nbsp;                        this.implementations.addAll(((Compound)implementation).implementations);
&nbsp;                    } else {
&nbsp;                        this.implementations.add(implementation);
&nbsp;                    }
&nbsp;                }
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                if (composable instanceof Composable) {</b>
&nbsp;                    this.implementations.addAll(((Composable)composable).implementations);
&nbsp;                    this.composable = ((Composable)composable).composable;
&nbsp;                } else {
&nbsp;                    this.composable = composable;
&nbsp;                }
&nbsp;
&nbsp;            }
&nbsp;
&nbsp;            public InstrumentedType prepare(InstrumentedType instrumentedType) {
&nbsp;                Implementation implementation;
&nbsp;                for(Iterator var2 = this.implementations.iterator(); var2.hasNext(); instrumentedType = implementation.prepare(instrumentedType)) {
&nbsp;                    implementation = (Implementation)var2.next();
&nbsp;                }
&nbsp;
&nbsp;                return this.composable.prepare(instrumentedType);
&nbsp;            }
&nbsp;
&nbsp;            public ByteCodeAppender appender(Target implementationTarget) {
&nbsp;                ByteCodeAppender[] byteCodeAppender = new ByteCodeAppender[this.implementations.size() + 1];
&nbsp;                int index = 0;
&nbsp;
&nbsp;                Implementation implementation;
&nbsp;                for(Iterator var4 = this.implementations.iterator(); var4.hasNext(); byteCodeAppender[index++] = implementation.appender(implementationTarget)) {
&nbsp;                    implementation = (Implementation)var4.next();
&nbsp;                }
&nbsp;
&nbsp;                byteCodeAppender[index] = this.composable.appender(implementationTarget);
&nbsp;                return new ByteCodeAppender.Compound(byteCodeAppender);
&nbsp;            }
&nbsp;
&nbsp;            public Implementation andThen(Implementation implementation) {
&nbsp;                return new Compound(CompoundList.of(this.implementations, this.composable.andThen(implementation)));
&nbsp;            }
&nbsp;
&nbsp;            public Composable andThen(Composable implementation) {
&nbsp;                return new Composable(this.implementations, this.composable.andThen(implementation));
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(Object var1) {
&nbsp;                if (this == var1) {
&nbsp;                    return true;
&nbsp;                } else if (var1 == null) {
&nbsp;                    return false;
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
&nbsp;                } else if (!this.composable.equals(((Composable)var1).composable)) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return this.implementations.equals(((Composable)var1).implementations);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public int hashCode() {
&nbsp;                return (this.getClass().hashCode() * 31 + this.composable.hashCode()) * 31 + this.implementations.hashCode();
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public interface Context extends MethodAccessorFactory {
&nbsp;        TypeDescription register(AuxiliaryType var1);
&nbsp;
&nbsp;        FieldDescription.InDefinedShape cache(StackManipulation var1, TypeDescription var2);
&nbsp;
&nbsp;        TypeDescription getInstrumentedType();
&nbsp;
&nbsp;        ClassFileVersion getClassFileVersion();
&nbsp;
&nbsp;        public static class Default extends ExtractableView.AbstractBase {
&nbsp;            public static final String ACCESSOR_METHOD_SUFFIX = &quot;accessor&quot;;
&nbsp;            public static final String FIELD_CACHE_PREFIX = &quot;cachedValue&quot;;
&nbsp;            private final AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy;
&nbsp;            private final TypeInitializer typeInitializer;
&nbsp;            private final ClassFileVersion auxiliaryClassFileVersion;
&nbsp;            private final Map&lt;SpecialMethodInvocation, DelegationRecord&gt; registeredAccessorMethods;
&nbsp;            private final Map&lt;FieldDescription, DelegationRecord&gt; registeredGetters;
&nbsp;            private final Map&lt;FieldDescription, DelegationRecord&gt; registeredSetters;
&nbsp;            private final Map&lt;AuxiliaryType, DynamicType&gt; auxiliaryTypes;
&nbsp;            private final Map&lt;FieldCacheEntry, FieldDescription.InDefinedShape&gt; registeredFieldCacheEntries;
&nbsp;            private final Set&lt;FieldDescription.InDefinedShape&gt; registeredFieldCacheFields;
&nbsp;            private final String suffix;
&nbsp;            private boolean fieldCacheCanAppendEntries;
&nbsp;
&nbsp;            protected Default(TypeDescription instrumentedType, ClassFileVersion classFileVersion, AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy, TypeInitializer typeInitializer, ClassFileVersion auxiliaryClassFileVersion) {
&nbsp;                super(instrumentedType, classFileVersion);
&nbsp;                this.auxiliaryTypeNamingStrategy = auxiliaryTypeNamingStrategy;
&nbsp;                this.typeInitializer = typeInitializer;
&nbsp;                this.auxiliaryClassFileVersion = auxiliaryClassFileVersion;
&nbsp;                this.registeredAccessorMethods = new HashMap();
&nbsp;                this.registeredGetters = new HashMap();
&nbsp;                this.registeredSetters = new HashMap();
&nbsp;                this.auxiliaryTypes = new HashMap();
&nbsp;                this.registeredFieldCacheEntries = new HashMap();
&nbsp;                this.registeredFieldCacheFields = new HashSet();
&nbsp;                this.suffix = RandomString.make();
&nbsp;                this.fieldCacheCanAppendEntries = true;
&nbsp;            }
&nbsp;
&nbsp;            public boolean isEnabled() {
&nbsp;                return true;
&nbsp;            }
&nbsp;
&nbsp;            public MethodDescription.InDefinedShape registerAccessorFor(SpecialMethodInvocation specialMethodInvocation, MethodAccessorFactory.AccessType accessType) {
&nbsp;                DelegationRecord record = (DelegationRecord)this.registeredAccessorMethods.get(specialMethodInvocation);
&nbsp;                DelegationRecord record = record == null ? new AccessorMethodDelegation(this.instrumentedType, this.suffix, accessType, specialMethodInvocation) : record.with(accessType);
&nbsp;                this.registeredAccessorMethods.put(specialMethodInvocation, record);
&nbsp;                return ((DelegationRecord)record).getMethod();
&nbsp;            }
&nbsp;
&nbsp;            public MethodDescription.InDefinedShape registerGetterFor(FieldDescription fieldDescription, MethodAccessorFactory.AccessType accessType) {
&nbsp;                DelegationRecord record = (DelegationRecord)this.registeredGetters.get(fieldDescription);
&nbsp;                DelegationRecord record = record == null ? new FieldGetterDelegation(this.instrumentedType, this.suffix, accessType, fieldDescription) : record.with(accessType);
&nbsp;                this.registeredGetters.put(fieldDescription, record);
&nbsp;                return ((DelegationRecord)record).getMethod();
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;            public MethodDescription.InDefinedShape registerSetterFor(FieldDescription fieldDescription, MethodAccessorFactory.AccessType accessType) {</b>
<b class="fc">&nbsp;                DelegationRecord record = (DelegationRecord)this.registeredSetters.get(fieldDescription);</b>
&nbsp;                DelegationRecord record = record == null ? new FieldSetterDelegation(this.instrumentedType, this.suffix, accessType, fieldDescription) : record.with(accessType);
&nbsp;                this.registeredSetters.put(fieldDescription, record);
&nbsp;                return ((DelegationRecord)record).getMethod();
&nbsp;            }
&nbsp;
&nbsp;            public TypeDescription register(AuxiliaryType auxiliaryType) {
<b class="fc">&nbsp;                DynamicType dynamicType = (DynamicType)this.auxiliaryTypes.get(auxiliaryType);</b>
&nbsp;                if (dynamicType == null) {
&nbsp;                    dynamicType = auxiliaryType.make(this.auxiliaryTypeNamingStrategy.name(this.instrumentedType, auxiliaryType), this.auxiliaryClassFileVersion, this);
&nbsp;                    this.auxiliaryTypes.put(auxiliaryType, dynamicType);
&nbsp;                }
&nbsp;
&nbsp;                return dynamicType.getTypeDescription();
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;            public List&lt;DynamicType&gt; getAuxiliaryTypes() {</b>
<b class="fc">&nbsp;                return new ArrayList(this.auxiliaryTypes.values());</b>
&nbsp;            }
&nbsp;
&nbsp;            public FieldDescription.InDefinedShape cache(StackManipulation fieldValue, TypeDescription fieldType) {
&nbsp;                FieldCacheEntry fieldCacheEntry = new FieldCacheEntry(fieldValue, fieldType);
&nbsp;                FieldDescription.InDefinedShape fieldCache = (FieldDescription.InDefinedShape)this.registeredFieldCacheEntries.get(fieldCacheEntry);
&nbsp;                if (fieldCache != null) {
<b class="fc">&nbsp;                    return fieldCache;</b>
<b class="fc">&nbsp;                } else if (!this.fieldCacheCanAppendEntries) {</b>
&nbsp;                    throw new IllegalStateException(&quot;Cached values cannot be registered after defining the type initializer for &quot; + this.instrumentedType);
&nbsp;                } else {
&nbsp;                    int hashCode = fieldValue.hashCode();
&nbsp;
&nbsp;                    CacheValueField fieldCache;
&nbsp;                    do {
<b class="fc">&nbsp;                        fieldCache = new CacheValueField(this.instrumentedType, fieldType.asGenericType(), this.suffix, hashCode++);</b>
&nbsp;                    } while(!this.registeredFieldCacheFields.add(fieldCache));
&nbsp;
&nbsp;                    this.registeredFieldCacheEntries.put(fieldCacheEntry, fieldCache);
&nbsp;                    return fieldCache;
&nbsp;                }
&nbsp;            }
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;            public void drain(TypeInitializer.Drain drain, ClassVisitor classVisitor, AnnotationValueFilter.Factory annotationValueFilterFactory) {</b>
&nbsp;                this.fieldCacheCanAppendEntries = false;
<b class="fc">&nbsp;                TypeInitializer typeInitializer = this.typeInitializer;</b>
&nbsp;                Iterator var5 = this.registeredFieldCacheEntries.entrySet().iterator();
&nbsp;
&nbsp;                while(var5.hasNext()) {
&nbsp;                    Map.Entry&lt;FieldCacheEntry, FieldDescription.InDefinedShape&gt; entry = (Map.Entry)var5.next();
&nbsp;                    FieldVisitor fieldVisitor = classVisitor.visitField(((FieldDescription.InDefinedShape)entry.getValue()).getModifiers(), ((FieldDescription.InDefinedShape)entry.getValue()).getInternalName(), ((FieldDescription.InDefinedShape)entry.getValue()).getDescriptor(), ((FieldDescription.InDefinedShape)entry.getValue()).getGenericSignature(), FieldDescription.NO_DEFAULT_VALUE);
<b class="fc">&nbsp;                    if (fieldVisitor != null) {</b>
&nbsp;                        fieldVisitor.visitEnd();
&nbsp;                        typeInitializer = typeInitializer.expandWith(((FieldCacheEntry)entry.getKey()).storeIn((FieldDescription)entry.getValue()));
&nbsp;                    }
&nbsp;                }
<b class="fc">&nbsp;</b>
&nbsp;                drain.apply(classVisitor, typeInitializer, this);
&nbsp;                var5 = this.registeredAccessorMethods.values().iterator();
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                TypeWriter.MethodPool.Record record;</b>
&nbsp;                while(var5.hasNext()) {
&nbsp;                    record = (TypeWriter.MethodPool.Record)var5.next();
&nbsp;                    record.apply(classVisitor, this, annotationValueFilterFactory);
&nbsp;                }
&nbsp;
&nbsp;                var5 = this.registeredGetters.values().iterator();
&nbsp;
<b class="fc">&nbsp;                while(var5.hasNext()) {</b>
&nbsp;                    record = (TypeWriter.MethodPool.Record)var5.next();
&nbsp;                    record.apply(classVisitor, this, annotationValueFilterFactory);
&nbsp;                }
&nbsp;
&nbsp;                var5 = this.registeredSetters.values().iterator();
&nbsp;
&nbsp;                while(var5.hasNext()) {
&nbsp;                    record = (TypeWriter.MethodPool.Record)var5.next();
&nbsp;                    record.apply(classVisitor, this, annotationValueFilterFactory);
&nbsp;                }
&nbsp;
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            public static enum Factory implements Factory {</b>
&nbsp;                INSTANCE;
&nbsp;
&nbsp;                private Factory() {
&nbsp;                }
&nbsp;
&nbsp;                public ExtractableView make(TypeDescription instrumentedType, AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy, TypeInitializer typeInitializer, ClassFileVersion classFileVersion, ClassFileVersion auxiliaryClassFileVersion) {
&nbsp;                    return new Default(instrumentedType, classFileVersion, auxiliaryTypeNamingStrategy, typeInitializer, auxiliaryClassFileVersion);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Enhance
&nbsp;            protected static class FieldSetterDelegation extends DelegationRecord {
&nbsp;                private final FieldDescription fieldDescription;
&nbsp;
&nbsp;                protected FieldSetterDelegation(TypeDescription instrumentedType, String suffix, MethodAccessorFactory.AccessType accessType, FieldDescription fieldDescription) {
&nbsp;                    this(new FieldSetter(instrumentedType, fieldDescription, suffix), accessType.getVisibility(), fieldDescription);
&nbsp;                }
&nbsp;
&nbsp;                private FieldSetterDelegation(MethodDescription.InDefinedShape methodDescription, Visibility visibility, FieldDescription fieldDescription) {
&nbsp;                    super(methodDescription, visibility);
&nbsp;                    this.fieldDescription = fieldDescription;
&nbsp;                }
&nbsp;
&nbsp;                protected DelegationRecord with(MethodAccessorFactory.AccessType accessType) {
&nbsp;                    return new FieldSetterDelegation(this.methodDescription, this.visibility.expandTo(accessType.getVisibility()), this.fieldDescription);
&nbsp;                }
&nbsp;
&nbsp;                public ByteCodeAppender.Size apply(MethodVisitor methodVisitor, Context implementationContext, MethodDescription instrumentedMethod) {
&nbsp;                    StackManipulation.Size stackSize = (new StackManipulation.Compound(new StackManipulation[]{MethodVariableAccess.allArgumentsOf(instrumentedMethod).prependThisReference(), FieldAccess.forField(this.fieldDescription).write(), MethodReturn.VOID})).apply(methodVisitor, implementationContext);
&nbsp;                    return new ByteCodeAppender.Size(stackSize.getMaximalSize(), instrumentedMethod.getStackSize());
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(Object var1) {
&nbsp;                    if (!super.equals(var1)) {
&nbsp;                        return false;
&nbsp;                    } else if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.fieldDescription.equals(((FieldSetterDelegation)var1).fieldDescription);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return super.hashCode() * 31 + this.fieldDescription.hashCode();
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Enhance
&nbsp;            protected static class FieldGetterDelegation extends DelegationRecord {
&nbsp;                private final FieldDescription fieldDescription;
&nbsp;
&nbsp;                protected FieldGetterDelegation(TypeDescription instrumentedType, String suffix, MethodAccessorFactory.AccessType accessType, FieldDescription fieldDescription) {
&nbsp;                    this(new FieldGetter(instrumentedType, fieldDescription, suffix), accessType.getVisibility(), fieldDescription);
&nbsp;                }
&nbsp;
&nbsp;                private FieldGetterDelegation(MethodDescription.InDefinedShape methodDescription, Visibility visibility, FieldDescription fieldDescription) {
&nbsp;                    super(methodDescription, visibility);
&nbsp;                    this.fieldDescription = fieldDescription;
&nbsp;                }
&nbsp;
&nbsp;                protected DelegationRecord with(MethodAccessorFactory.AccessType accessType) {
&nbsp;                    return new FieldGetterDelegation(this.methodDescription, this.visibility.expandTo(accessType.getVisibility()), this.fieldDescription);
&nbsp;                }
&nbsp;
&nbsp;                public ByteCodeAppender.Size apply(MethodVisitor methodVisitor, Context implementationContext, MethodDescription instrumentedMethod) {
&nbsp;                    StackManipulation.Size stackSize = (new StackManipulation.Compound(new StackManipulation[]{(StackManipulation)(this.fieldDescription.isStatic() ? Trivial.INSTANCE : MethodVariableAccess.loadThis()), FieldAccess.forField(this.fieldDescription).read(), MethodReturn.of(this.fieldDescription.getType())})).apply(methodVisitor, implementationContext);
&nbsp;                    return new ByteCodeAppender.Size(stackSize.getMaximalSize(), instrumentedMethod.getStackSize());
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(Object var1) {
&nbsp;                    if (!super.equals(var1)) {
&nbsp;                        return false;
&nbsp;                    } else if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.fieldDescription.equals(((FieldGetterDelegation)var1).fieldDescription);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return super.hashCode() * 31 + this.fieldDescription.hashCode();
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Enhance
&nbsp;            protected static class AccessorMethodDelegation extends DelegationRecord {
&nbsp;                private final StackManipulation accessorMethodInvocation;
&nbsp;
&nbsp;                protected AccessorMethodDelegation(TypeDescription instrumentedType, String suffix, MethodAccessorFactory.AccessType accessType, SpecialMethodInvocation specialMethodInvocation) {
&nbsp;                    this(new AccessorMethod(instrumentedType, specialMethodInvocation.getMethodDescription(), specialMethodInvocation.getTypeDescription(), suffix), accessType.getVisibility(), specialMethodInvocation);
&nbsp;                }
&nbsp;
&nbsp;                private AccessorMethodDelegation(MethodDescription.InDefinedShape methodDescription, Visibility visibility, StackManipulation accessorMethodInvocation) {
&nbsp;                    super(methodDescription, visibility);
&nbsp;                    this.accessorMethodInvocation = accessorMethodInvocation;
&nbsp;                }
&nbsp;
&nbsp;                protected DelegationRecord with(MethodAccessorFactory.AccessType accessType) {
&nbsp;                    return new AccessorMethodDelegation(this.methodDescription, this.visibility.expandTo(accessType.getVisibility()), this.accessorMethodInvocation);
&nbsp;                }
&nbsp;
&nbsp;                public ByteCodeAppender.Size apply(MethodVisitor methodVisitor, Context implementationContext, MethodDescription instrumentedMethod) {
&nbsp;                    StackManipulation.Size stackSize = (new StackManipulation.Compound(new StackManipulation[]{MethodVariableAccess.allArgumentsOf(instrumentedMethod).prependThisReference(), this.accessorMethodInvocation, MethodReturn.of(instrumentedMethod.getReturnType())})).apply(methodVisitor, implementationContext);
&nbsp;                    return new ByteCodeAppender.Size(stackSize.getMaximalSize(), instrumentedMethod.getStackSize());
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(Object var1) {
&nbsp;                    if (!super.equals(var1)) {
<b class="fc">&nbsp;                        return false;</b>
<b class="fc">&nbsp;                    } else if (this == var1) {</b>
<b class="fc">&nbsp;                        return true;</b>
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.accessorMethodInvocation.equals(((AccessorMethodDelegation)var1).accessorMethodInvocation);
<b class="fc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return super.hashCode() * 31 + this.accessorMethodInvocation.hashCode();
&nbsp;                }
&nbsp;            }
<b class="fc">&nbsp;</b>
&nbsp;            @Enhance
&nbsp;            protected abstract static class DelegationRecord extends TypeWriter.MethodPool.Record.ForDefinedMethod implements ByteCodeAppender {
&nbsp;                protected final MethodDescription.InDefinedShape methodDescription;
&nbsp;                protected final Visibility visibility;
&nbsp;
&nbsp;                protected DelegationRecord(MethodDescription.InDefinedShape methodDescription, Visibility visibility) {
&nbsp;                    this.methodDescription = methodDescription;
&nbsp;                    this.visibility = visibility;
&nbsp;                }
&nbsp;
&nbsp;                protected abstract DelegationRecord with(MethodAccessorFactory.AccessType var1);
&nbsp;
&nbsp;                public MethodDescription.InDefinedShape getMethod() {
&nbsp;                    return this.methodDescription;
&nbsp;                }
&nbsp;
&nbsp;                public TypeWriter.MethodPool.Record.Sort getSort() {
&nbsp;                    return Sort.IMPLEMENTED;
&nbsp;                }
&nbsp;
&nbsp;                public Visibility getVisibility() {
&nbsp;                    return this.visibility;
&nbsp;                }
&nbsp;
&nbsp;                public void applyHead(MethodVisitor methodVisitor) {
&nbsp;                }
&nbsp;
&nbsp;                public void applyBody(MethodVisitor methodVisitor, Context implementationContext, AnnotationValueFilter.Factory annotationValueFilterFactory) {
&nbsp;                    methodVisitor.visitCode();
&nbsp;                    ByteCodeAppender.Size size = this.applyCode(methodVisitor, implementationContext);
&nbsp;                    methodVisitor.visitMaxs(size.getOperandStackSize(), size.getLocalVariableSize());
&nbsp;                }
&nbsp;
&nbsp;                public void applyAttributes(MethodVisitor methodVisitor, AnnotationValueFilter.Factory annotationValueFilterFactory) {
&nbsp;                }
&nbsp;
&nbsp;                public ByteCodeAppender.Size applyCode(MethodVisitor methodVisitor, Context implementationContext) {
&nbsp;                    return this.apply(methodVisitor, implementationContext, this.getMethod());
&nbsp;                }
&nbsp;
&nbsp;                public TypeWriter.MethodPool.Record prepend(ByteCodeAppender byteCodeAppender) {
&nbsp;                    throw new UnsupportedOperationException(&quot;Cannot prepend code to a delegation for &quot; + this.methodDescription);
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(Object var1) {
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.visibility.equals(((DelegationRecord)var1).visibility)) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.methodDescription.equals(((DelegationRecord)var1).methodDescription);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return (this.getClass().hashCode() * 31 + this.methodDescription.hashCode()) * 31 + this.visibility.hashCode();
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            protected static class FieldSetter extends AbstractPropertyAccessorMethod {
&nbsp;                private final TypeDescription instrumentedType;
&nbsp;                private final FieldDescription fieldDescription;
&nbsp;                private final String name;
&nbsp;
&nbsp;                protected FieldSetter(TypeDescription instrumentedType, FieldDescription fieldDescription, String suffix) {
&nbsp;                    this.instrumentedType = instrumentedType;
&nbsp;                    this.fieldDescription = fieldDescription;
&nbsp;                    this.name = fieldDescription.getName() + &quot;$&quot; + &quot;accessor&quot; + &quot;$&quot; + suffix;
&nbsp;                }
&nbsp;
&nbsp;                public TypeDescription.Generic getReturnType() {
&nbsp;                    return Generic.VOID;
&nbsp;                }
&nbsp;
&nbsp;                public ParameterList&lt;ParameterDescription.InDefinedShape&gt; getParameters() {
&nbsp;                    return new ParameterList.Explicit.ForTypes(this, Collections.singletonList(this.fieldDescription.getType().asRawType()));
&nbsp;                }
&nbsp;
&nbsp;                public TypeList.Generic getExceptionTypes() {
&nbsp;                    return new TypeList.Generic.Empty();
&nbsp;                }
&nbsp;
&nbsp;                @Nonnull(
&nbsp;                    when = When.MAYBE
&nbsp;                )
&nbsp;                public AnnotationValue&lt;?, ?&gt; getDefaultValue() {
&nbsp;                    return AnnotationValue.UNDEFINED;
&nbsp;                }
&nbsp;
&nbsp;                public TypeList.Generic getTypeVariables() {
&nbsp;                    return new TypeList.Generic.Empty();
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationList getDeclaredAnnotations() {
&nbsp;                    return new AnnotationList.Empty();
&nbsp;                }
&nbsp;
&nbsp;                @Nonnull
&nbsp;                public TypeDescription getDeclaringType() {
&nbsp;                    return this.instrumentedType;
&nbsp;                }
&nbsp;
&nbsp;                protected int getBaseModifiers() {
&nbsp;                    return this.fieldDescription.isStatic() ? 8 : 0;
&nbsp;                }
&nbsp;
&nbsp;                public String getInternalName() {
&nbsp;                    return this.name;
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            protected static class FieldGetter extends AbstractPropertyAccessorMethod {
&nbsp;                private final TypeDescription instrumentedType;
&nbsp;                private final FieldDescription fieldDescription;
&nbsp;                private final String name;
&nbsp;
&nbsp;                protected FieldGetter(TypeDescription instrumentedType, FieldDescription fieldDescription, String suffix) {
&nbsp;                    this.instrumentedType = instrumentedType;
&nbsp;                    this.fieldDescription = fieldDescription;
&nbsp;                    this.name = fieldDescription.getName() + &quot;$&quot; + &quot;accessor&quot; + &quot;$&quot; + suffix;
&nbsp;                }
&nbsp;
&nbsp;                public TypeDescription.Generic getReturnType() {
&nbsp;                    return this.fieldDescription.getType().asRawType();
&nbsp;                }
&nbsp;
&nbsp;                public ParameterList&lt;ParameterDescription.InDefinedShape&gt; getParameters() {
&nbsp;                    return new ParameterList.Empty();
&nbsp;                }
&nbsp;
&nbsp;                public TypeList.Generic getExceptionTypes() {
&nbsp;                    return new TypeList.Generic.Empty();
&nbsp;                }
&nbsp;
&nbsp;                @Nonnull(
&nbsp;                    when = When.MAYBE
&nbsp;                )
&nbsp;                public AnnotationValue&lt;?, ?&gt; getDefaultValue() {
&nbsp;                    return AnnotationValue.UNDEFINED;
&nbsp;                }
&nbsp;
&nbsp;                public TypeList.Generic getTypeVariables() {
&nbsp;                    return new TypeList.Generic.Empty();
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationList getDeclaredAnnotations() {
&nbsp;                    return new AnnotationList.Empty();
&nbsp;                }
&nbsp;
&nbsp;                @Nonnull
&nbsp;                public TypeDescription getDeclaringType() {
&nbsp;                    return this.instrumentedType;
&nbsp;                }
&nbsp;
&nbsp;                protected int getBaseModifiers() {
&nbsp;                    return this.fieldDescription.isStatic() ? 8 : 0;
&nbsp;                }
&nbsp;
&nbsp;                public String getInternalName() {
&nbsp;                    return this.name;
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            protected static class AccessorMethod extends AbstractPropertyAccessorMethod {
&nbsp;                private final TypeDescription instrumentedType;
&nbsp;                private final MethodDescription methodDescription;
&nbsp;                private final String name;
&nbsp;
&nbsp;                protected AccessorMethod(TypeDescription instrumentedType, MethodDescription methodDescription, TypeDescription typeDescription, String suffix) {
&nbsp;                    this.instrumentedType = instrumentedType;
&nbsp;                    this.methodDescription = methodDescription;
&nbsp;                    this.name = methodDescription.getInternalName() + &quot;$&quot; + &quot;accessor&quot; + &quot;$&quot; + suffix + (typeDescription.isInterface() ? &quot;$&quot; + RandomString.hashOf(typeDescription.hashCode()) : &quot;&quot;);
&nbsp;                }
&nbsp;
&nbsp;                public TypeDescription.Generic getReturnType() {
&nbsp;                    return this.methodDescription.getReturnType().asRawType();
&nbsp;                }
&nbsp;
&nbsp;                public ParameterList&lt;ParameterDescription.InDefinedShape&gt; getParameters() {
&nbsp;                    return new ParameterList.Explicit.ForTypes(this, this.methodDescription.getParameters().asTypeList().asRawTypes());
&nbsp;                }
&nbsp;
&nbsp;                public TypeList.Generic getExceptionTypes() {
&nbsp;                    return this.methodDescription.getExceptionTypes().asRawTypes();
&nbsp;                }
&nbsp;
&nbsp;                @Nonnull(
&nbsp;                    when = When.MAYBE
&nbsp;                )
&nbsp;                public AnnotationValue&lt;?, ?&gt; getDefaultValue() {
&nbsp;                    return AnnotationValue.UNDEFINED;
&nbsp;                }
&nbsp;
&nbsp;                public TypeList.Generic getTypeVariables() {
&nbsp;                    return new TypeList.Generic.Empty();
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationList getDeclaredAnnotations() {
&nbsp;                    return new AnnotationList.Empty();
&nbsp;                }
&nbsp;
&nbsp;                @Nonnull
&nbsp;                public TypeDescription getDeclaringType() {
&nbsp;                    return this.instrumentedType;
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                protected int getBaseModifiers() {</b>
<b class="fc">&nbsp;                    return this.methodDescription.isStatic() ? 8 : 0;</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                public String getInternalName() {</b>
<b class="fc">&nbsp;                    return this.name;</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;            protected abstract static class AbstractPropertyAccessorMethod extends MethodDescription.InDefinedShape.AbstractBase {</b>
<b class="fc">&nbsp;                protected AbstractPropertyAccessorMethod() {</b>
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                public int getModifiers() {
&nbsp;                    return 4096 | this.getBaseModifiers() | (this.getDeclaringType().isInterface() ? 1 : 16);
&nbsp;                }
&nbsp;
&nbsp;                protected abstract int getBaseModifiers();
&nbsp;            }
&nbsp;
&nbsp;            protected static class FieldCacheEntry implements StackManipulation {
&nbsp;                private final StackManipulation fieldValue;
&nbsp;                private final TypeDescription fieldType;
&nbsp;
&nbsp;                protected FieldCacheEntry(StackManipulation fieldValue, TypeDescription fieldType) {
<b class="fc">&nbsp;                    this.fieldValue = fieldValue;</b>
<b class="fc">&nbsp;                    this.fieldType = fieldType;</b>
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                protected ByteCodeAppender storeIn(FieldDescription fieldDescription) {</b>
<b class="fc">&nbsp;                    return new ByteCodeAppender.Simple(new StackManipulation[]{this, FieldAccess.forField(fieldDescription).write()});</b>
&nbsp;                }
&nbsp;
&nbsp;                protected TypeDescription getFieldType() {
&nbsp;                    return this.fieldType;
&nbsp;                }
&nbsp;
&nbsp;                public boolean isValid() {
&nbsp;                    return this.fieldValue.isValid();
&nbsp;                }
&nbsp;
&nbsp;                public StackManipulation.Size apply(MethodVisitor methodVisitor, Context implementationContext) {
&nbsp;                    return this.fieldValue.apply(methodVisitor, implementationContext);
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    int result = this.fieldValue.hashCode();
&nbsp;                    result = 31 * result + this.fieldType.hashCode();
&nbsp;                    return result;
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(@CheckForNull Object other) {
&nbsp;                    if (this == other) {
&nbsp;                        return true;
&nbsp;                    } else if (other != null &amp;&amp; this.getClass() == other.getClass()) {
&nbsp;                        FieldCacheEntry fieldCacheEntry = (FieldCacheEntry)other;
&nbsp;                        return this.fieldValue.equals(fieldCacheEntry.fieldValue) &amp;&amp; this.fieldType.equals(fieldCacheEntry.fieldType);
&nbsp;                    } else {
&nbsp;                        return false;
&nbsp;                    }
&nbsp;                }
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;            protected static class CacheValueField extends FieldDescription.InDefinedShape.AbstractBase {</b>
&nbsp;                private final TypeDescription instrumentedType;
&nbsp;                private final TypeDescription.Generic fieldType;
<b class="fc">&nbsp;                private final String name;</b>
&nbsp;
<b class="fc">&nbsp;                protected CacheValueField(TypeDescription instrumentedType, TypeDescription.Generic fieldType, String suffix, int hashCode) {</b>
&nbsp;                    this.instrumentedType = instrumentedType;
&nbsp;                    this.fieldType = fieldType;
&nbsp;                    this.name = &quot;cachedValue$&quot; + suffix + &quot;$&quot; + RandomString.hashOf(hashCode);
&nbsp;                }
&nbsp;
&nbsp;                public TypeDescription.Generic getType() {
<b class="fc">&nbsp;                    return this.fieldType;</b>
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationList getDeclaredAnnotations() {
&nbsp;                    return new AnnotationList.Empty();
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                @Nonnull</b>
<b class="fc">&nbsp;                public TypeDescription getDeclaringType() {</b>
<b class="fc">&nbsp;                    return this.instrumentedType;</b>
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                public int getModifiers() {</b>
&nbsp;                    return 4120 | (this.instrumentedType.isInterface() ? 1 : 2);
&nbsp;                }
<b class="fc">&nbsp;</b>
&nbsp;                public String getName() {
<b class="fc">&nbsp;                    return this.name;</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        public static class Disabled extends ExtractableView.AbstractBase {
&nbsp;            protected Disabled(TypeDescription instrumentedType, ClassFileVersion classFileVersion) {
&nbsp;                super(instrumentedType, classFileVersion);
&nbsp;            }
&nbsp;
&nbsp;            public boolean isEnabled() {
&nbsp;                return false;
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;            public List&lt;DynamicType&gt; getAuxiliaryTypes() {</b>
<b class="fc">&nbsp;                return Collections.emptyList();</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;            public void drain(TypeInitializer.Drain drain, ClassVisitor classVisitor, AnnotationValueFilter.Factory annotationValueFilterFactory) {</b>
&nbsp;                drain.apply(classVisitor, None.INSTANCE, this);
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;            public TypeDescription register(AuxiliaryType auxiliaryType) {</b>
&nbsp;                throw new IllegalStateException(&quot;Registration of auxiliary types was disabled: &quot; + auxiliaryType);
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;            public MethodDescription.InDefinedShape registerAccessorFor(SpecialMethodInvocation specialMethodInvocation, MethodAccessorFactory.AccessType accessType) {</b>
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;Registration of method accessors was disabled: &quot; + specialMethodInvocation.getMethodDescription());</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;</b>
&nbsp;            public MethodDescription.InDefinedShape registerGetterFor(FieldDescription fieldDescription, MethodAccessorFactory.AccessType accessType) {
&nbsp;                throw new IllegalStateException(&quot;Registration of field accessor was disabled: &quot; + fieldDescription);
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            public MethodDescription.InDefinedShape registerSetterFor(FieldDescription fieldDescription, MethodAccessorFactory.AccessType accessType) {
&nbsp;                throw new IllegalStateException(&quot;Registration of field accessor was disabled: &quot; + fieldDescription);
&nbsp;            }
&nbsp;
&nbsp;            public FieldDescription.InDefinedShape cache(StackManipulation fieldValue, TypeDescription fieldType) {
&nbsp;                throw new IllegalStateException(&quot;Field values caching was disabled: &quot; + fieldType);
&nbsp;            }
&nbsp;
&nbsp;            public static enum Factory implements Factory {
&nbsp;                INSTANCE;
&nbsp;
&nbsp;                private Factory() {
&nbsp;                }
&nbsp;
&nbsp;                public ExtractableView make(TypeDescription instrumentedType, AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy, TypeInitializer typeInitializer, ClassFileVersion classFileVersion, ClassFileVersion auxiliaryClassFileVersion) {
&nbsp;                    if (typeInitializer.isDefined()) {
&nbsp;                        throw new IllegalStateException(&quot;Cannot define type initializer which was explicitly disabled: &quot; + typeInitializer);
&nbsp;                    } else {
&nbsp;                        return new Disabled(instrumentedType, classFileVersion);
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public interface Factory {
&nbsp;            ExtractableView make(TypeDescription var1, AuxiliaryType.NamingStrategy var2, TypeInitializer var3, ClassFileVersion var4, ClassFileVersion var5);
&nbsp;        }
&nbsp;
&nbsp;        public interface ExtractableView extends Context {
&nbsp;            boolean isEnabled();
&nbsp;
<b class="fc">&nbsp;            List&lt;DynamicType&gt; getAuxiliaryTypes();</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;            void drain(TypeInitializer.Drain var1, ClassVisitor var2, AnnotationValueFilter.Factory var3);</b>
<b class="fc">&nbsp;</b>
&nbsp;            @Enhance
&nbsp;            public abstract static class AbstractBase implements ExtractableView {
&nbsp;                protected final TypeDescription instrumentedType;
&nbsp;                protected final ClassFileVersion classFileVersion;
&nbsp;
&nbsp;                protected AbstractBase(TypeDescription instrumentedType, ClassFileVersion classFileVersion) {
<b class="fc">&nbsp;                    this.instrumentedType = instrumentedType;</b>
&nbsp;                    this.classFileVersion = classFileVersion;
&nbsp;                }
&nbsp;
&nbsp;                public TypeDescription getInstrumentedType() {
&nbsp;                    return this.instrumentedType;
&nbsp;                }
&nbsp;
&nbsp;                public ClassFileVersion getClassFileVersion() {
&nbsp;                    return this.classFileVersion;
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(Object var1) {
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
<b class="fc">&nbsp;                    } else if (var1 == null) {</b>
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.instrumentedType.equals(((AbstractBase)var1).instrumentedType)) {
&nbsp;                        return false;
&nbsp;                    } else {
<b class="fc">&nbsp;                        return this.classFileVersion.equals(((AbstractBase)var1).classFileVersion);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return (this.getClass().hashCode() * 31 + this.instrumentedType.hashCode()) * 31 + this.classFileVersion.hashCode();
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    public interface Target {
&nbsp;        TypeDescription getInstrumentedType();
&nbsp;
&nbsp;        TypeDefinition getOriginType();
&nbsp;
&nbsp;        SpecialMethodInvocation invokeSuper(MethodDescription.SignatureToken var1);
&nbsp;
&nbsp;        SpecialMethodInvocation invokeDefault(MethodDescription.SignatureToken var1);
&nbsp;
&nbsp;        SpecialMethodInvocation invokeDefault(MethodDescription.SignatureToken var1, TypeDescription var2);
&nbsp;
&nbsp;        SpecialMethodInvocation invokeDominant(MethodDescription.SignatureToken var1);
&nbsp;
&nbsp;        @Enhance
&nbsp;        public abstract static class AbstractBase implements Target {
&nbsp;            protected final TypeDescription instrumentedType;
&nbsp;            protected final MethodGraph.Linked methodGraph;
&nbsp;            protected final DefaultMethodInvocation defaultMethodInvocation;
&nbsp;
&nbsp;            protected AbstractBase(TypeDescription instrumentedType, MethodGraph.Linked methodGraph, DefaultMethodInvocation defaultMethodInvocation) {
&nbsp;                this.instrumentedType = instrumentedType;
&nbsp;                this.methodGraph = methodGraph;
&nbsp;                this.defaultMethodInvocation = defaultMethodInvocation;
&nbsp;            }
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;            public TypeDescription getInstrumentedType() {</b>
<b class="fc">&nbsp;                return this.instrumentedType;</b>
&nbsp;            }
&nbsp;
&nbsp;            public SpecialMethodInvocation invokeDefault(MethodDescription.SignatureToken token) {
&nbsp;                SpecialMethodInvocation specialMethodInvocation = Implementation.SpecialMethodInvocation.Illegal.INSTANCE;
&nbsp;                Iterator var3 = this.instrumentedType.getInterfaces().asErasures().iterator();
&nbsp;
&nbsp;                while(var3.hasNext()) {
&nbsp;                    TypeDescription interfaceType = (TypeDescription)var3.next();
&nbsp;                    SpecialMethodInvocation invocation = this.invokeDefault(token, interfaceType).withCheckedCompatibilityTo(token.asTypeToken());
<b class="fc">&nbsp;                    if (invocation.isValid()) {</b>
&nbsp;                        if (((SpecialMethodInvocation)specialMethodInvocation).isValid()) {
&nbsp;                            return Implementation.SpecialMethodInvocation.Illegal.INSTANCE;
&nbsp;                        }
&nbsp;
&nbsp;                        specialMethodInvocation = invocation;
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                return (SpecialMethodInvocation)specialMethodInvocation;
&nbsp;            }
&nbsp;
&nbsp;            public SpecialMethodInvocation invokeDefault(MethodDescription.SignatureToken token, TypeDescription targetType) {
&nbsp;                return this.defaultMethodInvocation.apply(this.methodGraph.getInterfaceGraph(targetType).locate(token), targetType);
&nbsp;            }
&nbsp;
&nbsp;            public SpecialMethodInvocation invokeDominant(MethodDescription.SignatureToken token) {
&nbsp;                SpecialMethodInvocation specialMethodInvocation = this.invokeSuper(token);
&nbsp;                return specialMethodInvocation.isValid() ? specialMethodInvocation : this.invokeDefault(token);
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(Object var1) {
&nbsp;                if (this == var1) {
<b class="fc">&nbsp;                    return true;</b>
&nbsp;                } else if (var1 == null) {
&nbsp;                    return false;
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
<b class="fc">&nbsp;                } else if (!this.defaultMethodInvocation.equals(((AbstractBase)var1).defaultMethodInvocation)) {</b>
<b class="fc">&nbsp;                    return false;</b>
<b class="fc">&nbsp;                } else if (!this.instrumentedType.equals(((AbstractBase)var1).instrumentedType)) {</b>
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return this.methodGraph.equals(((AbstractBase)var1).methodGraph);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public int hashCode() {
&nbsp;                return ((this.getClass().hashCode() * 31 + this.instrumentedType.hashCode()) * 31 + this.methodGraph.hashCode()) * 31 + this.defaultMethodInvocation.hashCode();
&nbsp;            }
&nbsp;
&nbsp;            protected static enum DefaultMethodInvocation {
&nbsp;                ENABLED {
&nbsp;                    protected SpecialMethodInvocation apply(MethodGraph.Node node, TypeDescription targetType) {
&nbsp;                        return (SpecialMethodInvocation)(node.getSort().isUnique() ? Implementation.SpecialMethodInvocation.Simple.of(node.getRepresentative(), targetType) : Implementation.SpecialMethodInvocation.Illegal.INSTANCE);
&nbsp;                    }
&nbsp;                },
&nbsp;                DISABLED {
<b class="fc">&nbsp;                    protected SpecialMethodInvocation apply(MethodGraph.Node node, TypeDescription targetType) {</b>
&nbsp;                        return Implementation.SpecialMethodInvocation.Illegal.INSTANCE;
&nbsp;                    }
&nbsp;                };
&nbsp;
&nbsp;                private DefaultMethodInvocation() {
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                public static DefaultMethodInvocation of(ClassFileVersion classFileVersion) {
&nbsp;                    return classFileVersion.isAtLeast(ClassFileVersion.JAVA_V8) ? ENABLED : DISABLED;
&nbsp;                }
&nbsp;
&nbsp;                protected abstract SpecialMethodInvocation apply(MethodGraph.Node var1, TypeDescription var2);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public interface Factory {
&nbsp;            Target make(TypeDescription var1, MethodGraph.Linked var2, ClassFileVersion var3);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public interface SpecialMethodInvocation extends StackManipulation {
&nbsp;        MethodDescription getMethodDescription();
&nbsp;
&nbsp;        TypeDescription getTypeDescription();
&nbsp;
&nbsp;        SpecialMethodInvocation withCheckedCompatibilityTo(MethodDescription.TypeToken var1);
&nbsp;
&nbsp;        public static class Simple extends AbstractBase {
&nbsp;            private final MethodDescription methodDescription;
&nbsp;            private final TypeDescription typeDescription;
&nbsp;            private final StackManipulation stackManipulation;
&nbsp;
&nbsp;            protected Simple(MethodDescription methodDescription, TypeDescription typeDescription, StackManipulation stackManipulation) {
&nbsp;                this.methodDescription = methodDescription;
&nbsp;                this.typeDescription = typeDescription;
&nbsp;                this.stackManipulation = stackManipulation;
&nbsp;            }
&nbsp;
&nbsp;            public static SpecialMethodInvocation of(MethodDescription methodDescription, TypeDescription typeDescription) {
&nbsp;                StackManipulation stackManipulation = MethodInvocation.invoke(methodDescription).special(typeDescription);
&nbsp;                return (SpecialMethodInvocation)(stackManipulation.isValid() ? new Simple(methodDescription, typeDescription, stackManipulation) : Implementation.SpecialMethodInvocation.Illegal.INSTANCE);
&nbsp;            }
&nbsp;
&nbsp;            public MethodDescription getMethodDescription() {
&nbsp;                return this.methodDescription;
&nbsp;            }
&nbsp;
&nbsp;            public TypeDescription getTypeDescription() {
&nbsp;                return this.typeDescription;
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;            public StackManipulation.Size apply(MethodVisitor methodVisitor, Context implementationContext) {</b>
<b class="fc">&nbsp;                return this.stackManipulation.apply(methodVisitor, implementationContext);</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            public SpecialMethodInvocation withCheckedCompatibilityTo(MethodDescription.TypeToken token) {</b>
&nbsp;                return (SpecialMethodInvocation)(this.methodDescription.asTypeToken().equals(token) ? this : Implementation.SpecialMethodInvocation.Illegal.INSTANCE);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public abstract static class AbstractBase extends StackManipulation.AbstractBase implements SpecialMethodInvocation {
&nbsp;            public AbstractBase() {
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            @net.bytebuddy.build.CachedReturnPlugin.Enhance(&quot;hashCode&quot;)
&nbsp;            public int hashCode() {
&nbsp;                int var1 = this.hashCode;
&nbsp;                int var2 = var1 != 0 ? 0 : 31 * this.getMethodDescription().asSignatureToken().hashCode() + this.getTypeDescription().hashCode();
&nbsp;                if (var2 == 0) {
<b class="fc">&nbsp;                    var2 = this.hashCode;</b>
&nbsp;                } else {
&nbsp;                    this.hashCode = var2;
&nbsp;                }
&nbsp;
&nbsp;                return var2;
&nbsp;            }
<b class="fc">&nbsp;</b>
&nbsp;            public boolean equals(@CheckForNull Object other) {
&nbsp;                if (this == other) {
&nbsp;                    return true;
&nbsp;                } else if (!(other instanceof SpecialMethodInvocation)) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    SpecialMethodInvocation specialMethodInvocation = (SpecialMethodInvocation)other;
&nbsp;                    return this.getMethodDescription().asSignatureToken().equals(specialMethodInvocation.getMethodDescription().asSignatureToken()) &amp;&amp; this.getTypeDescription().equals(specialMethodInvocation.getTypeDescription());
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public static enum Illegal implements SpecialMethodInvocation {
&nbsp;            INSTANCE;
<b class="fc">&nbsp;</b>
&nbsp;            private Illegal() {
&nbsp;            }
&nbsp;
&nbsp;            public boolean isValid() {
&nbsp;                return false;
&nbsp;            }
<b class="fc">&nbsp;</b>
&nbsp;            public StackManipulation.Size apply(MethodVisitor methodVisitor, Context implementationContext) {
&nbsp;                throw new IllegalStateException(&quot;Cannot implement an undefined method&quot;);
&nbsp;            }
&nbsp;
&nbsp;            public MethodDescription getMethodDescription() {
&nbsp;                throw new IllegalStateException(&quot;An illegal special method invocation must not be applied&quot;);
&nbsp;            }
<b class="fc">&nbsp;</b>
&nbsp;            public TypeDescription getTypeDescription() {
&nbsp;                throw new IllegalStateException(&quot;An illegal special method invocation must not be applied&quot;);
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            public SpecialMethodInvocation withCheckedCompatibilityTo(MethodDescription.TypeToken token) {</b>
&nbsp;                return this;
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public interface Composable extends Implementation {
&nbsp;        Implementation andThen(Implementation var1);
&nbsp;
<b class="fc">&nbsp;        Composable andThen(Composable var1);</b>
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-22 12:48</div>
</div>
</body>
</html>
