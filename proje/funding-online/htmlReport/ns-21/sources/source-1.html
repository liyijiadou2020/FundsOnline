


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=GBK"> 
  <title>Coverage Report > MethodDescription</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.description.method</a>
</div>

<h1>Coverage Summary for Class: MethodDescription (net.bytebuddy.description.method)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">MethodDescription</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
</tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (10/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (59/59)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$ForLoadedConstructor</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (13/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$ForLoadedMethod</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (20/20)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$InDefinedShape$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$InDefinedShape$AbstractBase$ForLoadedExecutable</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$Latent</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (31/31)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$Latent$TypeInitializer</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (10/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$SignatureToken</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (17/17)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$Token</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (36/36)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$TypeSubstituting</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (20/20)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$TypeToken</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (11/11)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (30/30)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (231/231)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;//
&nbsp;// Source code recreated from a .class file by IntelliJ IDEA
&nbsp;// (powered by FernFlower decompiler)
&nbsp;//
&nbsp;
&nbsp;package net.bytebuddy.description.method;
&nbsp;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import java.lang.annotation.Annotation;
&nbsp;import java.lang.reflect.AnnotatedElement;
&nbsp;import java.lang.reflect.Constructor;
&nbsp;import java.lang.reflect.GenericDeclaration;
&nbsp;import java.lang.reflect.GenericSignatureFormatError;
&nbsp;import java.lang.reflect.Method;
&nbsp;import java.lang.reflect.Modifier;
&nbsp;import java.security.AccessController;
&nbsp;import java.security.PrivilegedAction;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Collections;
&nbsp;import java.util.Iterator;
&nbsp;import java.util.List;
&nbsp;import javax.annotation.CheckForNull;
&nbsp;import javax.annotation.Nonnull;
&nbsp;import javax.annotation.meta.When;
&nbsp;import net.bytebuddy.build.CachedReturnPlugin.Enhance;
&nbsp;import net.bytebuddy.description.ByteCodeElement;
&nbsp;import net.bytebuddy.description.DeclaredByType;
&nbsp;import net.bytebuddy.description.ModifierReviewable;
&nbsp;import net.bytebuddy.description.NamedElement;
&nbsp;import net.bytebuddy.description.TypeVariableSource;
&nbsp;import net.bytebuddy.description.annotation.AnnotationDescription;
&nbsp;import net.bytebuddy.description.annotation.AnnotationList;
&nbsp;import net.bytebuddy.description.annotation.AnnotationValue;
&nbsp;import net.bytebuddy.description.annotation.AnnotationDescription.ForLoadedAnnotation;
&nbsp;import net.bytebuddy.description.enumeration.EnumerationDescription;
&nbsp;import net.bytebuddy.description.modifier.Visibility;
&nbsp;import net.bytebuddy.description.modifier.ModifierContributor.Resolver;
&nbsp;import net.bytebuddy.description.type.TypeDefinition;
&nbsp;import net.bytebuddy.description.type.TypeDescription;
&nbsp;import net.bytebuddy.description.type.TypeList;
&nbsp;import net.bytebuddy.description.type.TypeVariableToken;
&nbsp;import net.bytebuddy.description.type.TypeDefinition.Sort;
&nbsp;import net.bytebuddy.description.type.TypeDescription.ForLoadedType;
&nbsp;import net.bytebuddy.description.type.TypeDescription.Generic;
&nbsp;import net.bytebuddy.description.type.TypeDescription.Generic.OfParameterizedType.ForGenerifiedErasure;
&nbsp;import net.bytebuddy.description.type.TypeDescription.Generic.Visitor.Substitutor.ForAttachment;
&nbsp;import net.bytebuddy.description.type.TypeList.Generic.ForDetachedTypes;
&nbsp;import net.bytebuddy.description.type.TypeList.Generic.ForLoadedTypes.OfTypeVariables;
&nbsp;import net.bytebuddy.jar.asm.Type;
&nbsp;import net.bytebuddy.jar.asm.signature.SignatureWriter;
&nbsp;import net.bytebuddy.matcher.ElementMatcher;
&nbsp;import net.bytebuddy.matcher.ElementMatchers;
&nbsp;import net.bytebuddy.utility.JavaType;
&nbsp;import net.bytebuddy.utility.dispatcher.JavaDispatcher;
&nbsp;import net.bytebuddy.utility.dispatcher.JavaDispatcher.Defaults;
&nbsp;import net.bytebuddy.utility.dispatcher.JavaDispatcher.Proxied;
&nbsp;
&nbsp;public interface MethodDescription extends TypeVariableSource, DeclaredByType.WithMandatoryDeclaration, ModifierReviewable.ForMethodDescription, NamedElement.WithGenericName, ByteCodeElement, ByteCodeElement.TypeDependant&lt;InDefinedShape, Token&gt; {
&nbsp;    String CONSTRUCTOR_INTERNAL_NAME = &quot;&lt;init&gt;&quot;;
&nbsp;    String TYPE_INITIALIZER_INTERNAL_NAME = &quot;&lt;clinit&gt;&quot;;
&nbsp;    int TYPE_INITIALIZER_MODIFIER = 8;
&nbsp;    @Nonnull(
&nbsp;        when = When.NEVER
&nbsp;    )
&nbsp;    InDefinedShape UNDEFINED = null;
&nbsp;
&nbsp;    TypeDescription.Generic getReturnType();
&nbsp;
&nbsp;    ParameterList&lt;?&gt; getParameters();
&nbsp;
&nbsp;    TypeList.Generic getExceptionTypes();
&nbsp;
&nbsp;    int getActualModifiers();
&nbsp;
&nbsp;    int getActualModifiers(boolean var1);
&nbsp;
&nbsp;    int getActualModifiers(boolean var1, Visibility var2);
&nbsp;
&nbsp;    boolean isConstructor();
<b class="fc">&nbsp;</b>
&nbsp;    boolean isMethod();
&nbsp;
&nbsp;    boolean isTypeInitializer();
&nbsp;
&nbsp;    boolean represents(Method var1);
&nbsp;
&nbsp;    boolean represents(Constructor&lt;?&gt; var1);
&nbsp;
&nbsp;    boolean isVirtual();
&nbsp;
&nbsp;    int getStackSize();
&nbsp;
&nbsp;    boolean isDefaultMethod();
&nbsp;
&nbsp;    boolean isSpecializableFor(TypeDescription var1);
&nbsp;
&nbsp;    @Nonnull(
&nbsp;        when = When.MAYBE
&nbsp;    )
&nbsp;    AnnotationValue&lt;?, ?&gt; getDefaultValue();
&nbsp;
&nbsp;    @Nonnull(
&nbsp;        when = When.MAYBE
&nbsp;    )
&nbsp;    &lt;T&gt; T getDefaultValue(Class&lt;T&gt; var1);
&nbsp;
&nbsp;    boolean isInvokableOn(TypeDescription var1);
&nbsp;
&nbsp;    boolean isInvokeBootstrap();
&nbsp;
&nbsp;    boolean isInvokeBootstrap(List&lt;? extends TypeDefinition&gt; var1);
&nbsp;
&nbsp;    boolean isConstantBootstrap();
&nbsp;
&nbsp;    boolean isConstantBootstrap(List&lt;? extends TypeDefinition&gt; var1);
&nbsp;
&nbsp;    boolean isDefaultValue();
&nbsp;
&nbsp;    boolean isDefaultValue(AnnotationValue&lt;?, ?&gt; var1);
&nbsp;
&nbsp;    @Nonnull(
&nbsp;        when = When.MAYBE
&nbsp;    )
&nbsp;    TypeDescription.Generic getReceiverType();
&nbsp;
&nbsp;    SignatureToken asSignatureToken();
&nbsp;
&nbsp;    TypeToken asTypeToken();
&nbsp;
&nbsp;    boolean isBridgeCompatible(TypeToken var1);
&nbsp;
&nbsp;    public static class TypeToken {
&nbsp;        private final TypeDescription returnType;
&nbsp;        private final List&lt;? extends TypeDescription&gt; parameterTypes;
&nbsp;
&nbsp;        public TypeToken(TypeDescription returnType, List&lt;? extends TypeDescription&gt; parameterTypes) {
&nbsp;            this.returnType = returnType;
&nbsp;            this.parameterTypes = parameterTypes;
&nbsp;        }
&nbsp;
&nbsp;        public TypeDescription getReturnType() {
&nbsp;            return this.returnType;
&nbsp;        }
&nbsp;
&nbsp;        public List&lt;TypeDescription&gt; getParameterTypes() {
&nbsp;            return this.parameterTypes;
&nbsp;        }
&nbsp;
&nbsp;        @Enhance(&quot;hashCode&quot;)
&nbsp;        public int hashCode() {
&nbsp;            int var1 = this.hashCode;
&nbsp;            int var10000;
&nbsp;            if (var1 != 0) {
&nbsp;                var10000 = 0;
&nbsp;            } else {
&nbsp;                int result = this.returnType.hashCode();
&nbsp;                result = 31 * result + this.parameterTypes.hashCode();
&nbsp;                var10000 = result;
&nbsp;            }
&nbsp;
&nbsp;            int var2 = var10000;
&nbsp;            if (var2 == 0) {
&nbsp;                var2 = this.hashCode;
&nbsp;            } else {
&nbsp;                this.hashCode = var2;
&nbsp;            }
&nbsp;
&nbsp;            return var2;
&nbsp;        }
&nbsp;
&nbsp;        public boolean equals(@CheckForNull Object other) {
&nbsp;            if (this == other) {
&nbsp;                return true;
&nbsp;            } else if (!(other instanceof TypeToken)) {
&nbsp;                return false;
&nbsp;            } else {
&nbsp;                TypeToken typeToken = (TypeToken)other;
&nbsp;                return this.returnType.equals(typeToken.returnType) &amp;&amp; this.parameterTypes.equals(typeToken.parameterTypes);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public String toString() {
&nbsp;            StringBuilder stringBuilder = (new StringBuilder()).append(&#39;(&#39;);
&nbsp;            Iterator var2 = this.parameterTypes.iterator();
&nbsp;
&nbsp;            while(var2.hasNext()) {
&nbsp;                TypeDescription parameterType = (TypeDescription)var2.next();
&nbsp;                stringBuilder.append(parameterType.getDescriptor());
&nbsp;            }
&nbsp;
&nbsp;            return stringBuilder.append(&#39;)&#39;).append(this.returnType.getDescriptor()).toString();
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static class SignatureToken {
&nbsp;        private final String name;
&nbsp;        private final TypeDescription returnType;
&nbsp;        private final List&lt;? extends TypeDescription&gt; parameterTypes;
&nbsp;
&nbsp;        public SignatureToken(String name, TypeDescription returnType, TypeDescription... parameterType) {
&nbsp;            this(name, returnType, Arrays.asList(parameterType));
&nbsp;        }
&nbsp;
&nbsp;        public SignatureToken(String name, TypeDescription returnType, List&lt;? extends TypeDescription&gt; parameterTypes) {
&nbsp;            this.name = name;
&nbsp;            this.returnType = returnType;
&nbsp;            this.parameterTypes = parameterTypes;
&nbsp;        }
&nbsp;
&nbsp;        public String getName() {
&nbsp;            return this.name;
&nbsp;        }
&nbsp;
&nbsp;        public TypeDescription getReturnType() {
&nbsp;            return this.returnType;
&nbsp;        }
&nbsp;
&nbsp;        public List&lt;TypeDescription&gt; getParameterTypes() {
&nbsp;            return this.parameterTypes;
&nbsp;        }
&nbsp;
&nbsp;        public TypeToken asTypeToken() {
&nbsp;            return new TypeToken(this.returnType, this.parameterTypes);
&nbsp;        }
&nbsp;
&nbsp;        public String getDescriptor() {
&nbsp;            StringBuilder stringBuilder = (new StringBuilder()).append(&#39;(&#39;);
&nbsp;            Iterator var2 = this.parameterTypes.iterator();
&nbsp;
&nbsp;            while(var2.hasNext()) {
&nbsp;                TypeDescription typeDescription = (TypeDescription)var2.next();
&nbsp;                stringBuilder.append(typeDescription.getDescriptor());
&nbsp;            }
&nbsp;
&nbsp;            return stringBuilder.append(&#39;)&#39;).append(this.returnType.getDescriptor()).toString();
&nbsp;        }
&nbsp;
&nbsp;        @Enhance(&quot;hashCode&quot;)
&nbsp;        public int hashCode() {
&nbsp;            int var1 = this.hashCode;
&nbsp;            int var10000;
&nbsp;            if (var1 != 0) {
&nbsp;                var10000 = 0;
&nbsp;            } else {
&nbsp;                int result = this.name.hashCode();
&nbsp;                result = 31 * result + this.returnType.hashCode();
&nbsp;                result = 31 * result + this.parameterTypes.hashCode();
&nbsp;                var10000 = result;
&nbsp;            }
&nbsp;
&nbsp;            int var2 = var10000;
&nbsp;            if (var2 == 0) {
&nbsp;                var2 = this.hashCode;
&nbsp;            } else {
&nbsp;                this.hashCode = var2;
&nbsp;            }
&nbsp;
&nbsp;            return var2;
&nbsp;        }
&nbsp;
&nbsp;        public boolean equals(@CheckForNull Object other) {
&nbsp;            if (this == other) {
&nbsp;                return true;
&nbsp;            } else if (!(other instanceof SignatureToken)) {
&nbsp;                return false;
&nbsp;            } else {
&nbsp;                SignatureToken signatureToken = (SignatureToken)other;
&nbsp;                return this.name.equals(signatureToken.name) &amp;&amp; this.returnType.equals(signatureToken.returnType) &amp;&amp; this.parameterTypes.equals(signatureToken.parameterTypes);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public String toString() {
&nbsp;            StringBuilder stringBuilder = (new StringBuilder()).append(this.returnType).append(&#39; &#39;).append(this.name).append(&#39;(&#39;);
&nbsp;            boolean first = true;
&nbsp;
&nbsp;            TypeDescription parameterType;
&nbsp;            for(Iterator var3 = this.parameterTypes.iterator(); var3.hasNext(); stringBuilder.append(parameterType)) {
&nbsp;                parameterType = (TypeDescription)var3.next();
&nbsp;                if (first) {
&nbsp;                    first = false;
&nbsp;                } else {
&nbsp;                    stringBuilder.append(&#39;,&#39;);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            return stringBuilder.append(&#39;)&#39;).toString();
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static class Token implements ByteCodeElement.Token&lt;Token&gt; {
&nbsp;        private final String name;
&nbsp;        private final int modifiers;
&nbsp;        private final List&lt;? extends TypeVariableToken&gt; typeVariableTokens;
&nbsp;        private final TypeDescription.Generic returnType;
&nbsp;        private final List&lt;? extends ParameterDescription.Token&gt; parameterTokens;
&nbsp;        private final List&lt;? extends TypeDescription.Generic&gt; exceptionTypes;
&nbsp;        private final List&lt;? extends AnnotationDescription&gt; annotations;
&nbsp;        @Nonnull(
&nbsp;            when = When.MAYBE
&nbsp;        )
&nbsp;        private final AnnotationValue&lt;?, ?&gt; defaultValue;
&nbsp;        @Nonnull(
&nbsp;            when = When.MAYBE
&nbsp;        )
&nbsp;        private final TypeDescription.Generic receiverType;
&nbsp;
&nbsp;        public Token(int modifiers) {
&nbsp;            this(&quot;&lt;init&gt;&quot;, modifiers, Generic.VOID);
&nbsp;        }
&nbsp;
&nbsp;        public Token(String name, int modifiers, TypeDescription.Generic returnType) {
&nbsp;            this(name, modifiers, returnType, Collections.emptyList());
&nbsp;        }
&nbsp;
&nbsp;        public Token(String name, int modifiers, TypeDescription.Generic returnType, List&lt;? extends TypeDescription.Generic&gt; parameterTypes) {
&nbsp;            this(name, modifiers, Collections.emptyList(), returnType, new ParameterDescription.TypeList(parameterTypes), Collections.emptyList(), Collections.emptyList(), AnnotationValue.UNDEFINED, Generic.UNDEFINED);
&nbsp;        }
&nbsp;
&nbsp;        public Token(String name, int modifiers, List&lt;? extends TypeVariableToken&gt; typeVariableTokens, TypeDescription.Generic returnType, List&lt;? extends ParameterDescription.Token&gt; parameterTokens, List&lt;? extends TypeDescription.Generic&gt; exceptionTypes, List&lt;? extends AnnotationDescription&gt; annotations, @Nonnull(when = When.MAYBE) AnnotationValue&lt;?, ?&gt; defaultValue, @Nonnull(when = When.MAYBE) TypeDescription.Generic receiverType) {
&nbsp;            this.name = name;
&nbsp;            this.modifiers = modifiers;
&nbsp;            this.typeVariableTokens = typeVariableTokens;
&nbsp;            this.returnType = returnType;
&nbsp;            this.parameterTokens = parameterTokens;
&nbsp;            this.exceptionTypes = exceptionTypes;
&nbsp;            this.annotations = annotations;
&nbsp;            this.defaultValue = defaultValue;
&nbsp;            this.receiverType = receiverType;
&nbsp;        }
&nbsp;
&nbsp;        public String getName() {
&nbsp;            return this.name;
&nbsp;        }
&nbsp;
&nbsp;        public int getModifiers() {
&nbsp;            return this.modifiers;
&nbsp;        }
&nbsp;
&nbsp;        public ByteCodeElement.TokenList&lt;TypeVariableToken&gt; getTypeVariableTokens() {
&nbsp;            return new ByteCodeElement.TokenList(this.typeVariableTokens);
&nbsp;        }
<b class="fc">&nbsp;</b>
&nbsp;        public TypeDescription.Generic getReturnType() {
&nbsp;            return this.returnType;
&nbsp;        }
&nbsp;
&nbsp;        public ByteCodeElement.TokenList&lt;ParameterDescription.Token&gt; getParameterTokens() {
<b class="fc">&nbsp;            return new ByteCodeElement.TokenList(this.parameterTokens);</b>
&nbsp;        }
&nbsp;
&nbsp;        public TypeList.Generic getExceptionTypes() {
&nbsp;            return new TypeList.Generic.Explicit(this.exceptionTypes);
&nbsp;        }
&nbsp;
&nbsp;        public AnnotationList getAnnotations() {
<b class="fc">&nbsp;            return new AnnotationList.Explicit(this.annotations);</b>
&nbsp;        }
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;        @Nonnull(</b>
<b class="fc">&nbsp;            when = When.MAYBE</b>
<b class="fc">&nbsp;        )</b>
&nbsp;        public AnnotationValue&lt;?, ?&gt; getDefaultValue() {
&nbsp;            return this.defaultValue;
&nbsp;        }
&nbsp;
&nbsp;        @Nonnull(
&nbsp;            when = When.MAYBE
&nbsp;        )
&nbsp;        public TypeDescription.Generic getReceiverType() {
&nbsp;            return this.receiverType;
&nbsp;        }
&nbsp;
&nbsp;        public Token accept(TypeDescription.Generic.Visitor&lt;? extends TypeDescription.Generic&gt; visitor) {
&nbsp;            return new Token(this.name, this.modifiers, this.getTypeVariableTokens().accept(visitor), (TypeDescription.Generic)this.returnType.accept(visitor), this.getParameterTokens().accept(visitor), this.getExceptionTypes().accept(visitor), this.annotations, this.defaultValue, this.receiverType == null ? Generic.UNDEFINED : (TypeDescription.Generic)this.receiverType.accept(visitor));
&nbsp;        }
&nbsp;
&nbsp;        public SignatureToken asSignatureToken(TypeDescription declaringType) {
&nbsp;            TypeDescription.Generic.Visitor&lt;TypeDescription&gt; visitor = new TypeDescription.Generic.Visitor.Reducing(declaringType, this.typeVariableTokens);
&nbsp;            List&lt;TypeDescription&gt; parameters = new ArrayList(this.parameterTokens.size());
&nbsp;            Iterator var4 = this.parameterTokens.iterator();
&nbsp;
<b class="fc">&nbsp;            while(var4.hasNext()) {</b>
&nbsp;                ParameterDescription.Token parameter = (ParameterDescription.Token)var4.next();
&nbsp;                parameters.add(parameter.getType().accept(visitor));
&nbsp;            }
&nbsp;
&nbsp;            return new SignatureToken(this.name, (TypeDescription)this.returnType.accept(visitor), parameters);
&nbsp;        }
&nbsp;
&nbsp;        @Enhance(&quot;hashCode&quot;)
&nbsp;        public int hashCode() {
&nbsp;            int var1 = this.hashCode;
&nbsp;            int var10000;
<b class="fc">&nbsp;            if (var1 != 0) {</b>
<b class="fc">&nbsp;                var10000 = 0;</b>
&nbsp;            } else {
&nbsp;                int result = this.name.hashCode();
&nbsp;                result = 31 * result + this.modifiers;
&nbsp;                result = 31 * result + this.typeVariableTokens.hashCode();
&nbsp;                result = 31 * result + this.returnType.hashCode();
&nbsp;                result = 31 * result + this.parameterTokens.hashCode();
&nbsp;                result = 31 * result + this.exceptionTypes.hashCode();
&nbsp;                result = 31 * result + this.annotations.hashCode();
&nbsp;                result = 31 * result + (this.defaultValue != null ? this.defaultValue.hashCode() : 0);
&nbsp;                result = 31 * result + (this.receiverType != null ? this.receiverType.hashCode() : 0);
&nbsp;                var10000 = result;
&nbsp;            }
&nbsp;
&nbsp;            int var2 = var10000;
&nbsp;            if (var2 == 0) {
&nbsp;                var2 = this.hashCode;
&nbsp;            } else {
&nbsp;                this.hashCode = var2;
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;</b>
&nbsp;            return var2;
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        public boolean equals(@CheckForNull Object other) {
&nbsp;            if (this == other) {
&nbsp;                return true;
&nbsp;            } else if (other != null &amp;&amp; this.getClass() == other.getClass()) {
&nbsp;                boolean var10000;
&nbsp;                label74: {
&nbsp;                    Token token = (Token)other;
&nbsp;                    if (this.modifiers == token.modifiers &amp;&amp; this.name.equals(token.name) &amp;&amp; this.typeVariableTokens.equals(token.typeVariableTokens) &amp;&amp; this.returnType.equals(token.returnType) &amp;&amp; this.parameterTokens.equals(token.parameterTokens) &amp;&amp; this.exceptionTypes.equals(token.exceptionTypes) &amp;&amp; this.annotations.equals(token.annotations)) {
&nbsp;                        label68: {
&nbsp;                            if (this.defaultValue != null) {
&nbsp;                                if (!this.defaultValue.equals(token.defaultValue)) {
&nbsp;                                    break label68;
&nbsp;                                }
&nbsp;                            } else if (token.defaultValue != null) {
&nbsp;                                break label68;
&nbsp;                            }
&nbsp;
&nbsp;                            if (this.receiverType != null) {
&nbsp;                                if (this.receiverType.equals(token.receiverType)) {
&nbsp;                                    break label74;
&nbsp;                                }
&nbsp;                            } else if (token.receiverType == null) {
&nbsp;                                break label74;
&nbsp;                            }
<b class="fc">&nbsp;                        }</b>
&nbsp;                    }
&nbsp;
&nbsp;                    var10000 = false;
&nbsp;                    return var10000;
&nbsp;                }
&nbsp;
&nbsp;                var10000 = true;
&nbsp;                return var10000;
&nbsp;            } else {
&nbsp;                return false;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public String toString() {
&nbsp;            return &quot;MethodDescription.Token{name=&#39;&quot; + this.name + &#39;\&#39;&#39; + &quot;, modifiers=&quot; + this.modifiers + &quot;, typeVariableTokens=&quot; + this.typeVariableTokens + &quot;, returnType=&quot; + this.returnType + &quot;, parameterTokens=&quot; + this.parameterTokens + &quot;, exceptionTypes=&quot; + this.exceptionTypes + &quot;, annotations=&quot; + this.annotations + &quot;, defaultValue=&quot; + this.defaultValue + &quot;, receiverType=&quot; + this.receiverType + &#39;}&#39;;
&nbsp;        }
&nbsp;    }
<b class="fc">&nbsp;</b>
&nbsp;    public static class TypeSubstituting extends AbstractBase implements InGenericShape {
&nbsp;        private final TypeDescription.Generic declaringType;
&nbsp;        private final MethodDescription methodDescription;
&nbsp;        private final TypeDescription.Generic.Visitor&lt;? extends TypeDescription.Generic&gt; visitor;
&nbsp;
&nbsp;        public TypeSubstituting(TypeDescription.Generic declaringType, MethodDescription methodDescription, TypeDescription.Generic.Visitor&lt;? extends TypeDescription.Generic&gt; visitor) {
<b class="fc">&nbsp;            this.declaringType = declaringType;</b>
&nbsp;            this.methodDescription = methodDescription;
&nbsp;            this.visitor = visitor;
&nbsp;        }
&nbsp;
&nbsp;        public TypeDescription.Generic getReturnType() {
&nbsp;            return (TypeDescription.Generic)this.methodDescription.getReturnType().accept(this.visitor);
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        public TypeList.Generic getTypeVariables() {
&nbsp;            return (TypeList.Generic)this.methodDescription.getTypeVariables().accept(this.visitor).filter(ElementMatchers.ofSort(Sort.VARIABLE));
&nbsp;        }
&nbsp;
&nbsp;        public ParameterList&lt;ParameterDescription.InGenericShape&gt; getParameters() {
<b class="fc">&nbsp;            return new ParameterList.TypeSubstituting(this, this.methodDescription.getParameters(), this.visitor);</b>
&nbsp;        }
&nbsp;
&nbsp;        public TypeList.Generic getExceptionTypes() {
&nbsp;            return new TypeList.Generic.ForDetachedTypes(this.methodDescription.getExceptionTypes(), this.visitor);
&nbsp;        }
&nbsp;
&nbsp;        @Nonnull(
&nbsp;            when = When.MAYBE
&nbsp;        )
&nbsp;        public AnnotationValue&lt;?, ?&gt; getDefaultValue() {
&nbsp;            return this.methodDescription.getDefaultValue();
&nbsp;        }
&nbsp;
&nbsp;        public TypeDescription.Generic getReceiverType() {
&nbsp;            TypeDescription.Generic receiverType = this.methodDescription.getReceiverType();
&nbsp;            return receiverType == null ? Generic.UNDEFINED : (TypeDescription.Generic)receiverType.accept(this.visitor);
&nbsp;        }
&nbsp;
&nbsp;        public AnnotationList getDeclaredAnnotations() {
&nbsp;            return this.methodDescription.getDeclaredAnnotations();
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;</b>
&nbsp;        @Nonnull
&nbsp;        public TypeDescription.Generic getDeclaringType() {
&nbsp;            return this.declaringType;
&nbsp;        }
&nbsp;
&nbsp;        public int getModifiers() {
&nbsp;            return this.methodDescription.getModifiers();
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;</b>
&nbsp;        public String getInternalName() {
&nbsp;            return this.methodDescription.getInternalName();
&nbsp;        }
&nbsp;
&nbsp;        public InDefinedShape asDefined() {
&nbsp;            return (InDefinedShape)this.methodDescription.asDefined();
&nbsp;        }
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;        public boolean isConstructor() {</b>
<b class="fc">&nbsp;            return this.methodDescription.isConstructor();</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;</b>
&nbsp;        public boolean isMethod() {
&nbsp;            return this.methodDescription.isMethod();
&nbsp;        }
&nbsp;
&nbsp;        public boolean isTypeInitializer() {
&nbsp;            return this.methodDescription.isTypeInitializer();
&nbsp;        }
&nbsp;    }
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;    public static class Latent extends InDefinedShape.AbstractBase {</b>
<b class="fc">&nbsp;        private final TypeDescription declaringType;</b>
&nbsp;        private final String internalName;
&nbsp;        private final int modifiers;
&nbsp;        private final List&lt;? extends TypeVariableToken&gt; typeVariables;
&nbsp;        private final TypeDescription.Generic returnType;
&nbsp;        private final List&lt;? extends ParameterDescription.Token&gt; parameterTokens;
&nbsp;        private final List&lt;? extends TypeDescription.Generic&gt; exceptionTypes;
&nbsp;        private final List&lt;? extends AnnotationDescription&gt; declaredAnnotations;
&nbsp;        @Nonnull(
&nbsp;            when = When.MAYBE
&nbsp;        )
<b class="fc">&nbsp;        private final AnnotationValue&lt;?, ?&gt; defaultValue;</b>
<b class="fc">&nbsp;        @Nonnull(</b>
<b class="fc">&nbsp;            when = When.MAYBE</b>
<b class="fc">&nbsp;        )</b>
<b class="fc">&nbsp;        private final TypeDescription.Generic receiverType;</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;        public Latent(TypeDescription declaringType, Token token) {</b>
<b class="fc">&nbsp;            this(declaringType, token.getName(), token.getModifiers(), token.getTypeVariableTokens(), token.getReturnType(), token.getParameterTokens(), token.getExceptionTypes(), token.getAnnotations(), token.getDefaultValue(), token.getReceiverType());</b>
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        public Latent(TypeDescription declaringType, String internalName, int modifiers, List&lt;? extends TypeVariableToken&gt; typeVariables, TypeDescription.Generic returnType, List&lt;? extends ParameterDescription.Token&gt; parameterTokens, List&lt;? extends TypeDescription.Generic&gt; exceptionTypes, List&lt;? extends AnnotationDescription&gt; declaredAnnotations, @Nonnull(when = When.MAYBE) AnnotationValue&lt;?, ?&gt; defaultValue, @Nonnull(when = When.MAYBE) TypeDescription.Generic receiverType) {
&nbsp;            this.declaringType = declaringType;
&nbsp;            this.internalName = internalName;
&nbsp;            this.modifiers = modifiers;
<b class="fc">&nbsp;            this.typeVariables = typeVariables;</b>
<b class="fc">&nbsp;            this.returnType = returnType;</b>
&nbsp;            this.parameterTokens = parameterTokens;
&nbsp;            this.exceptionTypes = exceptionTypes;
&nbsp;            this.declaredAnnotations = declaredAnnotations;
&nbsp;            this.defaultValue = defaultValue;
&nbsp;            this.receiverType = receiverType;
&nbsp;        }
&nbsp;
&nbsp;        public TypeList.Generic getTypeVariables() {
&nbsp;            return ForDetachedTypes.attachVariables(this, this.typeVariables);
&nbsp;        }
<b class="fc">&nbsp;</b>
&nbsp;        public TypeDescription.Generic getReturnType() {
&nbsp;            return (TypeDescription.Generic)this.returnType.accept(ForAttachment.of(this));
&nbsp;        }
&nbsp;
&nbsp;        public ParameterList&lt;ParameterDescription.InDefinedShape&gt; getParameters() {
&nbsp;            return new ParameterList.ForTokens(this, this.parameterTokens);
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        public TypeList.Generic getExceptionTypes() {</b>
<b class="fc">&nbsp;            return ForDetachedTypes.attach(this, this.exceptionTypes);</b>
&nbsp;        }
&nbsp;
&nbsp;        public AnnotationList getDeclaredAnnotations() {
&nbsp;            return new AnnotationList.Explicit(this.declaredAnnotations);
&nbsp;        }
&nbsp;
&nbsp;        public String getInternalName() {
<b class="fc">&nbsp;            return this.internalName;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Nonnull
&nbsp;        public TypeDescription getDeclaringType() {
&nbsp;            return this.declaringType;
&nbsp;        }
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;        public int getModifiers() {</b>
<b class="fc">&nbsp;            return this.modifiers;</b>
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        @Nonnull(
&nbsp;            when = When.MAYBE
&nbsp;        )
&nbsp;        public AnnotationValue&lt;?, ?&gt; getDefaultValue() {
&nbsp;            return this.defaultValue;
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        @Nonnull(</b>
<b class="fc">&nbsp;            when = When.MAYBE</b>
&nbsp;        )
&nbsp;        public TypeDescription.Generic getReceiverType() {
&nbsp;            return this.receiverType == null ? super.getReceiverType() : (TypeDescription.Generic)this.receiverType.accept(ForAttachment.of(this));
&nbsp;        }
&nbsp;
&nbsp;        public static class TypeInitializer extends InDefinedShape.AbstractBase {
&nbsp;            private final TypeDescription typeDescription;
&nbsp;
&nbsp;            public TypeInitializer(TypeDescription typeDescription) {
<b class="fc">&nbsp;                this.typeDescription = typeDescription;</b>
&nbsp;            }
&nbsp;
&nbsp;            public TypeDescription.Generic getReturnType() {
&nbsp;                return Generic.VOID;
&nbsp;            }
&nbsp;
&nbsp;            public ParameterList&lt;ParameterDescription.InDefinedShape&gt; getParameters() {
&nbsp;                return new ParameterList.Empty();
&nbsp;            }
&nbsp;
&nbsp;            public TypeList.Generic getExceptionTypes() {
&nbsp;                return new TypeList.Generic.Empty();
&nbsp;            }
<b class="fc">&nbsp;</b>
&nbsp;            @Nonnull(
<b class="fc">&nbsp;                when = When.MAYBE</b>
<b class="fc">&nbsp;            )</b>
&nbsp;            public AnnotationValue&lt;?, ?&gt; getDefaultValue() {
<b class="fc">&nbsp;                return AnnotationValue.UNDEFINED;</b>
&nbsp;            }
&nbsp;
&nbsp;            public TypeList.Generic getTypeVariables() {
&nbsp;                return new TypeList.Generic.Empty();
&nbsp;            }
&nbsp;
&nbsp;            public AnnotationList getDeclaredAnnotations() {
&nbsp;                return new AnnotationList.Empty();
&nbsp;            }
&nbsp;
&nbsp;            @Nonnull
&nbsp;            public TypeDescription getDeclaringType() {
&nbsp;                return this.typeDescription;
&nbsp;            }
&nbsp;
&nbsp;            public int getModifiers() {
&nbsp;                return 8;
&nbsp;            }
&nbsp;
&nbsp;            public String getInternalName() {
&nbsp;                return &quot;&lt;clinit&gt;&quot;;
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static class ForLoadedMethod extends InDefinedShape.AbstractBase.ForLoadedExecutable&lt;Method&gt; implements ParameterDescription.ForLoadedParameter.ParameterAnnotationSource {
&nbsp;        public ForLoadedMethod(Method method) {
&nbsp;            super(method);
&nbsp;        }
&nbsp;
&nbsp;        @Nonnull
&nbsp;        public TypeDescription getDeclaringType() {
&nbsp;            return ForLoadedType.of(((Method)this.executable).getDeclaringClass());
&nbsp;        }
&nbsp;
&nbsp;        public TypeDescription.Generic getReturnType() {
&nbsp;            return (TypeDescription.Generic)(net.bytebuddy.description.type.TypeDescription.AbstractBase.RAW_TYPES ? net.bytebuddy.description.type.TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(((Method)this.executable).getReturnType()) : new TypeDescription.Generic.LazyProjection.ForLoadedReturnType((Method)this.executable));
&nbsp;        }
&nbsp;
&nbsp;        @Enhance(&quot;parameters&quot;)
&nbsp;        public ParameterList&lt;ParameterDescription.InDefinedShape&gt; getParameters() {
&nbsp;            ParameterList var1 = this.parameters;
&nbsp;            ParameterList var2 = var1 != null ? null : net.bytebuddy.description.method.ParameterList.ForLoadedExecutable.of((Method)this.executable, this);
&nbsp;            if (var2 == null) {
&nbsp;                var2 = (ParameterList)this.parameters;
&nbsp;            } else {
&nbsp;                this.parameters = var2;
&nbsp;            }
&nbsp;
&nbsp;            return var2;
&nbsp;        }
&nbsp;
&nbsp;        public TypeList.Generic getExceptionTypes() {
&nbsp;            return (TypeList.Generic)(net.bytebuddy.description.type.TypeDescription.AbstractBase.RAW_TYPES ? new TypeList.Generic.ForLoadedTypes(((Method)this.executable).getExceptionTypes()) : new TypeList.Generic.OfMethodExceptionTypes((Method)this.executable));
&nbsp;        }
&nbsp;
&nbsp;        public boolean isConstructor() {
&nbsp;            return false;
&nbsp;        }
&nbsp;
&nbsp;        public boolean isTypeInitializer() {
&nbsp;            return false;
&nbsp;        }
&nbsp;
&nbsp;        public boolean isBridge() {
&nbsp;            return ((Method)this.executable).isBridge();
&nbsp;        }
&nbsp;
&nbsp;        public boolean represents(Method method) {
&nbsp;            return ((Method)this.executable).equals(method) || this.equals(new ForLoadedMethod(method));
&nbsp;        }
&nbsp;
&nbsp;        public boolean represents(Constructor&lt;?&gt; constructor) {
&nbsp;            return false;
&nbsp;        }
&nbsp;
&nbsp;        public String getName() {
&nbsp;            return ((Method)this.executable).getName();
&nbsp;        }
&nbsp;
&nbsp;        public int getModifiers() {
&nbsp;            return ((Method)this.executable).getModifiers();
&nbsp;        }
&nbsp;
&nbsp;        public boolean isSynthetic() {
&nbsp;            return ((Method)this.executable).isSynthetic();
&nbsp;        }
&nbsp;
&nbsp;        public String getInternalName() {
&nbsp;            return ((Method)this.executable).getName();
&nbsp;        }
&nbsp;
&nbsp;        public String getDescriptor() {
&nbsp;            return Type.getMethodDescriptor((Method)this.executable);
&nbsp;        }
&nbsp;
&nbsp;        public Method getLoadedMethod() {
&nbsp;            return (Method)this.executable;
&nbsp;        }
&nbsp;
&nbsp;        @Enhance(&quot;declaredAnnotations&quot;)
&nbsp;        public AnnotationList getDeclaredAnnotations() {
&nbsp;            AnnotationList var1 = this.declaredAnnotations;
&nbsp;            Object var2 = var1 != null ? null : new AnnotationList.ForLoadedAnnotations(((Method)this.executable).getDeclaredAnnotations());
&nbsp;            if (var2 == null) {
&nbsp;                var2 = (AnnotationList)this.declaredAnnotations;
&nbsp;            } else {
&nbsp;                this.declaredAnnotations = (AnnotationList)var2;
&nbsp;            }
&nbsp;
&nbsp;            return (AnnotationList)var2;
&nbsp;        }
&nbsp;
&nbsp;        @Nonnull(
&nbsp;            when = When.MAYBE
&nbsp;        )
&nbsp;        public AnnotationValue&lt;?, ?&gt; getDefaultValue() {
&nbsp;            Object value = ((Method)this.executable).getDefaultValue();
&nbsp;            return value == null ? AnnotationValue.UNDEFINED : ForLoadedAnnotation.asValue(value, ((Method)this.executable).getReturnType());
&nbsp;        }
&nbsp;
&nbsp;        public TypeList.Generic getTypeVariables() {
&nbsp;            return (TypeList.Generic)(net.bytebuddy.description.type.TypeDescription.AbstractBase.RAW_TYPES ? new TypeList.Generic.Empty() : OfTypeVariables.of((GenericDeclaration)this.executable));
&nbsp;        }
&nbsp;
&nbsp;        @Enhance(&quot;parameterAnnotations&quot;)
&nbsp;        public Annotation[][] getParameterAnnotations() {
&nbsp;            Annotation[][] var1 = this.parameterAnnotations;
&nbsp;            Annotation[][] var2 = var1 != null ? null : ((Method)this.executable).getParameterAnnotations();
&nbsp;            if (var2 == null) {
&nbsp;                var2 = (Annotation[][])this.parameterAnnotations;
&nbsp;            } else {
&nbsp;                this.parameterAnnotations = var2;
&nbsp;            }
&nbsp;
&nbsp;            return var2;
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static class ForLoadedConstructor extends InDefinedShape.AbstractBase.ForLoadedExecutable&lt;Constructor&lt;?&gt;&gt; implements ParameterDescription.ForLoadedParameter.ParameterAnnotationSource {
&nbsp;        public ForLoadedConstructor(Constructor&lt;?&gt; constructor) {
&nbsp;            super(constructor);
&nbsp;        }
&nbsp;
&nbsp;        @Nonnull
&nbsp;        public TypeDescription getDeclaringType() {
&nbsp;            return ForLoadedType.of(((Constructor)this.executable).getDeclaringClass());
&nbsp;        }
&nbsp;
&nbsp;        public TypeDescription.Generic getReturnType() {
&nbsp;            return Generic.VOID;
&nbsp;        }
&nbsp;
&nbsp;        @Enhance(&quot;parameters&quot;)
&nbsp;        public ParameterList&lt;ParameterDescription.InDefinedShape&gt; getParameters() {
&nbsp;            ParameterList var1 = this.parameters;
&nbsp;            ParameterList var2 = var1 != null ? null : net.bytebuddy.description.method.ParameterList.ForLoadedExecutable.of((Constructor)this.executable, this);
&nbsp;            if (var2 == null) {
&nbsp;                var2 = (ParameterList)this.parameters;
&nbsp;            } else {
&nbsp;                this.parameters = var2;
&nbsp;            }
&nbsp;
&nbsp;            return var2;
&nbsp;        }
&nbsp;
&nbsp;        public TypeList.Generic getExceptionTypes() {
&nbsp;            return new TypeList.Generic.OfConstructorExceptionTypes((Constructor)this.executable);
&nbsp;        }
&nbsp;
&nbsp;        public boolean isConstructor() {
&nbsp;            return true;
&nbsp;        }
&nbsp;
&nbsp;        public boolean isTypeInitializer() {
&nbsp;            return false;
&nbsp;        }
&nbsp;
&nbsp;        public boolean represents(Method method) {
&nbsp;            return false;
&nbsp;        }
&nbsp;
&nbsp;        public boolean represents(Constructor&lt;?&gt; constructor) {
&nbsp;            return ((Constructor)this.executable).equals(constructor) || this.equals(new ForLoadedConstructor(constructor));
&nbsp;        }
&nbsp;
&nbsp;        public String getName() {
&nbsp;            return ((Constructor)this.executable).getName();
&nbsp;        }
&nbsp;
&nbsp;        public int getModifiers() {
&nbsp;            return ((Constructor)this.executable).getModifiers();
&nbsp;        }
&nbsp;
&nbsp;        public boolean isSynthetic() {
&nbsp;            return ((Constructor)this.executable).isSynthetic();
&nbsp;        }
&nbsp;
&nbsp;        public String getInternalName() {
&nbsp;            return &quot;&lt;init&gt;&quot;;
&nbsp;        }
&nbsp;
&nbsp;        public String getDescriptor() {
&nbsp;            return Type.getConstructorDescriptor((Constructor)this.executable);
&nbsp;        }
&nbsp;
&nbsp;        @Nonnull(
&nbsp;            when = When.MAYBE
&nbsp;        )
&nbsp;        public AnnotationValue&lt;?, ?&gt; getDefaultValue() {
&nbsp;            return AnnotationValue.UNDEFINED;
&nbsp;        }
&nbsp;
&nbsp;        @Enhance(&quot;declaredAnnotations&quot;)
&nbsp;        public AnnotationList getDeclaredAnnotations() {
&nbsp;            AnnotationList var1 = this.declaredAnnotations;
&nbsp;            Object var2 = var1 != null ? null : new AnnotationList.ForLoadedAnnotations(((Constructor)this.executable).getDeclaredAnnotations());
&nbsp;            if (var2 == null) {
&nbsp;                var2 = (AnnotationList)this.declaredAnnotations;
&nbsp;            } else {
&nbsp;                this.declaredAnnotations = (AnnotationList)var2;
&nbsp;            }
&nbsp;
&nbsp;            return (AnnotationList)var2;
&nbsp;        }
&nbsp;
&nbsp;        public TypeList.Generic getTypeVariables() {
&nbsp;            return OfTypeVariables.of((GenericDeclaration)this.executable);
&nbsp;        }
&nbsp;
&nbsp;        @Enhance(&quot;parameterAnnotations&quot;)
&nbsp;        public Annotation[][] getParameterAnnotations() {
&nbsp;            Annotation[][] var1 = this.parameterAnnotations;
&nbsp;            Annotation[][] var2 = var1 != null ? null : ((Constructor)this.executable).getParameterAnnotations();
&nbsp;            if (var2 == null) {
&nbsp;                var2 = (Annotation[][])this.parameterAnnotations;
&nbsp;            } else {
&nbsp;                this.parameterAnnotations = var2;
&nbsp;            }
&nbsp;
&nbsp;            return var2;
&nbsp;        }
<b class="fc">&nbsp;    }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;    public abstract static class AbstractBase extends TypeVariableSource.AbstractBase implements MethodDescription {</b>
<b class="fc">&nbsp;        private static final int SOURCE_MODIFIERS = 1343;</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;        public AbstractBase() {</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;        public int getStackSize() {</b>
&nbsp;            return this.getParameters().asTypeList().getStackSize() + (this.isStatic() ? 0 : 1);
&nbsp;        }
<b class="fc">&nbsp;</b>
&nbsp;        public boolean isMethod() {
&nbsp;            return !this.isConstructor() &amp;&amp; !this.isTypeInitializer();
&nbsp;        }
&nbsp;
&nbsp;        public boolean isConstructor() {
&nbsp;            return &quot;&lt;init&gt;&quot;.equals(this.getInternalName());
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        public boolean isTypeInitializer() {
&nbsp;            return &quot;&lt;clinit&gt;&quot;.equals(this.getInternalName());
&nbsp;        }
&nbsp;
&nbsp;        public boolean represents(Method method) {
<b class="fc">&nbsp;            return this.equals(new ForLoadedMethod(method));</b>
&nbsp;        }
&nbsp;
&nbsp;        public boolean represents(Constructor&lt;?&gt; constructor) {
&nbsp;            return this.equals(new ForLoadedConstructor(constructor));
&nbsp;        }
&nbsp;
&nbsp;        public String getName() {
&nbsp;            return this.isMethod() ? this.getInternalName() : this.getDeclaringType().asErasure().getName();
&nbsp;        }
&nbsp;
&nbsp;        public String getActualName() {
&nbsp;            return this.isMethod() ? this.getName() : &quot;&quot;;
&nbsp;        }
&nbsp;
&nbsp;        public String getDescriptor() {
&nbsp;            StringBuilder descriptor = (new StringBuilder()).append(&#39;(&#39;);
&nbsp;            Iterator var2 = this.getParameters().asTypeList().asErasures().iterator();
&nbsp;
&nbsp;            while(var2.hasNext()) {
&nbsp;                TypeDescription parameterType = (TypeDescription)var2.next();
&nbsp;                descriptor.append(parameterType.getDescriptor());
&nbsp;            }
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;            return descriptor.append(&#39;)&#39;).append(this.getReturnType().asErasure().getDescriptor()).toString();</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;</b>
&nbsp;        @Nonnull(
&nbsp;            when = When.MAYBE
&nbsp;        )
&nbsp;        public String getGenericSignature() {
&nbsp;            try {
&nbsp;                SignatureWriter signatureWriter = new SignatureWriter();
&nbsp;                boolean generic = false;
&nbsp;
&nbsp;                Iterator var3;
&nbsp;                TypeDescription.Generic parameterType;
&nbsp;                for(var3 = this.getTypeVariables().iterator(); var3.hasNext(); generic = true) {
&nbsp;                    parameterType = (TypeDescription.Generic)var3.next();
&nbsp;                    signatureWriter.visitFormalTypeParameter(parameterType.getSymbol());
&nbsp;                    boolean classBound = true;
&nbsp;
&nbsp;                    for(Iterator var6 = parameterType.getUpperBounds().iterator(); var6.hasNext(); classBound = false) {
&nbsp;                        TypeDescription.Generic upperBound = (TypeDescription.Generic)var6.next();
&nbsp;                        upperBound.accept(new TypeDescription.Generic.Visitor.ForSignatureVisitor(classBound ? signatureWriter.visitClassBound() : signatureWriter.visitInterfaceBound()));
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                for(var3 = this.getParameters().asTypeList().iterator(); var3.hasNext(); generic = generic || !parameterType.getSort().isNonGeneric()) {
&nbsp;                    parameterType = (TypeDescription.Generic)var3.next();
&nbsp;                    parameterType.accept(new TypeDescription.Generic.Visitor.ForSignatureVisitor(signatureWriter.visitParameterType()));
&nbsp;                }
&nbsp;
&nbsp;                TypeDescription.Generic returnType = this.getReturnType();
&nbsp;                returnType.accept(new TypeDescription.Generic.Visitor.ForSignatureVisitor(signatureWriter.visitReturnType()));
&nbsp;                generic = generic || !returnType.getSort().isNonGeneric();
&nbsp;                TypeList.Generic exceptionTypes = this.getExceptionTypes();
&nbsp;                TypeDescription.Generic exceptionType;
&nbsp;                if (!((TypeList.Generic)exceptionTypes.filter(ElementMatchers.not(ElementMatchers.ofSort(Sort.NON_GENERIC)))).isEmpty()) {
&nbsp;                    for(Iterator var11 = exceptionTypes.iterator(); var11.hasNext(); generic = generic || !exceptionType.getSort().isNonGeneric()) {
&nbsp;                        exceptionType = (TypeDescription.Generic)var11.next();
&nbsp;                        exceptionType.accept(new TypeDescription.Generic.Visitor.ForSignatureVisitor(signatureWriter.visitExceptionType()));
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                return generic ? signatureWriter.toString() : NON_GENERIC_SIGNATURE;
&nbsp;            } catch (GenericSignatureFormatError var8) {
&nbsp;                return NON_GENERIC_SIGNATURE;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public int getActualModifiers() {
&nbsp;            return this.getModifiers() | (this.getDeclaredAnnotations().isAnnotationPresent(Deprecated.class) ? 131072 : 0);
&nbsp;        }
&nbsp;
&nbsp;        public int getActualModifiers(boolean manifest) {
&nbsp;            return manifest ? this.getActualModifiers() &amp; -1281 : this.getActualModifiers() &amp; -257 | 1024;
&nbsp;        }
&nbsp;
&nbsp;        public int getActualModifiers(boolean manifest, Visibility visibility) {
&nbsp;            return Resolver.of(Collections.singleton(this.getVisibility().expandTo(visibility))).resolve(this.getActualModifiers(manifest));
&nbsp;        }
&nbsp;
&nbsp;        public boolean isVisibleTo(TypeDescription typeDescription) {
&nbsp;            return (this.isVirtual() || this.getDeclaringType().asErasure().isVisibleTo(typeDescription)) &amp;&amp; (this.isPublic() || typeDescription.equals(this.getDeclaringType().asErasure()) || this.isProtected() &amp;&amp; this.getDeclaringType().asErasure().isAssignableFrom(typeDescription) || !this.isPrivate() &amp;&amp; typeDescription.isSamePackage(this.getDeclaringType().asErasure()) || this.isPrivate() &amp;&amp; typeDescription.isNestMateOf(this.getDeclaringType().asErasure()));
&nbsp;        }
&nbsp;
&nbsp;        public boolean isAccessibleTo(TypeDescription typeDescription) {
&nbsp;            return (this.isVirtual() || this.getDeclaringType().asErasure().isVisibleTo(typeDescription)) &amp;&amp; (this.isPublic() || typeDescription.equals(this.getDeclaringType().asErasure()) || !this.isPrivate() &amp;&amp; typeDescription.isSamePackage(this.getDeclaringType().asErasure())) || this.isPrivate() &amp;&amp; typeDescription.isNestMateOf(this.getDeclaringType().asErasure());
&nbsp;        }
&nbsp;
&nbsp;        public boolean isVirtual() {
&nbsp;            return !this.isConstructor() &amp;&amp; !this.isPrivate() &amp;&amp; !this.isStatic() &amp;&amp; !this.isTypeInitializer();
&nbsp;        }
&nbsp;
&nbsp;        public boolean isDefaultMethod() {
&nbsp;            return !this.isAbstract() &amp;&amp; !this.isBridge() &amp;&amp; this.getDeclaringType().isInterface();
&nbsp;        }
&nbsp;
&nbsp;        public boolean isSpecializableFor(TypeDescription targetType) {
&nbsp;            if (this.isStatic()) {
&nbsp;                return false;
&nbsp;            } else if (!this.isPrivate() &amp;&amp; !this.isConstructor()) {
&nbsp;                return !this.isAbstract() &amp;&amp; this.getDeclaringType().asErasure().isAssignableFrom(targetType);
&nbsp;            } else {
&nbsp;                return this.getDeclaringType().equals(targetType);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Nonnull(
&nbsp;            when = When.MAYBE
&nbsp;        )
&nbsp;        public &lt;T&gt; T getDefaultValue(Class&lt;T&gt; type) {
&nbsp;            return type.cast(this.getDefaultValue());
&nbsp;        }
&nbsp;
&nbsp;        public boolean isInvokableOn(TypeDescription typeDescription) {
&nbsp;            boolean var10000;
&nbsp;            label29: {
&nbsp;                if (!this.isStatic() &amp;&amp; !this.isTypeInitializer() &amp;&amp; this.isVisibleTo(typeDescription)) {
&nbsp;                    if (this.isVirtual()) {
&nbsp;                        if (this.getDeclaringType().asErasure().isAssignableFrom(typeDescription)) {
&nbsp;                            break label29;
&nbsp;                        }
&nbsp;                    } else if (this.getDeclaringType().asErasure().equals(typeDescription)) {
&nbsp;                        break label29;
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                var10000 = false;
&nbsp;                return var10000;
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            var10000 = true;</b>
&nbsp;            return var10000;
&nbsp;        }
&nbsp;
&nbsp;        @SuppressFBWarnings(
&nbsp;            value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;            justification = &quot;Assuming component type for array type.&quot;
&nbsp;        )
<b class="fc">&nbsp;        private boolean isBootstrap(TypeDescription bootstrapped) {</b>
&nbsp;            TypeList parameterTypes = this.getParameters().asTypeList().asErasures();
&nbsp;            switch (parameterTypes.size()) {
&nbsp;                case 0:
&nbsp;                    return false;
&nbsp;                case 1:
&nbsp;                    return ((TypeDescription)parameterTypes.getOnly()).represents(Object[].class);
<b class="fc">&nbsp;                case 2:</b>
&nbsp;                    return JavaType.METHOD_HANDLES_LOOKUP.getTypeStub().isAssignableTo((TypeDescription)parameterTypes.get(0)) &amp;&amp; ((TypeDescription)parameterTypes.get(1)).represents(Object[].class);
&nbsp;                case 3:
&nbsp;                    return JavaType.METHOD_HANDLES_LOOKUP.getTypeStub().isAssignableTo((TypeDescription)parameterTypes.get(0)) &amp;&amp; (((TypeDescription)parameterTypes.get(1)).represents(Object.class) || ((TypeDescription)parameterTypes.get(1)).represents(String.class)) &amp;&amp; (((TypeDescription)parameterTypes.get(2)).isArray() &amp;&amp; ((TypeDescription)parameterTypes.get(2)).getComponentType().isAssignableFrom(bootstrapped) || ((TypeDescription)parameterTypes.get(2)).isAssignableFrom(bootstrapped));
&nbsp;                default:
&nbsp;                    return JavaType.METHOD_HANDLES_LOOKUP.getTypeStub().isAssignableTo((TypeDescription)parameterTypes.get(0)) &amp;&amp; (((TypeDescription)parameterTypes.get(1)).represents(Object.class) || ((TypeDescription)parameterTypes.get(1)).represents(String.class)) &amp;&amp; ((TypeDescription)parameterTypes.get(2)).isAssignableFrom(bootstrapped);
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;</b>
&nbsp;        @SuppressFBWarnings(
&nbsp;            value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;            justification = &quot;Assuming component type for array type.&quot;
&nbsp;        )
&nbsp;        private boolean isBootstrapping(List&lt;? extends TypeDefinition&gt; arguments) {
&nbsp;            TypeList targets = this.getParameters().asTypeList().asErasures();
<b class="fc">&nbsp;            Iterator iterator;</b>
&nbsp;            if (targets.size() &lt; 4) {
&nbsp;                if (arguments.isEmpty()) {
&nbsp;                    return true;
&nbsp;                } else if (((TypeDescription)targets.get(targets.size() - 1)).isArray()) {
&nbsp;                    iterator = arguments.iterator();
&nbsp;
<b class="fc">&nbsp;                    TypeDefinition argument;</b>
&nbsp;                    do {
&nbsp;                        if (!iterator.hasNext()) {
&nbsp;                            return true;
&nbsp;                        }
&nbsp;
&nbsp;                        argument = (TypeDefinition)iterator.next();
<b class="fc">&nbsp;                    } while(argument.asErasure().isAssignableTo(((TypeDescription)targets.get(targets.size() - 1)).getComponentType()));</b>
&nbsp;
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return false;
&nbsp;                }
&nbsp;            } else {
&nbsp;                iterator = ((TypeList)targets.subList(3, targets.size())).iterator();
&nbsp;                Iterator var4 = arguments.iterator();
&nbsp;
&nbsp;                while(var4.hasNext()) {
&nbsp;                    TypeDefinition type = (TypeDefinition)var4.next();
&nbsp;                    if (!iterator.hasNext()) {
&nbsp;                        return false;
&nbsp;                    }
&nbsp;
&nbsp;                    TypeDescription target = (TypeDescription)iterator.next();
&nbsp;                    if (!iterator.hasNext() &amp;&amp; target.isArray()) {
&nbsp;                        return true;
&nbsp;                    }
&nbsp;
&nbsp;                    if (!type.asErasure().isAssignableTo(target)) {
&nbsp;                        return false;
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                if (!iterator.hasNext()) {
&nbsp;                    return true;
<b class="fc">&nbsp;                } else {</b>
&nbsp;                    return ((TypeDescription)iterator.next()).isArray() &amp;&amp; !iterator.hasNext();
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public boolean isInvokeBootstrap() {
&nbsp;            TypeDescription returnType = this.getReturnType().asErasure();
&nbsp;            return (!this.isMethod() || this.isStatic() &amp;&amp; (JavaType.CALL_SITE.getTypeStub().isAssignableFrom(returnType) || JavaType.CALL_SITE.getTypeStub().isAssignableTo(returnType))) &amp;&amp; (!this.isConstructor() || JavaType.CALL_SITE.getTypeStub().isAssignableFrom(this.getDeclaringType().asErasure())) ? this.isBootstrap(JavaType.METHOD_TYPE.getTypeStub()) : false;
&nbsp;        }
&nbsp;
&nbsp;        public boolean isInvokeBootstrap(List&lt;? extends TypeDefinition&gt; arguments) {
&nbsp;            return this.isInvokeBootstrap() &amp;&amp; this.isBootstrapping(arguments);
&nbsp;        }
<b class="fc">&nbsp;</b>
&nbsp;        public boolean isConstantBootstrap() {
&nbsp;            return this.isBootstrap(TypeDescription.CLASS);
&nbsp;        }
&nbsp;
&nbsp;        public boolean isConstantBootstrap(List&lt;? extends TypeDefinition&gt; arguments) {
&nbsp;            return this.isConstantBootstrap() &amp;&amp; this.isBootstrapping(arguments);
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        public boolean isDefaultValue() {
&nbsp;            return !this.isConstructor() &amp;&amp; !this.isStatic() &amp;&amp; this.getReturnType().asErasure().isAnnotationReturnType() &amp;&amp; this.getParameters().isEmpty();
&nbsp;        }
&nbsp;
&nbsp;        @SuppressFBWarnings(
&nbsp;            value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
<b class="fc">&nbsp;            justification = &quot;Assuming component type for array type.&quot;</b>
&nbsp;        )
&nbsp;        public boolean isDefaultValue(AnnotationValue&lt;?, ?&gt; annotationValue) {
&nbsp;            if (!this.isDefaultValue()) {
&nbsp;                return false;
&nbsp;            } else {
&nbsp;                TypeDescription returnType = this.getReturnType().asErasure();
&nbsp;                Object value = annotationValue.resolve();
<b class="fc">&nbsp;                return returnType.represents(Boolean.TYPE) &amp;&amp; value instanceof Boolean || returnType.represents(Byte.TYPE) &amp;&amp; value instanceof Byte || returnType.represents(Character.TYPE) &amp;&amp; value instanceof Character || returnType.represents(Short.TYPE) &amp;&amp; value instanceof Short || returnType.represents(Integer.TYPE) &amp;&amp; value instanceof Integer || returnType.represents(Long.TYPE) &amp;&amp; value instanceof Long || returnType.represents(Float.TYPE) &amp;&amp; value instanceof Float || returnType.represents(Double.TYPE) &amp;&amp; value instanceof Double || returnType.represents(String.class) &amp;&amp; value instanceof String || returnType.isAssignableTo(Enum.class) &amp;&amp; value instanceof EnumerationDescription &amp;&amp; isEnumerationType(returnType, (EnumerationDescription)value) || returnType.isAssignableTo(Annotation.class) &amp;&amp; value instanceof AnnotationDescription &amp;&amp; isAnnotationType(returnType, (AnnotationDescription)value) || returnType.represents(Class.class) &amp;&amp; value instanceof TypeDescription || returnType.represents(boolean[].class) &amp;&amp; value instanceof boolean[] || returnType.represents(byte[].class) &amp;&amp; value instanceof byte[] || returnType.represents(char[].class) &amp;&amp; value instanceof char[] || returnType.represents(short[].class) &amp;&amp; value instanceof short[] || returnType.represents(int[].class) &amp;&amp; value instanceof int[] || returnType.represents(long[].class) &amp;&amp; value instanceof long[] || returnType.represents(float[].class) &amp;&amp; value instanceof float[] || returnType.represents(double[].class) &amp;&amp; value instanceof double[] || returnType.represents(String[].class) &amp;&amp; value instanceof String[] || returnType.isAssignableTo(Enum[].class) &amp;&amp; value instanceof EnumerationDescription[] &amp;&amp; isEnumerationType(returnType.getComponentType(), (EnumerationDescription[])((EnumerationDescription[])value)) || returnType.isAssignableTo(Annotation[].class) &amp;&amp; value instanceof AnnotationDescription[] &amp;&amp; isAnnotationType(returnType.getComponentType(), (AnnotationDescription[])((AnnotationDescription[])value)) || returnType.represents(Class[].class) &amp;&amp; value instanceof TypeDescription[];</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        private static boolean isEnumerationType(TypeDescription enumerationType, EnumerationDescription... enumerationDescription) {
&nbsp;            EnumerationDescription[] var2 = enumerationDescription;
&nbsp;            int var3 = enumerationDescription.length;
<b class="fc">&nbsp;</b>
&nbsp;            for(int var4 = 0; var4 &lt; var3; ++var4) {
&nbsp;                EnumerationDescription anEnumerationDescription = var2[var4];
&nbsp;                if (!anEnumerationDescription.getEnumerationType().equals(enumerationType)) {
&nbsp;                    return false;
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            return true;
&nbsp;        }
&nbsp;
&nbsp;        private static boolean isAnnotationType(TypeDescription annotationType, AnnotationDescription... annotationDescription) {
&nbsp;            AnnotationDescription[] var2 = annotationDescription;
&nbsp;            int var3 = annotationDescription.length;
&nbsp;
&nbsp;            for(int var4 = 0; var4 &lt; var3; ++var4) {
&nbsp;                AnnotationDescription anAnnotationDescription = var2[var4];
&nbsp;                if (!anAnnotationDescription.getAnnotationType().equals(annotationType)) {
&nbsp;                    return false;
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            return true;
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        @Nonnull(
&nbsp;            when = When.MAYBE
&nbsp;        )
&nbsp;        public TypeVariableSource getEnclosingSource() {
&nbsp;            return (TypeVariableSource)(this.isStatic() ? TypeVariableSource.UNDEFINED : this.getDeclaringType().asErasure());
&nbsp;        }
<b class="fc">&nbsp;</b>
&nbsp;        public boolean isInferrable() {
&nbsp;            return true;
&nbsp;        }
&nbsp;
&nbsp;        public &lt;T&gt; T accept(TypeVariableSource.Visitor&lt;T&gt; visitor) {
&nbsp;            return visitor.onMethod((InDefinedShape)this.asDefined());
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        public boolean isGenerified() {
<b class="fc">&nbsp;            return !this.getTypeVariables().isEmpty();</b>
&nbsp;        }
&nbsp;
&nbsp;        public Token asToken(ElementMatcher&lt;? super TypeDescription&gt; matcher) {
&nbsp;            TypeDescription.Generic receiverType = this.getReceiverType();
&nbsp;            return new Token(this.getInternalName(), this.getModifiers(), this.getTypeVariables().asTokenList(matcher), (TypeDescription.Generic)this.getReturnType().accept(new TypeDescription.Generic.Visitor.Substitutor.ForDetachment(matcher)), this.getParameters().asTokenList(matcher), this.getExceptionTypes().accept(new TypeDescription.Generic.Visitor.Substitutor.ForDetachment(matcher)), this.getDeclaredAnnotations(), this.getDefaultValue(), receiverType == null ? Generic.UNDEFINED : (TypeDescription.Generic)receiverType.accept(new TypeDescription.Generic.Visitor.Substitutor.ForDetachment(matcher)));
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        public SignatureToken asSignatureToken() {</b>
&nbsp;            return new SignatureToken(this.getInternalName(), this.getReturnType().asErasure(), this.getParameters().asTypeList().asErasures());
&nbsp;        }
&nbsp;
&nbsp;        public TypeToken asTypeToken() {
&nbsp;            return new TypeToken(this.getReturnType().asErasure(), this.getParameters().asTypeList().asErasures());
&nbsp;        }
<b class="fc">&nbsp;</b>
&nbsp;        public boolean isBridgeCompatible(TypeToken typeToken) {
&nbsp;            List&lt;TypeDescription&gt; types = this.getParameters().asTypeList().asErasures();
<b class="fc">&nbsp;            List&lt;TypeDescription&gt; bridgeTypes = typeToken.getParameterTypes();</b>
&nbsp;            if (types.size() != bridgeTypes.size()) {
&nbsp;                return false;
&nbsp;            } else {
&nbsp;                for(int index = 0; index &lt; types.size(); ++index) {
&nbsp;                    if (!((TypeDescription)types.get(index)).equals(bridgeTypes.get(index)) &amp;&amp; (((TypeDescription)types.get(index)).isPrimitive() || ((TypeDescription)bridgeTypes.get(index)).isPrimitive())) {
&nbsp;                        return false;
<b class="fc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                TypeDescription returnType = this.getReturnType().asErasure();
&nbsp;                TypeDescription bridgeReturnType = typeToken.getReturnType();
&nbsp;                return returnType.equals(bridgeReturnType) || !returnType.isPrimitive() &amp;&amp; !bridgeReturnType.isPrimitive();
&nbsp;            }
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        @Enhance(&quot;hashCode&quot;)
&nbsp;        public int hashCode() {
&nbsp;            int var1 = this.hashCode;
&nbsp;            int var10000;
&nbsp;            if (var1 != 0) {
&nbsp;                var10000 = 0;
&nbsp;            } else {
&nbsp;                int hashCode = 17 + this.getDeclaringType().hashCode();
&nbsp;                hashCode = 31 * hashCode + this.getInternalName().hashCode();
&nbsp;                hashCode = 31 * hashCode + this.getReturnType().asErasure().hashCode();
&nbsp;                var10000 = 31 * hashCode + this.getParameters().asTypeList().asErasures().hashCode();
&nbsp;            }
&nbsp;
&nbsp;            int var2 = var10000;
&nbsp;            if (var2 == 0) {
&nbsp;                var2 = this.hashCode;
&nbsp;            } else {
&nbsp;                this.hashCode = var2;
&nbsp;            }
&nbsp;
&nbsp;            return var2;
&nbsp;        }
&nbsp;
&nbsp;        public boolean equals(@CheckForNull Object other) {
&nbsp;            if (this == other) {
&nbsp;                return true;
<b class="fc">&nbsp;            } else if (!(other instanceof MethodDescription)) {</b>
&nbsp;                return false;
&nbsp;            } else {
&nbsp;                MethodDescription methodDescription = (MethodDescription)other;
&nbsp;                return this.getInternalName().equals(methodDescription.getInternalName()) &amp;&amp; this.getDeclaringType().equals(methodDescription.getDeclaringType()) &amp;&amp; this.getReturnType().asErasure().equals(methodDescription.getReturnType().asErasure()) &amp;&amp; this.getParameters().asTypeList().asErasures().equals(methodDescription.getParameters().asTypeList().asErasures());
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;</b>
&nbsp;        public String toGenericString() {
&nbsp;            StringBuilder stringBuilder = new StringBuilder();
&nbsp;            int modifiers = this.getModifiers() &amp; 1343;
&nbsp;            if (modifiers != 0) {
&nbsp;                stringBuilder.append(Modifier.toString(modifiers)).append(&#39; &#39;);
&nbsp;            }
&nbsp;
&nbsp;            if (this.isMethod()) {
&nbsp;                stringBuilder.append(this.getReturnType().getActualName()).append(&#39; &#39;);
&nbsp;                stringBuilder.append(this.getDeclaringType().asErasure().getActualName()).append(&#39;.&#39;);
&nbsp;            }
&nbsp;
&nbsp;            stringBuilder.append(this.getName()).append(&#39;(&#39;);
<b class="fc">&nbsp;            boolean first = true;</b>
&nbsp;
&nbsp;            TypeDescription.Generic typeDescription;
&nbsp;            for(Iterator var4 = this.getParameters().asTypeList().iterator(); var4.hasNext(); stringBuilder.append(typeDescription.getActualName())) {
&nbsp;                typeDescription = (TypeDescription.Generic)var4.next();
&nbsp;                if (!first) {
&nbsp;                    stringBuilder.append(&#39;,&#39;);
<b class="fc">&nbsp;                } else {</b>
&nbsp;                    first = false;
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            stringBuilder.append(&#39;)&#39;);
&nbsp;            TypeList.Generic exceptionTypes = this.getExceptionTypes();
&nbsp;            if (!exceptionTypes.isEmpty()) {
&nbsp;                stringBuilder.append(&quot; throws &quot;);
<b class="fc">&nbsp;                first = true;</b>
&nbsp;
&nbsp;                TypeDescription.Generic typeDescription;
&nbsp;                for(Iterator var8 = exceptionTypes.iterator(); var8.hasNext(); stringBuilder.append(typeDescription.getActualName())) {
&nbsp;                    typeDescription = (TypeDescription.Generic)var8.next();
&nbsp;                    if (!first) {
&nbsp;                        stringBuilder.append(&#39;,&#39;);
&nbsp;                    } else {
<b class="fc">&nbsp;                        first = false;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            return stringBuilder.toString();
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        public String toString() {</b>
<b class="fc">&nbsp;            StringBuilder stringBuilder = new StringBuilder();</b>
&nbsp;            int modifiers = this.getModifiers() &amp; 1343;
&nbsp;            if (modifiers != 0) {
&nbsp;                stringBuilder.append(Modifier.toString(modifiers)).append(&#39; &#39;);
&nbsp;            }
&nbsp;
&nbsp;            if (this.isMethod()) {
&nbsp;                stringBuilder.append(this.getReturnType().asErasure().getActualName()).append(&#39; &#39;);
&nbsp;                stringBuilder.append(this.getDeclaringType().asErasure().getActualName()).append(&#39;.&#39;);
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            stringBuilder.append(this.getName()).append(&#39;(&#39;);
<b class="fc">&nbsp;            boolean first = true;</b>
&nbsp;
&nbsp;            TypeDescription typeDescription;
&nbsp;            for(Iterator var4 = this.getParameters().asTypeList().asErasures().iterator(); var4.hasNext(); stringBuilder.append(typeDescription.getActualName())) {
&nbsp;                typeDescription = (TypeDescription)var4.next();
&nbsp;                if (!first) {
&nbsp;                    stringBuilder.append(&#39;,&#39;);
&nbsp;                } else {
<b class="fc">&nbsp;                    first = false;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            stringBuilder.append(&#39;)&#39;);
&nbsp;            TypeList exceptionTypes = this.getExceptionTypes().asErasures();
&nbsp;            if (!exceptionTypes.isEmpty()) {
&nbsp;                stringBuilder.append(&quot; throws &quot;);
&nbsp;                first = true;
&nbsp;
&nbsp;                TypeDescription typeDescription;
&nbsp;                for(Iterator var8 = exceptionTypes.iterator(); var8.hasNext(); stringBuilder.append(typeDescription.getActualName())) {
&nbsp;                    typeDescription = (TypeDescription)var8.next();
&nbsp;                    if (!first) {
&nbsp;                        stringBuilder.append(&#39;,&#39;);
&nbsp;                    } else {
&nbsp;                        first = false;
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            return stringBuilder.toString();
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public interface InDefinedShape extends MethodDescription {
&nbsp;        @Nonnull
&nbsp;        TypeDescription getDeclaringType();
&nbsp;
&nbsp;        ParameterList&lt;ParameterDescription.InDefinedShape&gt; getParameters();
&nbsp;
&nbsp;        public abstract static class AbstractBase extends AbstractBase implements InDefinedShape {
&nbsp;            public AbstractBase() {
&nbsp;            }
&nbsp;
&nbsp;            public InDefinedShape asDefined() {
&nbsp;                return this;
&nbsp;            }
&nbsp;
&nbsp;            @Nonnull(
&nbsp;                when = When.MAYBE
&nbsp;            )
&nbsp;            public TypeDescription.Generic getReceiverType() {
&nbsp;                if (this.isStatic()) {
&nbsp;                    return Generic.UNDEFINED;
&nbsp;                } else if (this.isConstructor()) {
&nbsp;                    TypeDescription declaringType = this.getDeclaringType();
&nbsp;                    TypeDescription enclosingDeclaringType = this.getDeclaringType().getEnclosingType();
&nbsp;                    if (enclosingDeclaringType == null) {
&nbsp;                        return ForGenerifiedErasure.of(declaringType);
&nbsp;                    } else {
&nbsp;                        return declaringType.isStatic() ? enclosingDeclaringType.asGenericType() : ForGenerifiedErasure.of(enclosingDeclaringType);
&nbsp;                    }
&nbsp;                } else {
&nbsp;                    return ForGenerifiedErasure.of(this.getDeclaringType());
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Proxied(&quot;java.lang.reflect.Executable&quot;)
&nbsp;            protected interface Executable {
&nbsp;                @Nonnull(
&nbsp;                    when = When.MAYBE
&nbsp;                )
&nbsp;                @Defaults
&nbsp;                @Proxied(&quot;getAnnotatedReceiverType&quot;)
&nbsp;                AnnotatedElement getAnnotatedReceiverType(Object var1);
&nbsp;            }
&nbsp;
&nbsp;            protected abstract static class ForLoadedExecutable&lt;T extends AnnotatedElement&gt; extends AbstractBase {
<b class="fc">&nbsp;                protected static final Executable EXECUTABLE;</b>
<b class="fc">&nbsp;                protected final T executable;</b>
<b class="fc">&nbsp;                private static final boolean ACCESS_CONTROLLER;</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                protected ForLoadedExecutable(T executable) {</b>
<b class="fc">&nbsp;                    this.executable = executable;</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                @net.bytebuddy.build.AccessControllerPlugin.Enhance</b>
<b class="fc">&nbsp;                private static &lt;T&gt; T doPrivileged(PrivilegedAction&lt;T&gt; action) {</b>
&nbsp;                    return ACCESS_CONTROLLER ? AccessController.doPrivileged(action) : action.run();
&nbsp;                }
&nbsp;
&nbsp;                public TypeDescription.Generic getReceiverType() {
&nbsp;                    AnnotatedElement element = EXECUTABLE.getAnnotatedReceiverType(this.executable);
&nbsp;                    return element == null ? super.getReceiverType() : Sort.describeAnnotated(element);
&nbsp;                }
&nbsp;
&nbsp;                static {
&nbsp;                    try {
&nbsp;                        Class.forName(&quot;java.security.AccessController&quot;, false, (ClassLoader)null);
&nbsp;                        ACCESS_CONTROLLER = Boolean.parseBoolean(System.getProperty(&quot;net.bytebuddy.securitymanager&quot;, &quot;true&quot;));
&nbsp;                    } catch (ClassNotFoundException var0) {
&nbsp;                        ACCESS_CONTROLLER = false;
&nbsp;                    } catch (SecurityException var1) {
&nbsp;                        ACCESS_CONTROLLER = true;
&nbsp;                    }
&nbsp;
&nbsp;                    EXECUTABLE = (Executable)doPrivileged(JavaDispatcher.of(Executable.class));
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public interface InGenericShape extends MethodDescription {
<b class="fc">&nbsp;        @Nonnull</b>
<b class="fc">&nbsp;        TypeDescription.Generic getDeclaringType();</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;        ParameterList&lt;ParameterDescription.InGenericShape&gt; getParameters();</b>
<b class="fc">&nbsp;    }</b>
<b class="fc">&nbsp;}</b>
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-22 12:48</div>
</div>
</body>
</html>
