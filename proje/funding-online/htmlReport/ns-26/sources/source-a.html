


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=GBK"> 
  <title>Coverage Report > TypeWriter</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.dynamic.scaffold</a>
</div>

<h1>Coverage Summary for Class: TypeWriter (net.bytebuddy.dynamic.scaffold)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
  <tr>
    <td class="name">TypeWriter$Default</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (36/36)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$Default$ClassDumpAction$Dispatcher$Disabled</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$Default$ForCreation</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (38/38)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$Default$UnresolvedType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$Default$ValidatingClassVisitor</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$FieldPool$Record$ForExplicitField</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (13/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$MethodPool$Record$AccessBridgeWrapper</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$MethodPool$Record$ForDefinedMethod</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (13/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$MethodPool$Record$ForDefinedMethod$WithBody</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (16/16)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$MethodPool$Record$ForNonImplementedMethod</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$MethodPool$Record$Sort</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (8/8)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (15/15)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (144/144)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;//
&nbsp;// Source code recreated from a .class file by IntelliJ IDEA
&nbsp;// (powered by FernFlower decompiler)
&nbsp;//
&nbsp;
&nbsp;package net.bytebuddy.dynamic.scaffold;
&nbsp;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import java.io.File;
&nbsp;import java.io.FileOutputStream;
&nbsp;import java.io.IOException;
&nbsp;import java.io.OutputStream;
&nbsp;import java.security.AccessController;
&nbsp;import java.security.PrivilegedAction;
&nbsp;import java.security.PrivilegedExceptionAction;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Collections;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.Iterator;
&nbsp;import java.util.LinkedHashMap;
&nbsp;import java.util.LinkedHashSet;
&nbsp;import java.util.List;
&nbsp;import java.util.Set;
&nbsp;import javax.annotation.CheckForNull;
&nbsp;import javax.annotation.Nonnull;
&nbsp;import javax.annotation.meta.When;
&nbsp;import net.bytebuddy.ClassFileVersion;
&nbsp;import net.bytebuddy.asm.AsmVisitorWrapper;
&nbsp;import net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance;
&nbsp;import net.bytebuddy.build.HashCodeAndEqualsPlugin.ValueHandling;
&nbsp;import net.bytebuddy.description.annotation.AnnotationList;
&nbsp;import net.bytebuddy.description.annotation.AnnotationValue;
&nbsp;import net.bytebuddy.description.field.FieldDescription;
&nbsp;import net.bytebuddy.description.field.FieldList;
&nbsp;import net.bytebuddy.description.method.MethodDescription;
&nbsp;import net.bytebuddy.description.method.MethodList;
&nbsp;import net.bytebuddy.description.method.ParameterDescription;
&nbsp;import net.bytebuddy.description.method.ParameterList;
&nbsp;import net.bytebuddy.description.modifier.Visibility;
&nbsp;import net.bytebuddy.description.modifier.ModifierContributor.Resolver;
&nbsp;import net.bytebuddy.description.type.RecordComponentDescription;
&nbsp;import net.bytebuddy.description.type.RecordComponentList;
&nbsp;import net.bytebuddy.description.type.TypeDefinition;
&nbsp;import net.bytebuddy.description.type.TypeDescription;
&nbsp;import net.bytebuddy.description.type.TypeList;
&nbsp;import net.bytebuddy.description.type.TypeDescription.AbstractBase;
&nbsp;import net.bytebuddy.description.type.TypeDescription.Generic.Visitor.TypeErasing;
&nbsp;import net.bytebuddy.dynamic.ClassFileLocator;
&nbsp;import net.bytebuddy.dynamic.DynamicType;
&nbsp;import net.bytebuddy.dynamic.TypeResolutionStrategy;
&nbsp;import net.bytebuddy.dynamic.scaffold.TypeInitializer.None;
&nbsp;import net.bytebuddy.dynamic.scaffold.inline.MethodRebaseResolver;
&nbsp;import net.bytebuddy.dynamic.scaffold.inline.RebaseImplementationTarget;
&nbsp;import net.bytebuddy.dynamic.scaffold.subclass.SubclassImplementationTarget.Factory;
&nbsp;import net.bytebuddy.implementation.Implementation;
&nbsp;import net.bytebuddy.implementation.LoadedTypeInitializer;
&nbsp;import net.bytebuddy.implementation.attribute.AnnotationAppender;
&nbsp;import net.bytebuddy.implementation.attribute.AnnotationRetention;
&nbsp;import net.bytebuddy.implementation.attribute.AnnotationValueFilter;
&nbsp;import net.bytebuddy.implementation.attribute.FieldAttributeAppender;
&nbsp;import net.bytebuddy.implementation.attribute.MethodAttributeAppender;
&nbsp;import net.bytebuddy.implementation.attribute.RecordComponentAttributeAppender;
&nbsp;import net.bytebuddy.implementation.attribute.TypeAttributeAppender;
&nbsp;import net.bytebuddy.implementation.attribute.FieldAttributeAppender.ForInstrumentedField;
&nbsp;import net.bytebuddy.implementation.attribute.RecordComponentAttributeAppender.ForInstrumentedRecordComponent;
&nbsp;import net.bytebuddy.implementation.auxiliary.AuxiliaryType;
&nbsp;import net.bytebuddy.implementation.bytecode.ByteCodeAppender;
&nbsp;import net.bytebuddy.implementation.bytecode.StackManipulation;
&nbsp;import net.bytebuddy.implementation.bytecode.StackManipulation.Trivial;
&nbsp;import net.bytebuddy.implementation.bytecode.assign.TypeCasting;
&nbsp;import net.bytebuddy.implementation.bytecode.constant.DefaultValue;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodInvocation;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodReturn;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodVariableAccess;
&nbsp;import net.bytebuddy.jar.asm.AnnotationVisitor;
&nbsp;import net.bytebuddy.jar.asm.ClassReader;
&nbsp;import net.bytebuddy.jar.asm.ClassVisitor;
&nbsp;import net.bytebuddy.jar.asm.ClassWriter;
&nbsp;import net.bytebuddy.jar.asm.ConstantDynamic;
&nbsp;import net.bytebuddy.jar.asm.FieldVisitor;
&nbsp;import net.bytebuddy.jar.asm.Handle;
&nbsp;import net.bytebuddy.jar.asm.Label;
&nbsp;import net.bytebuddy.jar.asm.MethodVisitor;
&nbsp;import net.bytebuddy.jar.asm.Opcodes;
&nbsp;import net.bytebuddy.jar.asm.RecordComponentVisitor;
&nbsp;import net.bytebuddy.jar.asm.Type;
&nbsp;import net.bytebuddy.jar.asm.TypePath;
&nbsp;import net.bytebuddy.jar.asm.commons.ClassRemapper;
&nbsp;import net.bytebuddy.jar.asm.commons.Remapper;
&nbsp;import net.bytebuddy.jar.asm.commons.SimpleRemapper;
&nbsp;import net.bytebuddy.matcher.ElementMatchers;
&nbsp;import net.bytebuddy.pool.TypePool;
&nbsp;import net.bytebuddy.utility.CompoundList;
&nbsp;import net.bytebuddy.utility.OpenedClassReader;
&nbsp;import net.bytebuddy.utility.privilege.GetSystemPropertyAction;
&nbsp;import net.bytebuddy.utility.visitor.MetadataAwareClassVisitor;
&nbsp;
&nbsp;public interface TypeWriter&lt;T&gt; {
&nbsp;    String DUMP_PROPERTY = &quot;net.bytebuddy.dump&quot;;
&nbsp;
&nbsp;    DynamicType.Unloaded&lt;T&gt; make(TypeResolutionStrategy.Resolved var1);
&nbsp;
&nbsp;    @Enhance
&nbsp;    public abstract static class Default&lt;S&gt; implements TypeWriter&lt;S&gt; {
&nbsp;        @Nonnull(
&nbsp;            when = When.NEVER
&nbsp;        )
&nbsp;        private static final String NO_REFERENCE;
&nbsp;        @Nonnull(
&nbsp;            when = When.MAYBE
&nbsp;        )
&nbsp;        protected static final String DUMP_FOLDER;
&nbsp;        protected final TypeDescription instrumentedType;
&nbsp;        protected final ClassFileVersion classFileVersion;
&nbsp;        protected final FieldPool fieldPool;
&nbsp;        protected final RecordComponentPool recordComponentPool;
&nbsp;        protected final List&lt;? extends DynamicType&gt; auxiliaryTypes;
&nbsp;        protected final FieldList&lt;FieldDescription.InDefinedShape&gt; fields;
&nbsp;        protected final MethodList&lt;?&gt; methods;
&nbsp;        protected final MethodList&lt;?&gt; instrumentedMethods;
&nbsp;        protected final RecordComponentList&lt;RecordComponentDescription.InDefinedShape&gt; recordComponents;
&nbsp;        protected final LoadedTypeInitializer loadedTypeInitializer;
&nbsp;        protected final TypeInitializer typeInitializer;
&nbsp;        protected final TypeAttributeAppender typeAttributeAppender;
&nbsp;        protected final AsmVisitorWrapper asmVisitorWrapper;
&nbsp;        protected final AnnotationValueFilter.Factory annotationValueFilterFactory;
&nbsp;        protected final AnnotationRetention annotationRetention;
&nbsp;        protected final AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy;
&nbsp;        protected final Implementation.Context.Factory implementationContextFactory;
&nbsp;        protected final TypeValidation typeValidation;
&nbsp;        protected final ClassWriterStrategy classWriterStrategy;
&nbsp;        protected final TypePool typePool;
&nbsp;        private static final boolean ACCESS_CONTROLLER;
&nbsp;
&nbsp;        protected Default(TypeDescription instrumentedType, ClassFileVersion classFileVersion, FieldPool fieldPool, RecordComponentPool recordComponentPool, List&lt;? extends DynamicType&gt; auxiliaryTypes, FieldList&lt;FieldDescription.InDefinedShape&gt; fields, MethodList&lt;?&gt; methods, MethodList&lt;?&gt; instrumentedMethods, RecordComponentList&lt;RecordComponentDescription.InDefinedShape&gt; recordComponents, LoadedTypeInitializer loadedTypeInitializer, TypeInitializer typeInitializer, TypeAttributeAppender typeAttributeAppender, AsmVisitorWrapper asmVisitorWrapper, AnnotationValueFilter.Factory annotationValueFilterFactory, AnnotationRetention annotationRetention, AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy, Implementation.Context.Factory implementationContextFactory, TypeValidation typeValidation, ClassWriterStrategy classWriterStrategy, TypePool typePool) {
&nbsp;            this.instrumentedType = instrumentedType;
&nbsp;            this.classFileVersion = classFileVersion;
&nbsp;            this.fieldPool = fieldPool;
&nbsp;            this.recordComponentPool = recordComponentPool;
&nbsp;            this.auxiliaryTypes = auxiliaryTypes;
&nbsp;            this.fields = fields;
&nbsp;            this.methods = methods;
&nbsp;            this.instrumentedMethods = instrumentedMethods;
&nbsp;            this.recordComponents = recordComponents;
&nbsp;            this.loadedTypeInitializer = loadedTypeInitializer;
&nbsp;            this.typeInitializer = typeInitializer;
&nbsp;            this.typeAttributeAppender = typeAttributeAppender;
&nbsp;            this.asmVisitorWrapper = asmVisitorWrapper;
&nbsp;            this.auxiliaryTypeNamingStrategy = auxiliaryTypeNamingStrategy;
&nbsp;            this.annotationValueFilterFactory = annotationValueFilterFactory;
&nbsp;            this.annotationRetention = annotationRetention;
&nbsp;            this.implementationContextFactory = implementationContextFactory;
&nbsp;            this.typeValidation = typeValidation;
&nbsp;            this.classWriterStrategy = classWriterStrategy;
&nbsp;            this.typePool = typePool;
&nbsp;        }
&nbsp;
&nbsp;        @net.bytebuddy.build.AccessControllerPlugin.Enhance
&nbsp;        private static &lt;T&gt; T doPrivileged(PrivilegedAction&lt;T&gt; action) {
&nbsp;            return ACCESS_CONTROLLER ? AccessController.doPrivileged(action) : action.run();
&nbsp;        }
&nbsp;
&nbsp;        @net.bytebuddy.build.AccessControllerPlugin.Enhance
&nbsp;        private static &lt;T&gt; T doPrivileged(PrivilegedExceptionAction&lt;T&gt; action) throws Exception {
&nbsp;            return ACCESS_CONTROLLER ? AccessController.doPrivileged(action) : action.run();
&nbsp;        }
&nbsp;
&nbsp;        public static &lt;U&gt; TypeWriter&lt;U&gt; forCreation(MethodRegistry.Compiled methodRegistry, List&lt;? extends DynamicType&gt; auxiliaryTypes, FieldPool fieldPool, RecordComponentPool recordComponentPool, TypeAttributeAppender typeAttributeAppender, AsmVisitorWrapper asmVisitorWrapper, ClassFileVersion classFileVersion, AnnotationValueFilter.Factory annotationValueFilterFactory, AnnotationRetention annotationRetention, AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy, Implementation.Context.Factory implementationContextFactory, TypeValidation typeValidation, ClassWriterStrategy classWriterStrategy, TypePool typePool) {
&nbsp;            return new ForCreation(methodRegistry.getInstrumentedType(), classFileVersion, fieldPool, methodRegistry, recordComponentPool, auxiliaryTypes, methodRegistry.getInstrumentedType().getDeclaredFields(), methodRegistry.getMethods(), methodRegistry.getInstrumentedMethods(), methodRegistry.getInstrumentedType().getRecordComponents(), methodRegistry.getLoadedTypeInitializer(), methodRegistry.getTypeInitializer(), typeAttributeAppender, asmVisitorWrapper, annotationValueFilterFactory, annotationRetention, auxiliaryTypeNamingStrategy, implementationContextFactory, typeValidation, classWriterStrategy, typePool);
&nbsp;        }
&nbsp;
&nbsp;        public static &lt;U&gt; TypeWriter&lt;U&gt; forRedefinition(MethodRegistry.Prepared methodRegistry, List&lt;? extends DynamicType&gt; auxiliaryTypes, FieldPool fieldPool, RecordComponentPool recordComponentPool, TypeAttributeAppender typeAttributeAppender, AsmVisitorWrapper asmVisitorWrapper, ClassFileVersion classFileVersion, AnnotationValueFilter.Factory annotationValueFilterFactory, AnnotationRetention annotationRetention, AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy, Implementation.Context.Factory implementationContextFactory, TypeValidation typeValidation, ClassWriterStrategy classWriterStrategy, TypePool typePool, TypeDescription originalType, ClassFileLocator classFileLocator) {
&nbsp;            return new ForInlining.WithFullProcessing(methodRegistry.getInstrumentedType(), classFileVersion, fieldPool, recordComponentPool, auxiliaryTypes, methodRegistry.getInstrumentedType().getDeclaredFields(), methodRegistry.getMethods(), methodRegistry.getInstrumentedMethods(), methodRegistry.getInstrumentedType().getRecordComponents(), methodRegistry.getLoadedTypeInitializer(), methodRegistry.getTypeInitializer(), typeAttributeAppender, asmVisitorWrapper, annotationValueFilterFactory, annotationRetention, auxiliaryTypeNamingStrategy, implementationContextFactory, typeValidation, classWriterStrategy, typePool, originalType, classFileLocator, methodRegistry, Factory.LEVEL_TYPE, net.bytebuddy.dynamic.scaffold.inline.MethodRebaseResolver.Disabled.INSTANCE);
&nbsp;        }
&nbsp;
&nbsp;        public static &lt;U&gt; TypeWriter&lt;U&gt; forRebasing(MethodRegistry.Prepared methodRegistry, List&lt;? extends DynamicType&gt; auxiliaryTypes, FieldPool fieldPool, RecordComponentPool recordComponentPool, TypeAttributeAppender typeAttributeAppender, AsmVisitorWrapper asmVisitorWrapper, ClassFileVersion classFileVersion, AnnotationValueFilter.Factory annotationValueFilterFactory, AnnotationRetention annotationRetention, AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy, Implementation.Context.Factory implementationContextFactory, TypeValidation typeValidation, ClassWriterStrategy classWriterStrategy, TypePool typePool, TypeDescription originalType, ClassFileLocator classFileLocator, MethodRebaseResolver methodRebaseResolver) {
&nbsp;            return new ForInlining.WithFullProcessing(methodRegistry.getInstrumentedType(), classFileVersion, fieldPool, recordComponentPool, CompoundList.of(auxiliaryTypes, methodRebaseResolver.getAuxiliaryTypes()), methodRegistry.getInstrumentedType().getDeclaredFields(), methodRegistry.getMethods(), methodRegistry.getInstrumentedMethods(), methodRegistry.getInstrumentedType().getRecordComponents(), methodRegistry.getLoadedTypeInitializer(), methodRegistry.getTypeInitializer(), typeAttributeAppender, asmVisitorWrapper, annotationValueFilterFactory, annotationRetention, auxiliaryTypeNamingStrategy, implementationContextFactory, typeValidation, classWriterStrategy, typePool, originalType, classFileLocator, methodRegistry, new RebaseImplementationTarget.Factory(methodRebaseResolver), methodRebaseResolver);
&nbsp;        }
&nbsp;
&nbsp;        public static &lt;U&gt; TypeWriter&lt;U&gt; forDecoration(TypeDescription instrumentedType, ClassFileVersion classFileVersion, List&lt;? extends DynamicType&gt; auxiliaryTypes, List&lt;? extends MethodDescription&gt; methods, TypeAttributeAppender typeAttributeAppender, AsmVisitorWrapper asmVisitorWrapper, AnnotationValueFilter.Factory annotationValueFilterFactory, AnnotationRetention annotationRetention, AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy, Implementation.Context.Factory implementationContextFactory, TypeValidation typeValidation, ClassWriterStrategy classWriterStrategy, TypePool typePool, ClassFileLocator classFileLocator) {
&nbsp;            return new ForInlining.WithDecorationOnly(instrumentedType, classFileVersion, auxiliaryTypes, new MethodList.Explicit(methods), typeAttributeAppender, asmVisitorWrapper, annotationValueFilterFactory, annotationRetention, auxiliaryTypeNamingStrategy, implementationContextFactory, typeValidation, classWriterStrategy, typePool, classFileLocator);
&nbsp;        }
&nbsp;
&nbsp;        @SuppressFBWarnings(
&nbsp;            value = {&quot;REC_CATCH_EXCEPTION&quot;},
&nbsp;            justification = &quot;Setting a debugging property should never change the program outcome.&quot;
&nbsp;        )
&nbsp;        public DynamicType.Unloaded&lt;S&gt; make(TypeResolutionStrategy.Resolved typeResolutionStrategy) {
&nbsp;            ClassDumpAction.Dispatcher dispatcher = DUMP_FOLDER == null ? TypeWriter.Default.ClassDumpAction.Dispatcher.Disabled.INSTANCE : new ClassDumpAction.Dispatcher.Enabled(DUMP_FOLDER, System.currentTimeMillis());
&nbsp;            Default&lt;S&gt;.UnresolvedType unresolvedType = this.create(typeResolutionStrategy.injectedInto(this.typeInitializer), (ClassDumpAction.Dispatcher)dispatcher);
&nbsp;            ((ClassDumpAction.Dispatcher)dispatcher).dump(this.instrumentedType, false, unresolvedType.getBinaryRepresentation());
&nbsp;            return unresolvedType.toDynamicType(typeResolutionStrategy);
&nbsp;        }
&nbsp;
&nbsp;        protected abstract Default&lt;S&gt;.UnresolvedType create(TypeInitializer var1, ClassDumpAction.Dispatcher var2);
&nbsp;
&nbsp;        static {
&nbsp;            try {
&nbsp;                Class.forName(&quot;java.security.AccessController&quot;, false, (ClassLoader)null);
&nbsp;                ACCESS_CONTROLLER = Boolean.parseBoolean(System.getProperty(&quot;net.bytebuddy.securitymanager&quot;, &quot;true&quot;));
&nbsp;            } catch (ClassNotFoundException var3) {
&nbsp;                ACCESS_CONTROLLER = false;
&nbsp;            } catch (SecurityException var4) {
&nbsp;                ACCESS_CONTROLLER = true;
&nbsp;            }
&nbsp;
&nbsp;            NO_REFERENCE = null;
&nbsp;
&nbsp;            String dumpFolder;
&nbsp;            try {
&nbsp;                dumpFolder = (String)doPrivileged((PrivilegedAction)(new GetSystemPropertyAction(&quot;net.bytebuddy.dump&quot;)));
&nbsp;            } catch (RuntimeException var2) {
&nbsp;                dumpFolder = null;
&nbsp;            }
&nbsp;
&nbsp;            DUMP_FOLDER = dumpFolder;
&nbsp;        }
&nbsp;
&nbsp;        public boolean equals(Object var1) {
&nbsp;            if (this == var1) {
&nbsp;                return true;
&nbsp;            } else if (var1 == null) {
&nbsp;                return false;
&nbsp;            } else if (this.getClass() != var1.getClass()) {
&nbsp;                return false;
&nbsp;            } else if (!this.annotationRetention.equals(((Default)var1).annotationRetention)) {
&nbsp;                return false;
&nbsp;            } else if (!this.typeValidation.equals(((Default)var1).typeValidation)) {
&nbsp;                return false;
&nbsp;            } else if (!this.instrumentedType.equals(((Default)var1).instrumentedType)) {
&nbsp;                return false;
&nbsp;            } else if (!this.classFileVersion.equals(((Default)var1).classFileVersion)) {
&nbsp;                return false;
&nbsp;            } else if (!this.fieldPool.equals(((Default)var1).fieldPool)) {
&nbsp;                return false;
&nbsp;            } else if (!this.recordComponentPool.equals(((Default)var1).recordComponentPool)) {
&nbsp;                return false;
&nbsp;            } else if (!this.auxiliaryTypes.equals(((Default)var1).auxiliaryTypes)) {
&nbsp;                return false;
&nbsp;            } else if (!this.fields.equals(((Default)var1).fields)) {
&nbsp;                return false;
&nbsp;            } else if (!this.methods.equals(((Default)var1).methods)) {
&nbsp;                return false;
&nbsp;            } else if (!this.instrumentedMethods.equals(((Default)var1).instrumentedMethods)) {
&nbsp;                return false;
&nbsp;            } else if (!this.recordComponents.equals(((Default)var1).recordComponents)) {
&nbsp;                return false;
&nbsp;            } else if (!this.loadedTypeInitializer.equals(((Default)var1).loadedTypeInitializer)) {
&nbsp;                return false;
&nbsp;            } else if (!this.typeInitializer.equals(((Default)var1).typeInitializer)) {
&nbsp;                return false;
&nbsp;            } else if (!this.typeAttributeAppender.equals(((Default)var1).typeAttributeAppender)) {
&nbsp;                return false;
&nbsp;            } else if (!this.asmVisitorWrapper.equals(((Default)var1).asmVisitorWrapper)) {
&nbsp;                return false;
&nbsp;            } else if (!this.annotationValueFilterFactory.equals(((Default)var1).annotationValueFilterFactory)) {
&nbsp;                return false;
&nbsp;            } else if (!this.auxiliaryTypeNamingStrategy.equals(((Default)var1).auxiliaryTypeNamingStrategy)) {
&nbsp;                return false;
&nbsp;            } else if (!this.implementationContextFactory.equals(((Default)var1).implementationContextFactory)) {
&nbsp;                return false;
&nbsp;            } else if (!this.classWriterStrategy.equals(((Default)var1).classWriterStrategy)) {
&nbsp;                return false;
&nbsp;            } else {
<b class="fc">&nbsp;                return this.typePool.equals(((Default)var1).typePool);</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;</b>
&nbsp;        public int hashCode() {
&nbsp;            return (((((((((((((((((((this.getClass().hashCode() * 31 + this.instrumentedType.hashCode()) * 31 + this.classFileVersion.hashCode()) * 31 + this.fieldPool.hashCode()) * 31 + this.recordComponentPool.hashCode()) * 31 + this.auxiliaryTypes.hashCode()) * 31 + this.fields.hashCode()) * 31 + this.methods.hashCode()) * 31 + this.instrumentedMethods.hashCode()) * 31 + this.recordComponents.hashCode()) * 31 + this.loadedTypeInitializer.hashCode()) * 31 + this.typeInitializer.hashCode()) * 31 + this.typeAttributeAppender.hashCode()) * 31 + this.asmVisitorWrapper.hashCode()) * 31 + this.annotationValueFilterFactory.hashCode()) * 31 + this.annotationRetention.hashCode()) * 31 + this.auxiliaryTypeNamingStrategy.hashCode()) * 31 + this.implementationContextFactory.hashCode()) * 31 + this.typeValidation.hashCode()) * 31 + this.classWriterStrategy.hashCode()) * 31 + this.typePool.hashCode();
&nbsp;        }
&nbsp;
&nbsp;        @Enhance
&nbsp;        protected static class ClassDumpAction implements PrivilegedExceptionAction&lt;Void&gt; {
&nbsp;            @Nonnull(
&nbsp;                when = When.NEVER
&nbsp;            )
&nbsp;            private static final Void NOTHING = null;
&nbsp;            private final String target;
&nbsp;            private final TypeDescription instrumentedType;
&nbsp;            private final boolean original;
&nbsp;            private final long suffix;
&nbsp;            private final byte[] binaryRepresentation;
&nbsp;
&nbsp;            protected ClassDumpAction(String target, TypeDescription instrumentedType, boolean original, long suffix, byte[] binaryRepresentation) {
&nbsp;                this.target = target;
&nbsp;                this.instrumentedType = instrumentedType;
&nbsp;                this.original = original;
&nbsp;                this.suffix = suffix;
&nbsp;                this.binaryRepresentation = binaryRepresentation;
&nbsp;            }
&nbsp;
&nbsp;            public Void run() throws Exception {
&nbsp;                OutputStream outputStream = new FileOutputStream(new File(this.target, this.instrumentedType.getName() + (this.original ? &quot;-original.&quot; : &quot;.&quot;) + this.suffix + &quot;.class&quot;));
&nbsp;
&nbsp;                Void var2;
<b class="fc">&nbsp;                try {</b>
&nbsp;                    outputStream.write(this.binaryRepresentation);
&nbsp;                    var2 = NOTHING;
&nbsp;                } finally {
&nbsp;                    outputStream.close();
&nbsp;                }
&nbsp;
&nbsp;                return var2;
&nbsp;            }
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;            public boolean equals(Object var1) {</b>
<b class="fc">&nbsp;                if (this == var1) {</b>
<b class="fc">&nbsp;                    return true;</b>
<b class="fc">&nbsp;                } else if (var1 == null) {</b>
<b class="fc">&nbsp;                    return false;</b>
<b class="fc">&nbsp;                } else if (this.getClass() != var1.getClass()) {</b>
<b class="fc">&nbsp;                    return false;</b>
&nbsp;                } else if (this.original != ((ClassDumpAction)var1).original) {
&nbsp;                    return false;
&nbsp;                } else if (this.suffix != ((ClassDumpAction)var1).suffix) {
&nbsp;                    return false;
&nbsp;                } else if (!this.target.equals(((ClassDumpAction)var1).target)) {
&nbsp;                    return false;
&nbsp;                } else if (!this.instrumentedType.equals(((ClassDumpAction)var1).instrumentedType)) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return Arrays.equals(this.binaryRepresentation, ((ClassDumpAction)var1).binaryRepresentation);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public int hashCode() {
&nbsp;                int var10000 = (((this.getClass().hashCode() * 31 + this.target.hashCode()) * 31 + this.instrumentedType.hashCode()) * 31 + this.original) * 31;
&nbsp;                long var10001 = this.suffix;
&nbsp;                return (var10000 + (int)(var10001 ^ var10001 &gt;&gt;&gt; 32)) * 31 + Arrays.hashCode(this.binaryRepresentation);
&nbsp;            }
&nbsp;
&nbsp;            protected interface Dispatcher {
&nbsp;                void dump(TypeDescription var1, boolean var2, byte[] var3);
&nbsp;
&nbsp;                @Enhance
&nbsp;                public static class Enabled implements Dispatcher {
&nbsp;                    private final String folder;
&nbsp;                    private final long timestamp;
&nbsp;
&nbsp;                    protected Enabled(String folder, long timestamp) {
&nbsp;                        this.folder = folder;
&nbsp;                        this.timestamp = timestamp;
&nbsp;                    }
&nbsp;
&nbsp;                    public void dump(TypeDescription instrumentedType, boolean original, byte[] binaryRepresentation) {
&nbsp;                        try {
&nbsp;                            TypeWriter.Default.doPrivileged((PrivilegedExceptionAction)(new ClassDumpAction(this.folder, instrumentedType, original, this.timestamp, binaryRepresentation)));
&nbsp;                        } catch (Exception var5) {
&nbsp;                            var5.printStackTrace();
&nbsp;                        }
&nbsp;
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(Object var1) {
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else if (this.timestamp != ((Enabled)var1).timestamp) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return this.folder.equals(((Enabled)var1).folder);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        int var10000 = (this.getClass().hashCode() * 31 + this.folder.hashCode()) * 31;
&nbsp;                        long var10001 = this.timestamp;
&nbsp;                        return var10000 + (int)(var10001 ^ var10001 &gt;&gt;&gt; 32);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public static enum Disabled implements Dispatcher {
&nbsp;                    INSTANCE;
&nbsp;
&nbsp;                    private Disabled() {
&nbsp;                    }
&nbsp;
&nbsp;                    public void dump(TypeDescription instrumentedType, boolean original, byte[] binaryRepresentation) {
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Enhance
&nbsp;        public static class ForCreation&lt;U&gt; extends Default&lt;U&gt; {
&nbsp;            private final MethodPool methodPool;
&nbsp;
&nbsp;            protected ForCreation(TypeDescription instrumentedType, ClassFileVersion classFileVersion, FieldPool fieldPool, MethodPool methodPool, RecordComponentPool recordComponentPool, List&lt;? extends DynamicType&gt; auxiliaryTypes, FieldList&lt;FieldDescription.InDefinedShape&gt; fields, MethodList&lt;?&gt; methods, MethodList&lt;?&gt; instrumentedMethods, RecordComponentList&lt;RecordComponentDescription.InDefinedShape&gt; recordComponents, LoadedTypeInitializer loadedTypeInitializer, TypeInitializer typeInitializer, TypeAttributeAppender typeAttributeAppender, AsmVisitorWrapper asmVisitorWrapper, AnnotationValueFilter.Factory annotationValueFilterFactory, AnnotationRetention annotationRetention, AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy, Implementation.Context.Factory implementationContextFactory, TypeValidation typeValidation, ClassWriterStrategy classWriterStrategy, TypePool typePool) {
&nbsp;                super(instrumentedType, classFileVersion, fieldPool, recordComponentPool, auxiliaryTypes, fields, methods, instrumentedMethods, recordComponents, loadedTypeInitializer, typeInitializer, typeAttributeAppender, asmVisitorWrapper, annotationValueFilterFactory, annotationRetention, auxiliaryTypeNamingStrategy, implementationContextFactory, typeValidation, classWriterStrategy, typePool);
&nbsp;                this.methodPool = methodPool;
&nbsp;            }
&nbsp;
&nbsp;            @SuppressFBWarnings(
&nbsp;                value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;                justification = &quot;Relying on correlated type properties.&quot;
&nbsp;            )
&nbsp;            protected Default&lt;U&gt;.UnresolvedType create(TypeInitializer typeInitializer, ClassDumpAction.Dispatcher dispatcher) {
&nbsp;                int writerFlags = this.asmVisitorWrapper.mergeWriter(0);
&nbsp;                ClassWriter classWriter = this.classWriterStrategy.resolve(writerFlags, this.typePool);
&nbsp;                Implementation.Context.ExtractableView implementationContext = this.implementationContextFactory.make(this.instrumentedType, this.auxiliaryTypeNamingStrategy, typeInitializer, this.classFileVersion, this.classFileVersion);
&nbsp;                ClassVisitor classVisitor = this.asmVisitorWrapper.wrap(this.instrumentedType, TypeWriter.Default.ValidatingClassVisitor.of(classWriter, this.typeValidation), implementationContext, this.typePool, this.fields, this.methods, writerFlags, this.asmVisitorWrapper.mergeReader(0));
&nbsp;                classVisitor.visit(this.classFileVersion.getMinorMajorVersion(), this.instrumentedType.getActualModifiers(!this.instrumentedType.isInterface()), this.instrumentedType.getInternalName(), this.instrumentedType.getGenericSignature(), (this.instrumentedType.getSuperClass() == null ? TypeDescription.OBJECT : this.instrumentedType.getSuperClass().asErasure()).getInternalName(), this.instrumentedType.getInterfaces().asErasures().toInternalNames());
&nbsp;                if (!this.instrumentedType.isNestHost()) {
&nbsp;                    classVisitor.visitNestHost(this.instrumentedType.getNestHost().getInternalName());
&nbsp;                }
&nbsp;
&nbsp;                MethodDescription.InDefinedShape enclosingMethod = this.instrumentedType.getEnclosingMethod();
&nbsp;                if (enclosingMethod != null) {
&nbsp;                    classVisitor.visitOuterClass(enclosingMethod.getDeclaringType().getInternalName(), enclosingMethod.getInternalName(), enclosingMethod.getDescriptor());
&nbsp;                } else if (this.instrumentedType.isLocalType() || this.instrumentedType.isAnonymousType()) {
&nbsp;                    classVisitor.visitOuterClass(this.instrumentedType.getEnclosingType().getInternalName(), TypeWriter.Default.NO_REFERENCE, TypeWriter.Default.NO_REFERENCE);
&nbsp;                }
&nbsp;
&nbsp;                this.typeAttributeAppender.apply(classVisitor, this.instrumentedType, this.annotationValueFilterFactory.on(this.instrumentedType));
&nbsp;                Iterator var8;
&nbsp;                TypeDescription typeDescription;
&nbsp;                if (this.instrumentedType.isNestHost()) {
&nbsp;                    var8 = ((TypeList)this.instrumentedType.getNestMembers().filter(ElementMatchers.not(ElementMatchers.is(this.instrumentedType)))).iterator();
&nbsp;
&nbsp;                    while(var8.hasNext()) {
&nbsp;                        typeDescription = (TypeDescription)var8.next();
&nbsp;                        classVisitor.visitNestMember(typeDescription.getInternalName());
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                var8 = this.instrumentedType.getPermittedSubtypes().iterator();
&nbsp;
&nbsp;                while(var8.hasNext()) {
&nbsp;                    typeDescription = (TypeDescription)var8.next();
&nbsp;                    classVisitor.visitPermittedSubclass(typeDescription.getInternalName());
&nbsp;                }
&nbsp;
&nbsp;                TypeDescription declaringType = this.instrumentedType.getDeclaringType();
&nbsp;                if (declaringType != null) {
&nbsp;                    classVisitor.visitInnerClass(this.instrumentedType.getInternalName(), declaringType.getInternalName(), this.instrumentedType.getSimpleName(), this.instrumentedType.getModifiers());
&nbsp;                } else if (this.instrumentedType.isLocalType()) {
&nbsp;                    classVisitor.visitInnerClass(this.instrumentedType.getInternalName(), TypeWriter.Default.NO_REFERENCE, this.instrumentedType.getSimpleName(), this.instrumentedType.getModifiers());
&nbsp;                } else if (this.instrumentedType.isAnonymousType()) {
&nbsp;                    classVisitor.visitInnerClass(this.instrumentedType.getInternalName(), TypeWriter.Default.NO_REFERENCE, TypeWriter.Default.NO_REFERENCE, this.instrumentedType.getModifiers());
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                Iterator var12 = this.instrumentedType.getDeclaredTypes().iterator();
&nbsp;
&nbsp;                while(var12.hasNext()) {
<b class="fc">&nbsp;                    TypeDescription typeDescription = (TypeDescription)var12.next();</b>
&nbsp;                    classVisitor.visitInnerClass(typeDescription.getInternalName(), typeDescription.isMemberType() ? this.instrumentedType.getInternalName() : TypeWriter.Default.NO_REFERENCE, typeDescription.isAnonymousType() ? TypeWriter.Default.NO_REFERENCE : typeDescription.getSimpleName(), typeDescription.getModifiers());
&nbsp;                }
&nbsp;
&nbsp;                var12 = this.recordComponents.iterator();
<b class="fc">&nbsp;</b>
&nbsp;                while(var12.hasNext()) {
&nbsp;                    RecordComponentDescription recordComponentDescription = (RecordComponentDescription)var12.next();
&nbsp;                    this.recordComponentPool.target(recordComponentDescription).apply(classVisitor, this.annotationValueFilterFactory);
&nbsp;                }
<b class="fc">&nbsp;</b>
&nbsp;                var12 = this.fields.iterator();
&nbsp;
&nbsp;                while(var12.hasNext()) {
&nbsp;                    FieldDescription fieldDescription = (FieldDescription)var12.next();
&nbsp;                    this.fieldPool.target(fieldDescription).apply(classVisitor, this.annotationValueFilterFactory);
&nbsp;                }
&nbsp;
&nbsp;                var12 = this.instrumentedMethods.iterator();
&nbsp;
&nbsp;                while(var12.hasNext()) {
&nbsp;                    MethodDescription methodDescription = (MethodDescription)var12.next();
&nbsp;                    this.methodPool.target(methodDescription).apply(classVisitor, implementationContext, this.annotationValueFilterFactory);
&nbsp;                }
&nbsp;
&nbsp;                implementationContext.drain(new TypeInitializer.Drain.Default(this.instrumentedType, this.methodPool, this.annotationValueFilterFactory), classVisitor, this.annotationValueFilterFactory);
&nbsp;                classVisitor.visitEnd();
&nbsp;                return new UnresolvedType(classWriter.toByteArray(), implementationContext.getAuxiliaryTypes());
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;            public boolean equals(Object var1) {</b>
&nbsp;                if (!super.equals(var1)) {
&nbsp;                    return false;
&nbsp;                } else if (this == var1) {
&nbsp;                    return true;
&nbsp;                } else if (var1 == null) {
&nbsp;                    return false;
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return this.methodPool.equals(((ForCreation)var1).methodPool);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public int hashCode() {
&nbsp;                return super.hashCode() * 31 + this.methodPool.hashCode();
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;</b>
&nbsp;        @Enhance
&nbsp;        public abstract static class ForInlining&lt;U&gt; extends Default&lt;U&gt; {
&nbsp;            @Nonnull(
&nbsp;                when = When.NEVER
&nbsp;            )
&nbsp;            private static final FieldVisitor IGNORE_FIELD = null;
&nbsp;            @Nonnull(
&nbsp;                when = When.NEVER
&nbsp;            )
&nbsp;            private static final MethodVisitor IGNORE_METHOD = null;
&nbsp;            @Nonnull(
&nbsp;                when = When.NEVER
&nbsp;            )
&nbsp;            private static final RecordComponentVisitor IGNORE_RECORD_COMPONENT = null;
&nbsp;            @Nonnull(
&nbsp;                when = When.NEVER
&nbsp;            )
&nbsp;            private static final AnnotationVisitor IGNORE_ANNOTATION = null;
&nbsp;            protected final TypeDescription originalType;
<b class="fc">&nbsp;            protected final ClassFileLocator classFileLocator;</b>
<b class="fc">&nbsp;</b>
&nbsp;            protected ForInlining(TypeDescription instrumentedType, ClassFileVersion classFileVersion, FieldPool fieldPool, RecordComponentPool recordComponentPool, List&lt;? extends DynamicType&gt; auxiliaryTypes, FieldList&lt;FieldDescription.InDefinedShape&gt; fields, MethodList&lt;?&gt; methods, MethodList&lt;?&gt; instrumentedMethods, RecordComponentList&lt;RecordComponentDescription.InDefinedShape&gt; recordComponents, LoadedTypeInitializer loadedTypeInitializer, TypeInitializer typeInitializer, TypeAttributeAppender typeAttributeAppender, AsmVisitorWrapper asmVisitorWrapper, AnnotationValueFilter.Factory annotationValueFilterFactory, AnnotationRetention annotationRetention, AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy, Implementation.Context.Factory implementationContextFactory, TypeValidation typeValidation, ClassWriterStrategy classWriterStrategy, TypePool typePool, TypeDescription originalType, ClassFileLocator classFileLocator) {
&nbsp;                super(instrumentedType, classFileVersion, fieldPool, recordComponentPool, auxiliaryTypes, fields, methods, instrumentedMethods, recordComponents, loadedTypeInitializer, typeInitializer, typeAttributeAppender, asmVisitorWrapper, annotationValueFilterFactory, annotationRetention, auxiliaryTypeNamingStrategy, implementationContextFactory, typeValidation, classWriterStrategy, typePool);
&nbsp;                this.originalType = originalType;
&nbsp;                this.classFileLocator = classFileLocator;
&nbsp;            }
&nbsp;
&nbsp;            protected Default&lt;U&gt;.UnresolvedType create(TypeInitializer typeInitializer, ClassDumpAction.Dispatcher dispatcher) {
<b class="fc">&nbsp;                try {</b>
&nbsp;                    int writerFlags = this.asmVisitorWrapper.mergeWriter(0);
&nbsp;                    int readerFlags = this.asmVisitorWrapper.mergeReader(0);
&nbsp;                    byte[] binaryRepresentation = this.classFileLocator.locate(this.originalType.getName()).resolve();
&nbsp;                    dispatcher.dump(this.instrumentedType, true, binaryRepresentation);
&nbsp;                    ClassReader classReader = OpenedClassReader.of(binaryRepresentation);
&nbsp;                    ClassWriter classWriter = this.classWriterStrategy.resolve(writerFlags, this.typePool, classReader);
&nbsp;                    ContextRegistry contextRegistry = new ContextRegistry();
&nbsp;                    classReader.accept(this.writeTo(TypeWriter.Default.ValidatingClassVisitor.of(classWriter, this.typeValidation), typeInitializer, contextRegistry, writerFlags, readerFlags), readerFlags);
&nbsp;                    return new UnresolvedType(classWriter.toByteArray(), contextRegistry.getAuxiliaryTypes());
&nbsp;                } catch (IOException var9) {
&nbsp;                    throw new RuntimeException(&quot;The class file could not be written&quot;, var9);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            protected abstract ClassVisitor writeTo(ClassVisitor var1, TypeInitializer var2, ContextRegistry var3, int var4, int var5);
&nbsp;
&nbsp;            public boolean equals(Object var1) {
&nbsp;                if (!super.equals(var1)) {
&nbsp;                    return false;
&nbsp;                } else if (this == var1) {
&nbsp;                    return true;
&nbsp;                } else if (var1 == null) {
&nbsp;                    return false;
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
&nbsp;                } else if (!this.originalType.equals(((ForInlining)var1).originalType)) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return this.classFileLocator.equals(((ForInlining)var1).classFileLocator);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public int hashCode() {
&nbsp;                return (super.hashCode() * 31 + this.originalType.hashCode()) * 31 + this.classFileLocator.hashCode();
&nbsp;            }
&nbsp;
&nbsp;            protected static class WithDecorationOnly&lt;V&gt; extends ForInlining&lt;V&gt; {
&nbsp;                protected WithDecorationOnly(TypeDescription instrumentedType, ClassFileVersion classFileVersion, List&lt;? extends DynamicType&gt; auxiliaryTypes, MethodList&lt;?&gt; methods, TypeAttributeAppender typeAttributeAppender, AsmVisitorWrapper asmVisitorWrapper, AnnotationValueFilter.Factory annotationValueFilterFactory, AnnotationRetention annotationRetention, AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy, Implementation.Context.Factory implementationContextFactory, TypeValidation typeValidation, ClassWriterStrategy classWriterStrategy, TypePool typePool, ClassFileLocator classFileLocator) {
&nbsp;                    super(instrumentedType, classFileVersion, TypeWriter.FieldPool.Disabled.INSTANCE, TypeWriter.RecordComponentPool.Disabled.INSTANCE, auxiliaryTypes, new LazyFieldList(instrumentedType), methods, new MethodList.Empty(), new RecordComponentList.Empty(), net.bytebuddy.implementation.LoadedTypeInitializer.NoOp.INSTANCE, None.INSTANCE, typeAttributeAppender, asmVisitorWrapper, annotationValueFilterFactory, annotationRetention, auxiliaryTypeNamingStrategy, implementationContextFactory, typeValidation, classWriterStrategy, typePool, instrumentedType, classFileLocator);
&nbsp;                }
&nbsp;
&nbsp;                protected ClassVisitor writeTo(ClassVisitor classVisitor, TypeInitializer typeInitializer, ContextRegistry contextRegistry, int writerFlags, int readerFlags) {
&nbsp;                    if (typeInitializer.isDefined()) {
&nbsp;                        throw new UnsupportedOperationException(&quot;Cannot apply a type initializer for a decoration&quot;);
&nbsp;                    } else {
&nbsp;                        return new DecorationClassVisitor(classVisitor, contextRegistry, writerFlags, readerFlags);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @SuppressFBWarnings(
&nbsp;                    value = {&quot;UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR&quot;},
&nbsp;                    justification = &quot;Field access order is implied by ASM.&quot;
&nbsp;                )
&nbsp;                protected class DecorationClassVisitor extends MetadataAwareClassVisitor implements TypeInitializer.Drain {
<b class="fc">&nbsp;                    private final ContextRegistry contextRegistry;</b>
<b class="fc">&nbsp;                    private final int writerFlags;</b>
&nbsp;                    private final int readerFlags;
&nbsp;                    @Nonnull(
&nbsp;                        when = When.UNKNOWN
&nbsp;                    )
&nbsp;                    private Implementation.Context.ExtractableView implementationContext;
&nbsp;
<b class="fc">&nbsp;                    protected DecorationClassVisitor(ClassVisitor classVisitor, ContextRegistry contextRegistry, int writerFlags, int readerFlags) {</b>
&nbsp;                        super(OpenedClassReader.ASM_API, classVisitor);
&nbsp;                        this.contextRegistry = contextRegistry;
&nbsp;                        this.writerFlags = writerFlags;
&nbsp;                        this.readerFlags = readerFlags;
&nbsp;                    }
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                    public void visit(int classFileVersionNumber, int modifiers, String internalName, String genericSignature, String superClassInternalName, String[] interfaceTypeInternalName) {</b>
<b class="fc">&nbsp;                        ClassFileVersion classFileVersion = ClassFileVersion.ofMinorMajor(classFileVersionNumber);</b>
<b class="fc">&nbsp;                        this.implementationContext = WithDecorationOnly.this.implementationContextFactory.make(WithDecorationOnly.this.instrumentedType, WithDecorationOnly.this.auxiliaryTypeNamingStrategy, WithDecorationOnly.this.typeInitializer, classFileVersion, WithDecorationOnly.this.classFileVersion);</b>
<b class="fc">&nbsp;                        this.contextRegistry.setImplementationContext(this.implementationContext);</b>
<b class="fc">&nbsp;                        this.cv = WithDecorationOnly.this.asmVisitorWrapper.wrap(WithDecorationOnly.this.instrumentedType, this.cv, this.implementationContext, WithDecorationOnly.this.typePool, WithDecorationOnly.this.fields, WithDecorationOnly.this.methods, this.writerFlags, this.readerFlags);</b>
<b class="fc">&nbsp;                        this.cv.visit(classFileVersionNumber, modifiers, internalName, genericSignature, superClassInternalName, interfaceTypeInternalName);</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;</b>
&nbsp;                    @Nonnull(
&nbsp;                        when = When.MAYBE
&nbsp;                    )
<b class="fc">&nbsp;                    protected AnnotationVisitor onVisitTypeAnnotation(int typeReference, TypePath typePath, String descriptor, boolean visible) {</b>
<b class="fc">&nbsp;                        return WithDecorationOnly.this.annotationRetention.isEnabled() ? this.cv.visitTypeAnnotation(typeReference, typePath, descriptor, visible) : TypeWriter.Default.ForInlining.IGNORE_ANNOTATION;</b>
<b class="fc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    @Nonnull(
&nbsp;                        when = When.MAYBE
&nbsp;                    )
&nbsp;                    protected AnnotationVisitor onVisitAnnotation(String descriptor, boolean visible) {
&nbsp;                        return WithDecorationOnly.this.annotationRetention.isEnabled() ? this.cv.visitAnnotation(descriptor, visible) : TypeWriter.Default.ForInlining.IGNORE_ANNOTATION;
&nbsp;                    }
&nbsp;
&nbsp;                    protected void onAfterAttributes() {
&nbsp;                        WithDecorationOnly.this.typeAttributeAppender.apply(this.cv, WithDecorationOnly.this.instrumentedType, WithDecorationOnly.this.annotationValueFilterFactory.on(WithDecorationOnly.this.instrumentedType));
&nbsp;                    }
&nbsp;
&nbsp;                    protected void onVisitEnd() {
&nbsp;                        this.implementationContext.drain(this, this.cv, WithDecorationOnly.this.annotationValueFilterFactory);
&nbsp;                        this.cv.visitEnd();
&nbsp;                    }
&nbsp;
&nbsp;                    public void apply(ClassVisitor classVisitor, TypeInitializer typeInitializer, Implementation.Context implementationContext) {
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                protected static class LazyFieldList extends FieldList.AbstractBase&lt;FieldDescription.InDefinedShape&gt; {
&nbsp;                    private final TypeDescription instrumentedType;
&nbsp;
&nbsp;                    protected LazyFieldList(TypeDescription instrumentedType) {
&nbsp;                        this.instrumentedType = instrumentedType;
&nbsp;                    }
&nbsp;
&nbsp;                    public FieldDescription.InDefinedShape get(int index) {
&nbsp;                        return (FieldDescription.InDefinedShape)this.instrumentedType.getDeclaredFields().get(index);
&nbsp;                    }
&nbsp;
&nbsp;                    public int size() {
&nbsp;                        return this.instrumentedType.getDeclaredFields().size();
&nbsp;                    }
&nbsp;                }
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            @Enhance
&nbsp;            protected static class WithFullProcessing&lt;V&gt; extends ForInlining&lt;V&gt; {
&nbsp;                private static final Object[] EMPTY = new Object[0];
&nbsp;                private final MethodRegistry.Prepared methodRegistry;
&nbsp;                private final Implementation.Target.Factory implementationTargetFactory;
&nbsp;                private final MethodRebaseResolver methodRebaseResolver;
&nbsp;
&nbsp;                protected WithFullProcessing(TypeDescription instrumentedType, ClassFileVersion classFileVersion, FieldPool fieldPool, RecordComponentPool recordComponentPool, List&lt;? extends DynamicType&gt; auxiliaryTypes, FieldList&lt;FieldDescription.InDefinedShape&gt; fields, MethodList&lt;?&gt; methods, MethodList&lt;?&gt; instrumentedMethods, RecordComponentList&lt;RecordComponentDescription.InDefinedShape&gt; recordComponents, LoadedTypeInitializer loadedTypeInitializer, TypeInitializer typeInitializer, TypeAttributeAppender typeAttributeAppender, AsmVisitorWrapper asmVisitorWrapper, AnnotationValueFilter.Factory annotationValueFilterFactory, AnnotationRetention annotationRetention, AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy, Implementation.Context.Factory implementationContextFactory, TypeValidation typeValidation, ClassWriterStrategy classWriterStrategy, TypePool typePool, TypeDescription originalType, ClassFileLocator classFileLocator, MethodRegistry.Prepared methodRegistry, Implementation.Target.Factory implementationTargetFactory, MethodRebaseResolver methodRebaseResolver) {
&nbsp;                    super(instrumentedType, classFileVersion, fieldPool, recordComponentPool, auxiliaryTypes, fields, methods, instrumentedMethods, recordComponents, loadedTypeInitializer, typeInitializer, typeAttributeAppender, asmVisitorWrapper, annotationValueFilterFactory, annotationRetention, auxiliaryTypeNamingStrategy, implementationContextFactory, typeValidation, classWriterStrategy, typePool, originalType, classFileLocator);
&nbsp;                    this.methodRegistry = methodRegistry;
&nbsp;                    this.implementationTargetFactory = implementationTargetFactory;
&nbsp;                    this.methodRebaseResolver = methodRebaseResolver;
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                protected ClassVisitor writeTo(ClassVisitor classVisitor, TypeInitializer typeInitializer, ContextRegistry contextRegistry, int writerFlags, int readerFlags) {</b>
<b class="fc">&nbsp;                    ClassVisitor classVisitor = new RedefinitionClassVisitor(classVisitor, typeInitializer, contextRegistry, writerFlags, readerFlags);</b>
<b class="fc">&nbsp;                    return (ClassVisitor)(this.originalType.getName().equals(this.instrumentedType.getName()) ? classVisitor : new OpenedClassRemapper(classVisitor, new SimpleRemapper(this.originalType.getInternalName(), this.instrumentedType.getInternalName())));</b>
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(Object var1) {
&nbsp;                    if (!super.equals(var1)) {
&nbsp;                        return false;
&nbsp;                    } else if (this == var1) {
<b class="fc">&nbsp;                        return true;</b>
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.methodRegistry.equals(((WithFullProcessing)var1).methodRegistry)) {
&nbsp;                        return false;
<b class="fc">&nbsp;                    } else if (!this.implementationTargetFactory.equals(((WithFullProcessing)var1).implementationTargetFactory)) {</b>
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.methodRebaseResolver.equals(((WithFullProcessing)var1).methodRebaseResolver);
&nbsp;                    }
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                public int hashCode() {</b>
&nbsp;                    return ((super.hashCode() * 31 + this.methodRegistry.hashCode()) * 31 + this.implementationTargetFactory.hashCode()) * 31 + this.methodRebaseResolver.hashCode();
&nbsp;                }
&nbsp;
&nbsp;                protected static class SignatureKey {
&nbsp;                    private final String internalName;
&nbsp;                    private final String descriptor;
&nbsp;
<b class="fc">&nbsp;                    public SignatureKey(String internalName, String descriptor) {</b>
&nbsp;                        this.internalName = internalName;
&nbsp;                        this.descriptor = descriptor;
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(@CheckForNull Object other) {
<b class="fc">&nbsp;                        if (this == other) {</b>
<b class="fc">&nbsp;                            return true;</b>
<b class="fc">&nbsp;                        } else if (other != null &amp;&amp; this.getClass() == other.getClass()) {</b>
<b class="fc">&nbsp;                            SignatureKey that = (SignatureKey)other;</b>
&nbsp;                            return this.internalName.equals(that.internalName) &amp;&amp; this.descriptor.equals(that.descriptor);
&nbsp;                        } else {
&nbsp;                            return false;
&nbsp;                        }
&nbsp;                    }
&nbsp;
<b class="fc">&nbsp;                    public int hashCode() {</b>
&nbsp;                        return 17 + this.internalName.hashCode() + 31 * this.descriptor.hashCode();
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @SuppressFBWarnings(
&nbsp;                    value = {&quot;UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR&quot;},
<b class="fc">&nbsp;                    justification = &quot;Field access order is implied by ASM.&quot;</b>
&nbsp;                )
&nbsp;                protected class RedefinitionClassVisitor extends MetadataAwareClassVisitor {
&nbsp;                    private final TypeInitializer typeInitializer;
&nbsp;                    private final ContextRegistry contextRegistry;
&nbsp;                    private final int writerFlags;
&nbsp;                    private final int readerFlags;
&nbsp;                    private final LinkedHashMap&lt;SignatureKey, FieldDescription&gt; declarableFields;
&nbsp;                    private final LinkedHashMap&lt;SignatureKey, MethodDescription&gt; declarableMethods;
&nbsp;                    private final LinkedHashMap&lt;String, RecordComponentDescription&gt; declarableRecordComponents;
&nbsp;                    private final Set&lt;String&gt; nestMembers;
&nbsp;                    private final LinkedHashMap&lt;String, TypeDescription&gt; declaredTypes;
&nbsp;                    @Nonnull(
&nbsp;                        when = When.MAYBE
&nbsp;                    )
&nbsp;                    private final Set&lt;String&gt; permittedSubclasses;
&nbsp;                    @Nonnull(
&nbsp;                        when = When.UNKNOWN
&nbsp;                    )
&nbsp;                    private MethodPool methodPool;
&nbsp;                    @Nonnull(
&nbsp;                        when = When.UNKNOWN
&nbsp;                    )
&nbsp;                    private InitializationHandler initializationHandler;
&nbsp;                    @Nonnull(
&nbsp;                        when = When.UNKNOWN
&nbsp;                    )
&nbsp;                    private Implementation.Context.ExtractableView implementationContext;
&nbsp;                    private boolean retainDeprecationModifiers;
&nbsp;
&nbsp;                    protected RedefinitionClassVisitor(ClassVisitor classVisitor, TypeInitializer typeInitializer, ContextRegistry contextRegistry, int writerFlags, int readerFlags) {
&nbsp;                        super(OpenedClassReader.ASM_API, classVisitor);
&nbsp;                        this.typeInitializer = typeInitializer;
&nbsp;                        this.contextRegistry = contextRegistry;
&nbsp;                        this.writerFlags = writerFlags;
&nbsp;                        this.readerFlags = readerFlags;
&nbsp;                        this.declarableFields = new LinkedHashMap((int)Math.ceil((double)WithFullProcessing.this.fields.size() / 0.75));
&nbsp;                        Iterator var7 = WithFullProcessing.this.fields.iterator();
&nbsp;
&nbsp;                        while(var7.hasNext()) {
&nbsp;                            FieldDescription fieldDescription = (FieldDescription)var7.next();
&nbsp;                            this.declarableFields.put(new SignatureKey(fieldDescription.getInternalName(), fieldDescription.getDescriptor()), fieldDescription);
&nbsp;                        }
&nbsp;
&nbsp;                        this.declarableMethods = new LinkedHashMap((int)Math.ceil((double)WithFullProcessing.this.instrumentedMethods.size() / 0.75));
&nbsp;                        var7 = WithFullProcessing.this.instrumentedMethods.iterator();
&nbsp;
&nbsp;                        while(var7.hasNext()) {
&nbsp;                            MethodDescription methodDescription = (MethodDescription)var7.next();
&nbsp;                            this.declarableMethods.put(new SignatureKey(methodDescription.getInternalName(), methodDescription.getDescriptor()), methodDescription);
&nbsp;                        }
&nbsp;
&nbsp;                        this.declarableRecordComponents = new LinkedHashMap((int)Math.ceil((double)WithFullProcessing.this.recordComponents.size() / 0.75));
&nbsp;                        var7 = WithFullProcessing.this.recordComponents.iterator();
&nbsp;
&nbsp;                        while(var7.hasNext()) {
&nbsp;                            RecordComponentDescription recordComponentDescription = (RecordComponentDescription)var7.next();
&nbsp;                            this.declarableRecordComponents.put(recordComponentDescription.getActualName(), recordComponentDescription);
&nbsp;                        }
&nbsp;
&nbsp;                        TypeDescription typeDescription;
&nbsp;                        if (WithFullProcessing.this.instrumentedType.isNestHost()) {
&nbsp;                            this.nestMembers = new LinkedHashSet((int)Math.ceil((double)WithFullProcessing.this.instrumentedType.getNestMembers().size() / 0.75));
&nbsp;                            var7 = ((TypeList)WithFullProcessing.this.instrumentedType.getNestMembers().filter(ElementMatchers.not(ElementMatchers.is(WithFullProcessing.this.instrumentedType)))).iterator();
&nbsp;
&nbsp;                            while(var7.hasNext()) {
&nbsp;                                typeDescription = (TypeDescription)var7.next();
&nbsp;                                this.nestMembers.add(typeDescription.getInternalName());
&nbsp;                            }
&nbsp;                        } else {
&nbsp;                            this.nestMembers = Collections.emptySet();
&nbsp;                        }
&nbsp;
&nbsp;                        this.declaredTypes = new LinkedHashMap((int)Math.ceil((double)WithFullProcessing.this.instrumentedType.getDeclaredTypes().size() / 0.75));
&nbsp;                        var7 = WithFullProcessing.this.instrumentedType.getDeclaredTypes().iterator();
&nbsp;
&nbsp;                        while(var7.hasNext()) {
&nbsp;                            typeDescription = (TypeDescription)var7.next();
&nbsp;                            this.declaredTypes.put(typeDescription.getInternalName(), typeDescription);
&nbsp;                        }
&nbsp;
&nbsp;                        if (WithFullProcessing.this.instrumentedType.isSealed()) {
&nbsp;                            this.permittedSubclasses = new LinkedHashSet((int)Math.ceil((double)WithFullProcessing.this.instrumentedType.getPermittedSubtypes().size() / 0.75));
&nbsp;                            var7 = WithFullProcessing.this.instrumentedType.getPermittedSubtypes().iterator();
&nbsp;
&nbsp;                            while(var7.hasNext()) {
&nbsp;                                typeDescription = (TypeDescription)var7.next();
&nbsp;                                this.permittedSubclasses.add(typeDescription.getInternalName());
&nbsp;                            }
&nbsp;                        } else {
&nbsp;                            this.permittedSubclasses = null;
&nbsp;                        }
&nbsp;
&nbsp;                    }
&nbsp;
&nbsp;                    @SuppressFBWarnings(
&nbsp;                        value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;                        justification = &quot;Relying on correlated type properties.&quot;
&nbsp;                    )
&nbsp;                    public void visit(int classFileVersionNumber, int modifiers, String internalName, String genericSignature, String superClassInternalName, String[] interfaceTypeInternalName) {
&nbsp;                        ClassFileVersion classFileVersion = ClassFileVersion.ofMinorMajor(classFileVersionNumber);
&nbsp;                        this.methodPool = WithFullProcessing.this.methodRegistry.compile(WithFullProcessing.this.implementationTargetFactory, classFileVersion);
&nbsp;                        this.initializationHandler = new InitializationHandler.Creating(WithFullProcessing.this.instrumentedType, this.methodPool, WithFullProcessing.this.annotationValueFilterFactory);
&nbsp;                        this.implementationContext = WithFullProcessing.this.implementationContextFactory.make(WithFullProcessing.this.instrumentedType, WithFullProcessing.this.auxiliaryTypeNamingStrategy, this.typeInitializer, classFileVersion, WithFullProcessing.this.classFileVersion);
&nbsp;                        this.retainDeprecationModifiers = classFileVersion.isLessThan(ClassFileVersion.JAVA_V5);
&nbsp;                        this.contextRegistry.setImplementationContext(this.implementationContext);
&nbsp;                        this.cv = WithFullProcessing.this.asmVisitorWrapper.wrap(WithFullProcessing.this.instrumentedType, this.cv, this.implementationContext, WithFullProcessing.this.typePool, WithFullProcessing.this.fields, WithFullProcessing.this.methods, this.writerFlags, this.readerFlags);
&nbsp;                        this.cv.visit(classFileVersionNumber, WithFullProcessing.this.instrumentedType.getActualModifiers((modifiers &amp; 32) != 0 &amp;&amp; !WithFullProcessing.this.instrumentedType.isInterface()) | this.resolveDeprecationModifiers(modifiers) | ((modifiers &amp; 16) != 0 &amp;&amp; WithFullProcessing.this.instrumentedType.isAnonymousType() ? 16 : 0), WithFullProcessing.this.instrumentedType.getInternalName(), AbstractBase.RAW_TYPES ? genericSignature : WithFullProcessing.this.instrumentedType.getGenericSignature(), WithFullProcessing.this.instrumentedType.getSuperClass() == null ? (WithFullProcessing.this.instrumentedType.isInterface() ? TypeDescription.OBJECT.getInternalName() : TypeWriter.Default.NO_REFERENCE) : WithFullProcessing.this.instrumentedType.getSuperClass().asErasure().getInternalName(), WithFullProcessing.this.instrumentedType.getInterfaces().asErasures().toInternalNames());
&nbsp;                    }
&nbsp;
&nbsp;                    protected void onVisitNestHost(String nestHost) {
&nbsp;                        this.onNestHost();
&nbsp;                    }
&nbsp;
&nbsp;                    protected void onNestHost() {
&nbsp;                        if (!WithFullProcessing.this.instrumentedType.isNestHost()) {
&nbsp;                            this.cv.visitNestHost(WithFullProcessing.this.instrumentedType.getNestHost().getInternalName());
&nbsp;                        }
&nbsp;
&nbsp;                    }
&nbsp;
&nbsp;                    protected void onVisitPermittedSubclass(String permittedSubclass) {
&nbsp;                        if (this.permittedSubclasses != null &amp;&amp; this.permittedSubclasses.remove(permittedSubclass)) {
&nbsp;                            this.cv.visitPermittedSubclass(permittedSubclass);
&nbsp;                        }
&nbsp;
&nbsp;                    }
&nbsp;
&nbsp;                    protected void onVisitOuterClass(String owner, @Nonnull(when = When.MAYBE) String name, @Nonnull(when = When.MAYBE) String descriptor) {
&nbsp;                        try {
&nbsp;                            this.onOuterType();
&nbsp;                        } catch (Throwable var5) {
&nbsp;                            this.cv.visitOuterClass(owner, name, descriptor);
&nbsp;                        }
&nbsp;
&nbsp;                    }
&nbsp;
&nbsp;                    @SuppressFBWarnings(
&nbsp;                        value = {&quot;NP_NULL_ON_SOME_PATH&quot;},
&nbsp;                        justification = &quot;Relying on correlated type properties.&quot;
&nbsp;                    )
&nbsp;                    protected void onOuterType() {
&nbsp;                        MethodDescription.InDefinedShape enclosingMethod = WithFullProcessing.this.instrumentedType.getEnclosingMethod();
&nbsp;                        if (enclosingMethod != null) {
&nbsp;                            this.cv.visitOuterClass(enclosingMethod.getDeclaringType().getInternalName(), enclosingMethod.getInternalName(), enclosingMethod.getDescriptor());
&nbsp;                        } else if (WithFullProcessing.this.instrumentedType.isLocalType() || WithFullProcessing.this.instrumentedType.isAnonymousType()) {
&nbsp;                            this.cv.visitOuterClass(WithFullProcessing.this.instrumentedType.getEnclosingType().getInternalName(), TypeWriter.Default.NO_REFERENCE, TypeWriter.Default.NO_REFERENCE);
&nbsp;                        }
&nbsp;
&nbsp;                    }
&nbsp;
&nbsp;                    protected void onAfterAttributes() {
&nbsp;                        WithFullProcessing.this.typeAttributeAppender.apply(this.cv, WithFullProcessing.this.instrumentedType, WithFullProcessing.this.annotationValueFilterFactory.on(WithFullProcessing.this.instrumentedType));
&nbsp;                    }
&nbsp;
&nbsp;                    @Nonnull(
&nbsp;                        when = When.MAYBE
&nbsp;                    )
&nbsp;                    protected AnnotationVisitor onVisitTypeAnnotation(int typeReference, TypePath typePath, String descriptor, boolean visible) {
&nbsp;                        return WithFullProcessing.this.annotationRetention.isEnabled() ? this.cv.visitTypeAnnotation(typeReference, typePath, descriptor, visible) : TypeWriter.Default.ForInlining.IGNORE_ANNOTATION;
&nbsp;                    }
&nbsp;
&nbsp;                    @Nonnull(
&nbsp;                        when = When.MAYBE
&nbsp;                    )
&nbsp;                    protected AnnotationVisitor onVisitAnnotation(String descriptor, boolean visible) {
&nbsp;                        return WithFullProcessing.this.annotationRetention.isEnabled() ? this.cv.visitAnnotation(descriptor, visible) : TypeWriter.Default.ForInlining.IGNORE_ANNOTATION;
&nbsp;                    }
&nbsp;
&nbsp;                    @Nonnull(
&nbsp;                        when = When.MAYBE
&nbsp;                    )
&nbsp;                    protected RecordComponentVisitor onVisitRecordComponent(String name, String descriptor, @Nonnull(when = When.MAYBE) String genericSignature) {
&nbsp;                        RecordComponentDescription recordComponentDescription = (RecordComponentDescription)this.declarableRecordComponents.remove(name);
&nbsp;                        if (recordComponentDescription != null) {
&nbsp;                            RecordComponentPool.Record record = WithFullProcessing.this.recordComponentPool.target(recordComponentDescription);
&nbsp;                            if (!record.isImplicit()) {
&nbsp;                                return this.redefine(record, genericSignature);
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        return this.cv.visitRecordComponent(name, descriptor, genericSignature);
&nbsp;                    }
&nbsp;
&nbsp;                    @Nonnull(
&nbsp;                        when = When.MAYBE
&nbsp;                    )
&nbsp;                    protected RecordComponentVisitor redefine(RecordComponentPool.Record record, @Nonnull(when = When.MAYBE) String genericSignature) {
&nbsp;                        RecordComponentDescription recordComponentDescription = record.getRecordComponent();
&nbsp;                        RecordComponentVisitor recordComponentVisitor = this.cv.visitRecordComponent(recordComponentDescription.getActualName(), recordComponentDescription.getDescriptor(), AbstractBase.RAW_TYPES ? genericSignature : recordComponentDescription.getGenericSignature());
&nbsp;                        return (RecordComponentVisitor)(recordComponentVisitor == null ? TypeWriter.Default.ForInlining.IGNORE_RECORD_COMPONENT : new AttributeObtainingRecordComponentVisitor(recordComponentVisitor, record));
&nbsp;                    }
&nbsp;
&nbsp;                    @Nonnull(
&nbsp;                        when = When.MAYBE
&nbsp;                    )
&nbsp;                    protected FieldVisitor onVisitField(int modifiers, String internalName, String descriptor, @Nonnull(when = When.MAYBE) String genericSignature, @Nonnull(when = When.MAYBE) Object value) {
&nbsp;                        FieldDescription fieldDescription = (FieldDescription)this.declarableFields.remove(new SignatureKey(internalName, descriptor));
&nbsp;                        if (fieldDescription != null) {
&nbsp;                            FieldPool.Record record = WithFullProcessing.this.fieldPool.target(fieldDescription);
&nbsp;                            if (!record.isImplicit()) {
&nbsp;                                return this.redefine(record, value, modifiers, genericSignature);
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        return this.cv.visitField(modifiers, internalName, descriptor, genericSignature, value);
&nbsp;                    }
&nbsp;
&nbsp;                    @Nonnull(
&nbsp;                        when = When.MAYBE
&nbsp;                    )
&nbsp;                    protected FieldVisitor redefine(FieldPool.Record record, @Nonnull(when = When.MAYBE) Object value, int modifiers, @Nonnull(when = When.MAYBE) String genericSignature) {
&nbsp;                        FieldDescription instrumentedField = record.getField();
&nbsp;                        FieldVisitor fieldVisitor = this.cv.visitField(instrumentedField.getActualModifiers() | this.resolveDeprecationModifiers(modifiers), instrumentedField.getInternalName(), instrumentedField.getDescriptor(), AbstractBase.RAW_TYPES ? genericSignature : instrumentedField.getGenericSignature(), record.resolveDefault(value));
&nbsp;                        return (FieldVisitor)(fieldVisitor == null ? TypeWriter.Default.ForInlining.IGNORE_FIELD : new AttributeObtainingFieldVisitor(fieldVisitor, record));
&nbsp;                    }
&nbsp;
&nbsp;                    @Nonnull(
&nbsp;                        when = When.MAYBE
&nbsp;                    )
&nbsp;                    protected MethodVisitor onVisitMethod(int modifiers, String internalName, String descriptor, @Nonnull(when = When.MAYBE) String genericSignature, @Nonnull(when = When.MAYBE) String[] exceptionName) {
&nbsp;                        if (!internalName.equals(&quot;&lt;clinit&gt;&quot;)) {
&nbsp;                            MethodDescription methodDescription = (MethodDescription)this.declarableMethods.remove(new SignatureKey(internalName, descriptor));
&nbsp;                            return methodDescription == null ? this.cv.visitMethod(modifiers, internalName, descriptor, genericSignature, exceptionName) : this.redefine(methodDescription, (modifiers &amp; 1024) != 0, modifiers, genericSignature);
&nbsp;                        } else {
&nbsp;                            MethodVisitor methodVisitor = this.cv.visitMethod(modifiers, internalName, descriptor, genericSignature, exceptionName);
&nbsp;                            return methodVisitor == null ? TypeWriter.Default.ForInlining.IGNORE_METHOD : (MethodVisitor)((MethodVisitor)(this.initializationHandler = TypeWriter.Default.ForInlining.WithFullProcessing.InitializationHandler.Appending.of(this.implementationContext.isEnabled(), methodVisitor, WithFullProcessing.this.instrumentedType, this.methodPool, WithFullProcessing.this.annotationValueFilterFactory, (this.writerFlags &amp; 2) == 0 &amp;&amp; this.implementationContext.getClassFileVersion().isAtLeast(ClassFileVersion.JAVA_V6), (this.readerFlags &amp; 8) != 0)));
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    @Nonnull(
&nbsp;                        when = When.MAYBE
&nbsp;                    )
&nbsp;                    protected MethodVisitor redefine(MethodDescription methodDescription, boolean abstractOrigin, int modifiers, @Nonnull(when = When.MAYBE) String genericSignature) {
&nbsp;                        MethodPool.Record record = this.methodPool.target(methodDescription);
&nbsp;                        if (!record.getSort().isDefined()) {
&nbsp;                            return this.cv.visitMethod(methodDescription.getActualModifiers() | this.resolveDeprecationModifiers(modifiers), methodDescription.getInternalName(), methodDescription.getDescriptor(), AbstractBase.RAW_TYPES ? genericSignature : methodDescription.getGenericSignature(), methodDescription.getExceptionTypes().asErasures().toInternalNames());
&nbsp;                        } else {
&nbsp;                            MethodDescription implementedMethod = record.getMethod();
&nbsp;                            MethodVisitor methodVisitor = this.cv.visitMethod(Resolver.of(Collections.singleton(record.getVisibility())).resolve(implementedMethod.getActualModifiers(record.getSort().isImplemented())) | this.resolveDeprecationModifiers(modifiers), implementedMethod.getInternalName(), implementedMethod.getDescriptor(), AbstractBase.RAW_TYPES ? genericSignature : implementedMethod.getGenericSignature(), implementedMethod.getExceptionTypes().asErasures().toInternalNames());
&nbsp;                            if (methodVisitor == null) {
&nbsp;                                return TypeWriter.Default.ForInlining.IGNORE_METHOD;
&nbsp;                            } else if (abstractOrigin) {
&nbsp;                                return new AttributeObtainingMethodVisitor(methodVisitor, record);
&nbsp;                            } else if (methodDescription.isNative()) {
&nbsp;                                MethodRebaseResolver.Resolution resolution = WithFullProcessing.this.methodRebaseResolver.resolve((MethodDescription.InDefinedShape)implementedMethod.asDefined());
&nbsp;                                if (resolution.isRebased()) {
&nbsp;                                    MethodVisitor rebasedMethodVisitor = super.visitMethod(resolution.getResolvedMethod().getActualModifiers() | this.resolveDeprecationModifiers(modifiers), resolution.getResolvedMethod().getInternalName(), resolution.getResolvedMethod().getDescriptor(), AbstractBase.RAW_TYPES ? genericSignature : implementedMethod.getGenericSignature(), resolution.getResolvedMethod().getExceptionTypes().asErasures().toInternalNames());
&nbsp;                                    if (rebasedMethodVisitor != null) {
&nbsp;                                        rebasedMethodVisitor.visitEnd();
&nbsp;                                    }
&nbsp;                                }
&nbsp;
&nbsp;                                return new AttributeObtainingMethodVisitor(methodVisitor, record);
&nbsp;                            } else {
&nbsp;                                return new CodePreservingMethodVisitor(methodVisitor, record, WithFullProcessing.this.methodRebaseResolver.resolve((MethodDescription.InDefinedShape)implementedMethod.asDefined()));
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    protected void onVisitInnerClass(String internalName, @Nonnull(when = When.MAYBE) String outerName, @Nonnull(when = When.MAYBE) String innerName, int modifiers) {
&nbsp;                        if (!internalName.equals(WithFullProcessing.this.instrumentedType.getInternalName())) {
&nbsp;                            TypeDescription declaredType = (TypeDescription)this.declaredTypes.remove(internalName);
&nbsp;                            if (declaredType == null) {
&nbsp;                                this.cv.visitInnerClass(internalName, outerName, innerName, modifiers);
&nbsp;                            } else {
&nbsp;                                this.cv.visitInnerClass(internalName, !declaredType.isMemberType() &amp;&amp; (outerName == null || innerName != null || !declaredType.isAnonymousType()) ? TypeWriter.Default.NO_REFERENCE : WithFullProcessing.this.instrumentedType.getInternalName(), declaredType.isAnonymousType() ? TypeWriter.Default.NO_REFERENCE : declaredType.getSimpleName(), declaredType.getModifiers());
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                    }
&nbsp;
&nbsp;                    protected void onVisitNestMember(String nestMember) {
&nbsp;                        if (WithFullProcessing.this.instrumentedType.isNestHost() &amp;&amp; this.nestMembers.remove(nestMember)) {
&nbsp;                            this.cv.visitNestMember(nestMember);
&nbsp;                        }
&nbsp;
&nbsp;                    }
&nbsp;
&nbsp;                    protected void onVisitEnd() {
&nbsp;                        Iterator var1 = this.nestMembers.iterator();
&nbsp;
&nbsp;                        String permittedSubclass;
&nbsp;                        while(var1.hasNext()) {
&nbsp;                            permittedSubclass = (String)var1.next();
&nbsp;                            this.cv.visitNestMember(permittedSubclass);
&nbsp;                        }
&nbsp;
&nbsp;                        if (this.permittedSubclasses != null) {
&nbsp;                            var1 = this.permittedSubclasses.iterator();
&nbsp;
&nbsp;                            while(var1.hasNext()) {
&nbsp;                                permittedSubclass = (String)var1.next();
&nbsp;                                this.cv.visitPermittedSubclass(permittedSubclass);
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        TypeDescription declaringType = WithFullProcessing.this.instrumentedType.getDeclaringType();
&nbsp;                        if (declaringType != null) {
&nbsp;                            this.cv.visitInnerClass(WithFullProcessing.this.instrumentedType.getInternalName(), declaringType.getInternalName(), WithFullProcessing.this.instrumentedType.getSimpleName(), WithFullProcessing.this.instrumentedType.getModifiers());
&nbsp;                        } else if (WithFullProcessing.this.instrumentedType.isLocalType()) {
&nbsp;                            this.cv.visitInnerClass(WithFullProcessing.this.instrumentedType.getInternalName(), TypeWriter.Default.NO_REFERENCE, WithFullProcessing.this.instrumentedType.getSimpleName(), WithFullProcessing.this.instrumentedType.getModifiers());
&nbsp;                        } else if (WithFullProcessing.this.instrumentedType.isAnonymousType()) {
&nbsp;                            this.cv.visitInnerClass(WithFullProcessing.this.instrumentedType.getInternalName(), TypeWriter.Default.NO_REFERENCE, TypeWriter.Default.NO_REFERENCE, WithFullProcessing.this.instrumentedType.getModifiers());
&nbsp;                        }
&nbsp;
&nbsp;                        Iterator var5 = this.declaredTypes.values().iterator();
&nbsp;
&nbsp;                        while(var5.hasNext()) {
&nbsp;                            TypeDescription typeDescription = (TypeDescription)var5.next();
&nbsp;                            this.cv.visitInnerClass(typeDescription.getInternalName(), typeDescription.isMemberType() ? WithFullProcessing.this.instrumentedType.getInternalName() : TypeWriter.Default.NO_REFERENCE, typeDescription.isAnonymousType() ? TypeWriter.Default.NO_REFERENCE : typeDescription.getSimpleName(), typeDescription.getModifiers());
&nbsp;                        }
&nbsp;
&nbsp;                        var5 = this.declarableRecordComponents.values().iterator();
&nbsp;
&nbsp;                        while(var5.hasNext()) {
&nbsp;                            RecordComponentDescription recordComponent = (RecordComponentDescription)var5.next();
&nbsp;                            WithFullProcessing.this.recordComponentPool.target(recordComponent).apply(this.cv, WithFullProcessing.this.annotationValueFilterFactory);
&nbsp;                        }
&nbsp;
&nbsp;                        var5 = this.declarableFields.values().iterator();
&nbsp;
&nbsp;                        while(var5.hasNext()) {
&nbsp;                            FieldDescription fieldDescription = (FieldDescription)var5.next();
&nbsp;                            WithFullProcessing.this.fieldPool.target(fieldDescription).apply(this.cv, WithFullProcessing.this.annotationValueFilterFactory);
&nbsp;                        }
&nbsp;
&nbsp;                        var5 = this.declarableMethods.values().iterator();
&nbsp;
&nbsp;                        while(var5.hasNext()) {
&nbsp;                            MethodDescription methodDescription = (MethodDescription)var5.next();
&nbsp;                            this.methodPool.target(methodDescription).apply(this.cv, this.implementationContext, WithFullProcessing.this.annotationValueFilterFactory);
&nbsp;                        }
&nbsp;
&nbsp;                        this.initializationHandler.complete(this.cv, this.implementationContext);
&nbsp;                        this.cv.visitEnd();
&nbsp;                    }
&nbsp;
&nbsp;                    private int resolveDeprecationModifiers(int modifiers) {
&nbsp;                        return this.retainDeprecationModifiers &amp;&amp; (modifiers &amp; 131072) != 0 ? 131072 : 0;
&nbsp;                    }
&nbsp;
&nbsp;                    protected class AttributeObtainingMethodVisitor extends MethodVisitor {
&nbsp;                        private final MethodVisitor actualMethodVisitor;
&nbsp;                        private final MethodPool.Record record;
&nbsp;
&nbsp;                        protected AttributeObtainingMethodVisitor(MethodVisitor actualMethodVisitor, MethodPool.Record record) {
&nbsp;                            super(OpenedClassReader.ASM_API, actualMethodVisitor);
&nbsp;                            this.actualMethodVisitor = actualMethodVisitor;
&nbsp;                            this.record = record;
&nbsp;                            record.applyHead(actualMethodVisitor);
&nbsp;                        }
&nbsp;
&nbsp;                        @Nonnull(
&nbsp;                            when = When.MAYBE
&nbsp;                        )
&nbsp;                        public AnnotationVisitor visitAnnotationDefault() {
&nbsp;                            return TypeWriter.Default.ForInlining.IGNORE_ANNOTATION;
&nbsp;                        }
&nbsp;
&nbsp;                        @Nonnull(
&nbsp;                            when = When.MAYBE
&nbsp;                        )
&nbsp;                        public AnnotationVisitor visitTypeAnnotation(int typeReference, @Nonnull(when = When.MAYBE) TypePath typePath, String descriptor, boolean visible) {
&nbsp;                            return WithFullProcessing.this.annotationRetention.isEnabled() ? super.visitTypeAnnotation(typeReference, typePath, descriptor, visible) : TypeWriter.Default.ForInlining.IGNORE_ANNOTATION;
&nbsp;                        }
&nbsp;
&nbsp;                        @Nonnull(
&nbsp;                            when = When.MAYBE
&nbsp;                        )
&nbsp;                        public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {
&nbsp;                            return WithFullProcessing.this.annotationRetention.isEnabled() ? super.visitAnnotation(descriptor, visible) : TypeWriter.Default.ForInlining.IGNORE_ANNOTATION;
&nbsp;                        }
&nbsp;
&nbsp;                        public void visitAnnotableParameterCount(int count, boolean visible) {
&nbsp;                            if (WithFullProcessing.this.annotationRetention.isEnabled()) {
&nbsp;                                super.visitAnnotableParameterCount(count, visible);
&nbsp;                            }
&nbsp;
&nbsp;                        }
&nbsp;
&nbsp;                        @Nonnull(
&nbsp;                            when = When.MAYBE
&nbsp;                        )
&nbsp;                        public AnnotationVisitor visitParameterAnnotation(int index, String descriptor, boolean visible) {
&nbsp;                            return WithFullProcessing.this.annotationRetention.isEnabled() ? super.visitParameterAnnotation(index, descriptor, visible) : TypeWriter.Default.ForInlining.IGNORE_ANNOTATION;
&nbsp;                        }
&nbsp;
&nbsp;                        public void visitCode() {
&nbsp;                            this.mv = TypeWriter.Default.ForInlining.IGNORE_METHOD;
&nbsp;                        }
&nbsp;
&nbsp;                        public void visitEnd() {
&nbsp;                            this.record.applyBody(this.actualMethodVisitor, RedefinitionClassVisitor.this.implementationContext, WithFullProcessing.this.annotationValueFilterFactory);
&nbsp;                            this.actualMethodVisitor.visitEnd();
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    protected class CodePreservingMethodVisitor extends MethodVisitor {
&nbsp;                        private final MethodVisitor actualMethodVisitor;
&nbsp;                        private final MethodPool.Record record;
&nbsp;                        private final MethodRebaseResolver.Resolution resolution;
&nbsp;
&nbsp;                        protected CodePreservingMethodVisitor(MethodVisitor actualMethodVisitor, MethodPool.Record record, MethodRebaseResolver.Resolution resolution) {
&nbsp;                            super(OpenedClassReader.ASM_API, actualMethodVisitor);
&nbsp;                            this.actualMethodVisitor = actualMethodVisitor;
&nbsp;                            this.record = record;
&nbsp;                            this.resolution = resolution;
&nbsp;                            record.applyHead(actualMethodVisitor);
&nbsp;                        }
&nbsp;
&nbsp;                        @Nonnull(
&nbsp;                            when = When.MAYBE
&nbsp;                        )
&nbsp;                        public AnnotationVisitor visitAnnotationDefault() {
&nbsp;                            return TypeWriter.Default.ForInlining.IGNORE_ANNOTATION;
&nbsp;                        }
&nbsp;
&nbsp;                        @Nonnull(
&nbsp;                            when = When.MAYBE
&nbsp;                        )
&nbsp;                        public AnnotationVisitor visitTypeAnnotation(int typeReference, @Nonnull(when = When.MAYBE) TypePath typePath, String descriptor, boolean visible) {
&nbsp;                            return WithFullProcessing.this.annotationRetention.isEnabled() ? super.visitTypeAnnotation(typeReference, typePath, descriptor, visible) : TypeWriter.Default.ForInlining.IGNORE_ANNOTATION;
&nbsp;                        }
&nbsp;
&nbsp;                        @Nonnull(
&nbsp;                            when = When.MAYBE
&nbsp;                        )
&nbsp;                        public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {
&nbsp;                            return WithFullProcessing.this.annotationRetention.isEnabled() ? super.visitAnnotation(descriptor, visible) : TypeWriter.Default.ForInlining.IGNORE_ANNOTATION;
&nbsp;                        }
&nbsp;
&nbsp;                        public void visitAnnotableParameterCount(int count, boolean visible) {
&nbsp;                            if (WithFullProcessing.this.annotationRetention.isEnabled()) {
&nbsp;                                super.visitAnnotableParameterCount(count, visible);
&nbsp;                            }
&nbsp;
&nbsp;                        }
&nbsp;
&nbsp;                        @Nonnull(
&nbsp;                            when = When.MAYBE
&nbsp;                        )
&nbsp;                        public AnnotationVisitor visitParameterAnnotation(int index, String descriptor, boolean visible) {
&nbsp;                            return WithFullProcessing.this.annotationRetention.isEnabled() ? super.visitParameterAnnotation(index, descriptor, visible) : TypeWriter.Default.ForInlining.IGNORE_ANNOTATION;
&nbsp;                        }
&nbsp;
&nbsp;                        public void visitCode() {
&nbsp;                            this.record.applyBody(this.actualMethodVisitor, RedefinitionClassVisitor.this.implementationContext, WithFullProcessing.this.annotationValueFilterFactory);
&nbsp;                            this.actualMethodVisitor.visitEnd();
&nbsp;                            if (this.resolution.isRebased()) {
&nbsp;                                this.mv = RedefinitionClassVisitor.this.cv.visitMethod(this.resolution.getResolvedMethod().getActualModifiers(), this.resolution.getResolvedMethod().getInternalName(), this.resolution.getResolvedMethod().getDescriptor(), this.resolution.getResolvedMethod().getGenericSignature(), this.resolution.getResolvedMethod().getExceptionTypes().asErasures().toInternalNames());
&nbsp;                                super.visitCode();
&nbsp;                                if (!this.resolution.getAppendedParameters().isEmpty() &amp;&amp; (RedefinitionClassVisitor.this.writerFlags &amp; 2) == 0 &amp;&amp; RedefinitionClassVisitor.this.implementationContext.getClassFileVersion().isAtLeast(ClassFileVersion.JAVA_V6)) {
&nbsp;                                    if ((RedefinitionClassVisitor.this.readerFlags &amp; 8) == 0 &amp;&amp; this.resolution.getAppendedParameters().size() &lt; 4) {
&nbsp;                                        super.visitFrame(2, this.resolution.getAppendedParameters().size(), TypeWriter.Default.ForInlining.WithFullProcessing.EMPTY, TypeWriter.Default.ForInlining.WithFullProcessing.EMPTY.length, TypeWriter.Default.ForInlining.WithFullProcessing.EMPTY);
&nbsp;                                    } else {
&nbsp;                                        Object[] frame = new Object[this.resolution.getResolvedMethod().getParameters().size() - this.resolution.getAppendedParameters().size() + 1];
&nbsp;                                        frame[0] = Opcodes.UNINITIALIZED_THIS;
&nbsp;                                        int index = 1;
&nbsp;
&nbsp;                                        while(true) {
&nbsp;                                            if (index &gt;= frame.length) {
&nbsp;                                                super.visitFrame((RedefinitionClassVisitor.this.readerFlags &amp; 8) == 0 ? 0 : -1, frame.length, frame, TypeWriter.Default.ForInlining.WithFullProcessing.EMPTY.length, TypeWriter.Default.ForInlining.WithFullProcessing.EMPTY);
&nbsp;                                                break;
&nbsp;                                            }
&nbsp;
&nbsp;                                            TypeDefinition typeDefinition = ((ParameterDescription.InDefinedShape)this.resolution.getResolvedMethod().getParameters().get(index - 1)).getType();
&nbsp;                                            if (!typeDefinition.represents(Boolean.TYPE) &amp;&amp; !typeDefinition.represents(Byte.TYPE) &amp;&amp; !typeDefinition.represents(Short.TYPE) &amp;&amp; !typeDefinition.represents(Character.TYPE) &amp;&amp; !typeDefinition.represents(Integer.TYPE)) {
&nbsp;                                                if (typeDefinition.represents(Long.TYPE)) {
&nbsp;                                                    frame[index] = Opcodes.LONG;
&nbsp;                                                } else if (typeDefinition.represents(Float.TYPE)) {
&nbsp;                                                    frame[index] = Opcodes.FLOAT;
&nbsp;                                                } else if (typeDefinition.represents(Double.TYPE)) {
&nbsp;                                                    frame[index] = Opcodes.DOUBLE;
&nbsp;                                                } else {
&nbsp;                                                    frame[index] = typeDefinition.asErasure().getInternalName();
&nbsp;                                                }
&nbsp;                                            } else {
&nbsp;                                                frame[index] = Opcodes.INTEGER;
&nbsp;                                            }
&nbsp;
&nbsp;                                            ++index;
&nbsp;                                        }
&nbsp;                                    }
&nbsp;
&nbsp;                                    super.visitInsn(0);
&nbsp;                                }
&nbsp;                            } else {
&nbsp;                                this.mv = TypeWriter.Default.ForInlining.IGNORE_METHOD;
&nbsp;                                super.visitCode();
&nbsp;                            }
&nbsp;
&nbsp;                        }
&nbsp;
&nbsp;                        public void visitMaxs(int stackSize, int localVariableLength) {
&nbsp;                            super.visitMaxs(stackSize, Math.max(localVariableLength, this.resolution.getResolvedMethod().getStackSize()));
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    protected class AttributeObtainingRecordComponentVisitor extends RecordComponentVisitor {
&nbsp;                        private final RecordComponentPool.Record record;
&nbsp;
&nbsp;                        protected AttributeObtainingRecordComponentVisitor(RecordComponentVisitor recordComponentVisitor, RecordComponentPool.Record record) {
&nbsp;                            super(OpenedClassReader.ASM_API, recordComponentVisitor);
&nbsp;                            this.record = record;
&nbsp;                        }
&nbsp;
&nbsp;                        public AnnotationVisitor visitTypeAnnotation(int typeReference, TypePath typePath, String descriptor, boolean visible) {
&nbsp;                            return WithFullProcessing.this.annotationRetention.isEnabled() ? super.visitTypeAnnotation(typeReference, typePath, descriptor, visible) : TypeWriter.Default.ForInlining.IGNORE_ANNOTATION;
&nbsp;                        }
&nbsp;
&nbsp;                        public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {
&nbsp;                            return WithFullProcessing.this.annotationRetention.isEnabled() ? super.visitAnnotation(descriptor, visible) : TypeWriter.Default.ForInlining.IGNORE_ANNOTATION;
&nbsp;                        }
&nbsp;
&nbsp;                        public void visitEnd() {
&nbsp;                            this.record.apply(this.getDelegate(), WithFullProcessing.this.annotationValueFilterFactory);
&nbsp;                            super.visitEnd();
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    protected class AttributeObtainingFieldVisitor extends FieldVisitor {
&nbsp;                        private final FieldPool.Record record;
&nbsp;
<b class="fc">&nbsp;                        protected AttributeObtainingFieldVisitor(FieldVisitor fieldVisitor, FieldPool.Record record) {</b>
&nbsp;                            super(OpenedClassReader.ASM_API, fieldVisitor);
&nbsp;                            this.record = record;
&nbsp;                        }
&nbsp;
&nbsp;                        @Nonnull(
&nbsp;                            when = When.MAYBE
&nbsp;                        )
&nbsp;                        public AnnotationVisitor visitTypeAnnotation(int typeReference, @Nonnull(when = When.MAYBE) TypePath typePath, String descriptor, boolean visible) {
&nbsp;                            return WithFullProcessing.this.annotationRetention.isEnabled() ? super.visitTypeAnnotation(typeReference, typePath, descriptor, visible) : TypeWriter.Default.ForInlining.IGNORE_ANNOTATION;
&nbsp;                        }
&nbsp;
&nbsp;                        @Nonnull(
&nbsp;                            when = When.MAYBE
&nbsp;                        )
&nbsp;                        public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {
&nbsp;                            return WithFullProcessing.this.annotationRetention.isEnabled() ? super.visitAnnotation(descriptor, visible) : TypeWriter.Default.ForInlining.IGNORE_ANNOTATION;
&nbsp;                        }
&nbsp;
&nbsp;                        public void visitEnd() {
&nbsp;                            this.record.apply(this.fv, WithFullProcessing.this.annotationValueFilterFactory);
&nbsp;                            super.visitEnd();
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                protected interface InitializationHandler {
&nbsp;                    void complete(ClassVisitor var1, Implementation.Context.ExtractableView var2);
&nbsp;
&nbsp;                    public abstract static class Appending extends MethodVisitor implements InitializationHandler, TypeInitializer.Drain {
&nbsp;                        protected final TypeDescription instrumentedType;
&nbsp;                        protected final MethodPool.Record record;
&nbsp;                        protected final AnnotationValueFilter.Factory annotationValueFilterFactory;
&nbsp;                        protected final FrameWriter frameWriter;
&nbsp;                        protected int stackSize;
&nbsp;                        protected int localVariableLength;
&nbsp;
&nbsp;                        protected Appending(MethodVisitor methodVisitor, TypeDescription instrumentedType, MethodPool.Record record, AnnotationValueFilter.Factory annotationValueFilterFactory, boolean requireFrames, boolean expandFrames) {
&nbsp;                            super(OpenedClassReader.ASM_API, methodVisitor);
&nbsp;                            this.instrumentedType = instrumentedType;
&nbsp;                            this.record = record;
&nbsp;                            this.annotationValueFilterFactory = annotationValueFilterFactory;
&nbsp;                            if (!requireFrames) {
&nbsp;                                this.frameWriter = TypeWriter.Default.ForInlining.WithFullProcessing.InitializationHandler.Appending.FrameWriter.NoOp.INSTANCE;
&nbsp;                            } else if (expandFrames) {
&nbsp;                                this.frameWriter = TypeWriter.Default.ForInlining.WithFullProcessing.InitializationHandler.Appending.FrameWriter.Expanding.INSTANCE;
&nbsp;                            } else {
&nbsp;                                this.frameWriter = new FrameWriter.Active();
&nbsp;                            }
&nbsp;
&nbsp;                        }
&nbsp;
&nbsp;                        protected static InitializationHandler of(boolean enabled, MethodVisitor methodVisitor, TypeDescription instrumentedType, MethodPool methodPool, AnnotationValueFilter.Factory annotationValueFilterFactory, boolean requireFrames, boolean expandFrames) {
&nbsp;                            return (InitializationHandler)(enabled ? withDrain(methodVisitor, instrumentedType, methodPool, annotationValueFilterFactory, requireFrames, expandFrames) : withoutDrain(methodVisitor, instrumentedType, methodPool, annotationValueFilterFactory, requireFrames, expandFrames));
&nbsp;                        }
&nbsp;
&nbsp;                        private static WithDrain withDrain(MethodVisitor methodVisitor, TypeDescription instrumentedType, MethodPool methodPool, AnnotationValueFilter.Factory annotationValueFilterFactory, boolean requireFrames, boolean expandFrames) {
&nbsp;                            MethodPool.Record record = methodPool.target(new MethodDescription.Latent.TypeInitializer(instrumentedType));
&nbsp;                            return (WithDrain)(record.getSort().isImplemented() ? new WithDrain.WithActiveRecord(methodVisitor, instrumentedType, record, annotationValueFilterFactory, requireFrames, expandFrames) : new WithDrain.WithoutActiveRecord(methodVisitor, instrumentedType, record, annotationValueFilterFactory, requireFrames, expandFrames));
&nbsp;                        }
&nbsp;
&nbsp;                        private static WithoutDrain withoutDrain(MethodVisitor methodVisitor, TypeDescription instrumentedType, MethodPool methodPool, AnnotationValueFilter.Factory annotationValueFilterFactory, boolean requireFrames, boolean expandFrames) {
&nbsp;                            MethodPool.Record record = methodPool.target(new MethodDescription.Latent.TypeInitializer(instrumentedType));
&nbsp;                            return (WithoutDrain)(record.getSort().isImplemented() ? new WithoutDrain.WithActiveRecord(methodVisitor, instrumentedType, record, annotationValueFilterFactory, requireFrames, expandFrames) : new WithoutDrain.WithoutActiveRecord(methodVisitor, instrumentedType, record, annotationValueFilterFactory));
&nbsp;                        }
&nbsp;
&nbsp;                        public void visitCode() {
&nbsp;                            this.record.applyAttributes(this.mv, this.annotationValueFilterFactory);
&nbsp;                            super.visitCode();
&nbsp;                            this.onStart();
&nbsp;                        }
&nbsp;
&nbsp;                        protected abstract void onStart();
&nbsp;
&nbsp;                        public void visitFrame(int type, int localVariableLength, @Nonnull(when = When.MAYBE) Object[] localVariable, int stackSize, @Nonnull(when = When.MAYBE) Object[] stack) {
&nbsp;                            super.visitFrame(type, localVariableLength, localVariable, stackSize, stack);
&nbsp;                            this.frameWriter.onFrame(type, localVariableLength);
&nbsp;                        }
&nbsp;
&nbsp;                        public void visitMaxs(int stackSize, int localVariableLength) {
&nbsp;                            this.stackSize = stackSize;
&nbsp;                            this.localVariableLength = localVariableLength;
&nbsp;                        }
&nbsp;
&nbsp;                        public abstract void visitEnd();
&nbsp;
&nbsp;                        public void apply(ClassVisitor classVisitor, TypeInitializer typeInitializer, Implementation.Context implementationContext) {
&nbsp;                            ByteCodeAppender.Size size = typeInitializer.apply(this.mv, implementationContext, new MethodDescription.Latent.TypeInitializer(this.instrumentedType));
&nbsp;                            this.stackSize = Math.max(this.stackSize, size.getOperandStackSize());
&nbsp;                            this.localVariableLength = Math.max(this.localVariableLength, size.getLocalVariableSize());
&nbsp;                            this.onComplete(implementationContext);
&nbsp;                        }
&nbsp;
&nbsp;                        protected abstract void onComplete(Implementation.Context var1);
&nbsp;
&nbsp;                        public void complete(ClassVisitor classVisitor, Implementation.Context.ExtractableView implementationContext) {
&nbsp;                            implementationContext.drain(this, classVisitor, this.annotationValueFilterFactory);
&nbsp;                            this.mv.visitMaxs(this.stackSize, this.localVariableLength);
&nbsp;                            this.mv.visitEnd();
&nbsp;                        }
&nbsp;
&nbsp;                        protected abstract static class WithDrain extends Appending {
&nbsp;                            protected final Label appended = new Label();
&nbsp;                            protected final Label original = new Label();
&nbsp;
&nbsp;                            protected WithDrain(MethodVisitor methodVisitor, TypeDescription instrumentedType, MethodPool.Record record, AnnotationValueFilter.Factory annotationValueFilterFactory, boolean requireFrames, boolean expandFrames) {
&nbsp;                                super(methodVisitor, instrumentedType, record, annotationValueFilterFactory, requireFrames, expandFrames);
&nbsp;                            }
&nbsp;
&nbsp;                            protected void onStart() {
&nbsp;                                this.mv.visitJumpInsn(167, this.appended);
&nbsp;                                this.mv.visitLabel(this.original);
&nbsp;                                this.frameWriter.emitFrame(this.mv);
&nbsp;                            }
&nbsp;
&nbsp;                            public void visitEnd() {
&nbsp;                                this.mv.visitLabel(this.appended);
&nbsp;                                this.frameWriter.emitFrame(this.mv);
&nbsp;                            }
&nbsp;
&nbsp;                            protected void onComplete(Implementation.Context implementationContext) {
&nbsp;                                this.mv.visitJumpInsn(167, this.original);
&nbsp;                                this.onAfterComplete(implementationContext);
&nbsp;                            }
&nbsp;
&nbsp;                            protected abstract void onAfterComplete(Implementation.Context var1);
&nbsp;
&nbsp;                            protected static class WithActiveRecord extends WithDrain {
&nbsp;                                private final Label label = new Label();
&nbsp;
&nbsp;                                protected WithActiveRecord(MethodVisitor methodVisitor, TypeDescription instrumentedType, MethodPool.Record record, AnnotationValueFilter.Factory annotationValueFilterFactory, boolean requireFrames, boolean expandFrames) {
&nbsp;                                    super(methodVisitor, instrumentedType, record, annotationValueFilterFactory, requireFrames, expandFrames);
&nbsp;                                }
&nbsp;
&nbsp;                                public void visitInsn(int opcode) {
&nbsp;                                    if (opcode == 177) {
&nbsp;                                        this.mv.visitJumpInsn(167, this.label);
&nbsp;                                    } else {
&nbsp;                                        super.visitInsn(opcode);
&nbsp;                                    }
&nbsp;
&nbsp;                                }
&nbsp;
&nbsp;                                protected void onAfterComplete(Implementation.Context implementationContext) {
&nbsp;                                    this.mv.visitLabel(this.label);
&nbsp;                                    this.frameWriter.emitFrame(this.mv);
&nbsp;                                    ByteCodeAppender.Size size = this.record.applyCode(this.mv, implementationContext);
&nbsp;                                    this.stackSize = Math.max(this.stackSize, size.getOperandStackSize());
&nbsp;                                    this.localVariableLength = Math.max(this.localVariableLength, size.getLocalVariableSize());
&nbsp;                                }
&nbsp;                            }
&nbsp;
&nbsp;                            protected static class WithoutActiveRecord extends WithDrain {
&nbsp;                                protected WithoutActiveRecord(MethodVisitor methodVisitor, TypeDescription instrumentedType, MethodPool.Record record, AnnotationValueFilter.Factory annotationValueFilterFactory, boolean requireFrames, boolean expandFrames) {
&nbsp;                                    super(methodVisitor, instrumentedType, record, annotationValueFilterFactory, requireFrames, expandFrames);
&nbsp;                                }
&nbsp;
&nbsp;                                protected void onAfterComplete(Implementation.Context implementationContext) {
&nbsp;                                }
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        protected abstract static class WithoutDrain extends Appending {
&nbsp;                            protected WithoutDrain(MethodVisitor methodVisitor, TypeDescription instrumentedType, MethodPool.Record record, AnnotationValueFilter.Factory annotationValueFilterFactory, boolean requireFrames, boolean expandFrames) {
&nbsp;                                super(methodVisitor, instrumentedType, record, annotationValueFilterFactory, requireFrames, expandFrames);
&nbsp;                            }
&nbsp;
&nbsp;                            protected void onStart() {
&nbsp;                            }
&nbsp;
&nbsp;                            public void visitEnd() {
&nbsp;                            }
&nbsp;
&nbsp;                            protected static class WithActiveRecord extends WithoutDrain {
&nbsp;                                private final Label label = new Label();
&nbsp;
&nbsp;                                protected WithActiveRecord(MethodVisitor methodVisitor, TypeDescription instrumentedType, MethodPool.Record record, AnnotationValueFilter.Factory annotationValueFilterFactory, boolean requireFrames, boolean expandFrames) {
&nbsp;                                    super(methodVisitor, instrumentedType, record, annotationValueFilterFactory, requireFrames, expandFrames);
&nbsp;                                }
&nbsp;
&nbsp;                                public void visitInsn(int opcode) {
&nbsp;                                    if (opcode == 177) {
&nbsp;                                        this.mv.visitJumpInsn(167, this.label);
&nbsp;                                    } else {
&nbsp;                                        super.visitInsn(opcode);
&nbsp;                                    }
&nbsp;
&nbsp;                                }
&nbsp;
&nbsp;                                protected void onComplete(Implementation.Context implementationContext) {
&nbsp;                                    this.mv.visitLabel(this.label);
&nbsp;                                    this.frameWriter.emitFrame(this.mv);
&nbsp;                                    ByteCodeAppender.Size size = this.record.applyCode(this.mv, implementationContext);
&nbsp;                                    this.stackSize = Math.max(this.stackSize, size.getOperandStackSize());
&nbsp;                                    this.localVariableLength = Math.max(this.localVariableLength, size.getLocalVariableSize());
&nbsp;                                }
&nbsp;                            }
&nbsp;
&nbsp;                            protected static class WithoutActiveRecord extends WithoutDrain {
&nbsp;                                protected WithoutActiveRecord(MethodVisitor methodVisitor, TypeDescription instrumentedType, MethodPool.Record record, AnnotationValueFilter.Factory annotationValueFilterFactory) {
&nbsp;                                    super(methodVisitor, instrumentedType, record, annotationValueFilterFactory, false, false);
&nbsp;                                }
&nbsp;
&nbsp;                                protected void onComplete(Implementation.Context implementationContext) {
&nbsp;                                }
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        protected interface FrameWriter {
&nbsp;                            Object[] EMPTY = new Object[0];
&nbsp;
&nbsp;                            void onFrame(int var1, int var2);
&nbsp;
&nbsp;                            void emitFrame(MethodVisitor var1);
&nbsp;
&nbsp;                            public static class Active implements FrameWriter {
&nbsp;                                private int currentLocalVariableLength;
&nbsp;
&nbsp;                                public Active() {
&nbsp;                                }
&nbsp;
&nbsp;                                public void onFrame(int type, int localVariableLength) {
&nbsp;                                    switch (type) {
&nbsp;                                        case -1:
&nbsp;                                        case 0:
&nbsp;                                            this.currentLocalVariableLength = localVariableLength;
&nbsp;                                            break;
&nbsp;                                        case 1:
&nbsp;                                            this.currentLocalVariableLength += localVariableLength;
&nbsp;                                            break;
&nbsp;                                        case 2:
&nbsp;                                            this.currentLocalVariableLength -= localVariableLength;
&nbsp;                                        case 3:
&nbsp;                                        case 4:
&nbsp;                                            break;
&nbsp;                                        default:
&nbsp;                                            throw new IllegalStateException(&quot;Unexpected frame type: &quot; + type);
&nbsp;                                    }
&nbsp;
&nbsp;                                }
&nbsp;
&nbsp;                                public void emitFrame(MethodVisitor methodVisitor) {
&nbsp;                                    if (this.currentLocalVariableLength == 0) {
&nbsp;                                        methodVisitor.visitFrame(3, EMPTY.length, EMPTY, EMPTY.length, EMPTY);
&nbsp;                                    } else if (this.currentLocalVariableLength &gt; 3) {
&nbsp;                                        methodVisitor.visitFrame(0, EMPTY.length, EMPTY, EMPTY.length, EMPTY);
&nbsp;                                    } else {
&nbsp;                                        methodVisitor.visitFrame(2, this.currentLocalVariableLength, EMPTY, EMPTY.length, EMPTY);
&nbsp;                                    }
&nbsp;
&nbsp;                                    methodVisitor.visitInsn(0);
&nbsp;                                    this.currentLocalVariableLength = 0;
&nbsp;                                }
&nbsp;                            }
&nbsp;
&nbsp;                            public static enum Expanding implements FrameWriter {
&nbsp;                                INSTANCE;
&nbsp;
&nbsp;                                private Expanding() {
&nbsp;                                }
&nbsp;
&nbsp;                                public void onFrame(int type, int localVariableLength) {
&nbsp;                                }
&nbsp;
&nbsp;                                public void emitFrame(MethodVisitor methodVisitor) {
&nbsp;                                    methodVisitor.visitFrame(-1, EMPTY.length, EMPTY, EMPTY.length, EMPTY);
&nbsp;                                    methodVisitor.visitInsn(0);
&nbsp;                                }
&nbsp;                            }
&nbsp;
&nbsp;                            public static enum NoOp implements FrameWriter {
&nbsp;                                INSTANCE;
&nbsp;
&nbsp;                                private NoOp() {
&nbsp;                                }
&nbsp;
&nbsp;                                public void onFrame(int type, int localVariableLength) {
&nbsp;                                }
&nbsp;
&nbsp;                                public void emitFrame(MethodVisitor methodVisitor) {
&nbsp;                                }
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public static class Creating extends TypeInitializer.Drain.Default implements InitializationHandler {
&nbsp;                        protected Creating(TypeDescription instrumentedType, MethodPool methodPool, AnnotationValueFilter.Factory annotationValueFilterFactory) {
&nbsp;                            super(instrumentedType, methodPool, annotationValueFilterFactory);
&nbsp;                        }
&nbsp;
&nbsp;                        public void complete(ClassVisitor classVisitor, Implementation.Context.ExtractableView implementationContext) {
&nbsp;                            implementationContext.drain(this, classVisitor, this.annotationValueFilterFactory);
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                protected static class OpenedClassRemapper extends ClassRemapper {
&nbsp;                    protected OpenedClassRemapper(ClassVisitor classVisitor, Remapper remapper) {
&nbsp;                        super(OpenedClassReader.ASM_API, classVisitor, remapper);
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            protected static class ContextRegistry {
&nbsp;                @Nonnull(
&nbsp;                    when = When.UNKNOWN
&nbsp;                )
&nbsp;                private Implementation.Context.ExtractableView implementationContext;
&nbsp;
&nbsp;                protected ContextRegistry() {
&nbsp;                }
&nbsp;
&nbsp;                public void setImplementationContext(Implementation.Context.ExtractableView implementationContext) {
&nbsp;                    this.implementationContext = implementationContext;
&nbsp;                }
&nbsp;
&nbsp;                @SuppressFBWarnings(
&nbsp;                    value = {&quot;UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR&quot;},
&nbsp;                    justification = &quot;Lazy value definition is intended.&quot;
&nbsp;                )
&nbsp;                public List&lt;DynamicType&gt; getAuxiliaryTypes() {
&nbsp;                    return this.implementationContext.getAuxiliaryTypes();
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        protected static class ValidatingClassVisitor extends ClassVisitor {
&nbsp;            private static final String NO_PARAMETERS = &quot;()&quot;;
&nbsp;            private static final String RETURNS_VOID = &quot;V&quot;;
&nbsp;            private static final String STRING_DESCRIPTOR = &quot;Ljava/lang/String;&quot;;
&nbsp;            @Nonnull(
&nbsp;                when = When.NEVER
&nbsp;            )
&nbsp;            private static final FieldVisitor IGNORE_FIELD = null;
&nbsp;            @Nonnull(
&nbsp;                when = When.NEVER
&nbsp;            )
&nbsp;            private static final MethodVisitor IGNORE_METHOD = null;
&nbsp;            @Nonnull(
&nbsp;                when = When.UNKNOWN
&nbsp;            )
&nbsp;            private Constraint constraint;
&nbsp;
&nbsp;            protected ValidatingClassVisitor(ClassVisitor classVisitor) {
&nbsp;                super(OpenedClassReader.ASM_API, classVisitor);
&nbsp;            }
&nbsp;
&nbsp;            protected static ClassVisitor of(ClassVisitor classVisitor, TypeValidation typeValidation) {
&nbsp;                return (ClassVisitor)(typeValidation.isEnabled() ? new ValidatingClassVisitor(classVisitor) : classVisitor);
&nbsp;            }
&nbsp;
&nbsp;            public void visit(int version, int modifiers, String name, @Nonnull(when = When.MAYBE) String signature, @Nonnull(when = When.MAYBE) String superName, @Nonnull(when = When.MAYBE) String[] interfaceInternalName) {
&nbsp;                ClassFileVersion classFileVersion = ClassFileVersion.ofMinorMajor(version);
&nbsp;                List&lt;Constraint&gt; constraints = new ArrayList();
&nbsp;                constraints.add(new Constraint.ForClassFileVersion(classFileVersion));
&nbsp;                if (name.endsWith(&quot;/package-info&quot;)) {
&nbsp;                    constraints.add(TypeWriter.Default.ValidatingClassVisitor.Constraint.ForPackageType.INSTANCE);
&nbsp;                } else if ((modifiers &amp; 8192) != 0) {
&nbsp;                    if (!classFileVersion.isAtLeast(ClassFileVersion.JAVA_V5)) {
&nbsp;                        throw new IllegalStateException(&quot;Cannot define an annotation type for class file version &quot; + classFileVersion);
&nbsp;                    }
&nbsp;
&nbsp;                    constraints.add(classFileVersion.isAtLeast(ClassFileVersion.JAVA_V8) ? TypeWriter.Default.ValidatingClassVisitor.Constraint.ForAnnotation.JAVA_8 : TypeWriter.Default.ValidatingClassVisitor.Constraint.ForAnnotation.CLASSIC);
&nbsp;                } else if ((modifiers &amp; 512) != 0) {
&nbsp;                    constraints.add(classFileVersion.isAtLeast(ClassFileVersion.JAVA_V8) ? TypeWriter.Default.ValidatingClassVisitor.Constraint.ForInterface.JAVA_8 : TypeWriter.Default.ValidatingClassVisitor.Constraint.ForInterface.CLASSIC);
&nbsp;                } else if ((modifiers &amp; 1024) != 0) {
&nbsp;                    constraints.add(TypeWriter.Default.ValidatingClassVisitor.Constraint.ForClass.ABSTRACT);
&nbsp;                } else {
&nbsp;                    constraints.add(TypeWriter.Default.ValidatingClassVisitor.Constraint.ForClass.MANIFEST);
&nbsp;                }
&nbsp;
&nbsp;                boolean record;
&nbsp;                if ((modifiers &amp; 65536) != 0) {
&nbsp;                    constraints.add(TypeWriter.Default.ValidatingClassVisitor.Constraint.ForRecord.INSTANCE);
&nbsp;                    record = true;
&nbsp;                } else {
&nbsp;                    record = false;
&nbsp;                }
&nbsp;
&nbsp;                this.constraint = new Constraint.Compound(constraints);
&nbsp;                this.constraint.assertType(modifiers, interfaceInternalName != null, signature != null);
&nbsp;                if (record) {
&nbsp;                    this.constraint.assertRecord();
&nbsp;                }
&nbsp;
&nbsp;                super.visit(version, modifiers, name, signature, superName, interfaceInternalName);
&nbsp;            }
&nbsp;
&nbsp;            public void visitPermittedSubclass(String permittedSubclass) {
&nbsp;                this.constraint.assertPermittedSubclass();
&nbsp;                super.visitPermittedSubclass(permittedSubclass);
&nbsp;            }
&nbsp;
&nbsp;            @Nonnull(
&nbsp;                when = When.MAYBE
&nbsp;            )
&nbsp;            public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {
&nbsp;                this.constraint.assertAnnotation();
&nbsp;                return super.visitAnnotation(descriptor, visible);
&nbsp;            }
&nbsp;
&nbsp;            @Nonnull(
&nbsp;                when = When.MAYBE
&nbsp;            )
&nbsp;            public AnnotationVisitor visitTypeAnnotation(int typeReference, @Nonnull(when = When.MAYBE) TypePath typePath, String descriptor, boolean visible) {
&nbsp;                this.constraint.assertTypeAnnotation();
&nbsp;                return super.visitTypeAnnotation(typeReference, typePath, descriptor, visible);
&nbsp;            }
&nbsp;
&nbsp;            public void visitNestHost(String nestHost) {
&nbsp;                this.constraint.assertNestMate();
&nbsp;                super.visitNestHost(nestHost);
&nbsp;            }
&nbsp;
&nbsp;            public void visitNestMember(String nestMember) {
&nbsp;                this.constraint.assertNestMate();
&nbsp;                super.visitNestMember(nestMember);
&nbsp;            }
&nbsp;
&nbsp;            @Nonnull(
&nbsp;                when = When.MAYBE
&nbsp;            )
&nbsp;            public FieldVisitor visitField(int modifiers, String name, String descriptor, @Nonnull(when = When.MAYBE) String signature, @Nonnull(when = When.MAYBE) Object value) {
&nbsp;                if (value != null) {
&nbsp;                    Class type;
&nbsp;                    switch (descriptor.charAt(0)) {
&nbsp;                        case &#39;B&#39;:
&nbsp;                        case &#39;C&#39;:
&nbsp;                        case &#39;I&#39;:
&nbsp;                        case &#39;S&#39;:
&nbsp;                        case &#39;Z&#39;:
&nbsp;                            type = Integer.class;
&nbsp;                            break;
&nbsp;                        case &#39;D&#39;:
&nbsp;                            type = Double.class;
&nbsp;                            break;
&nbsp;                        case &#39;E&#39;:
&nbsp;                        case &#39;G&#39;:
&nbsp;                        case &#39;H&#39;:
&nbsp;                        case &#39;K&#39;:
&nbsp;                        case &#39;L&#39;:
&nbsp;                        case &#39;M&#39;:
&nbsp;                        case &#39;N&#39;:
&nbsp;                        case &#39;O&#39;:
&nbsp;                        case &#39;P&#39;:
&nbsp;                        case &#39;Q&#39;:
&nbsp;                        case &#39;R&#39;:
&nbsp;                        case &#39;T&#39;:
&nbsp;                        case &#39;U&#39;:
&nbsp;                        case &#39;V&#39;:
&nbsp;                        case &#39;W&#39;:
&nbsp;                        case &#39;X&#39;:
&nbsp;                        case &#39;Y&#39;:
&nbsp;                        default:
&nbsp;                            if (!descriptor.equals(&quot;Ljava/lang/String;&quot;)) {
&nbsp;                                throw new IllegalStateException(&quot;Cannot define a default value for type of field &quot; + name);
&nbsp;                            }
&nbsp;
&nbsp;                            type = String.class;
&nbsp;                            break;
&nbsp;                        case &#39;F&#39;:
&nbsp;                            type = Float.class;
&nbsp;                            break;
&nbsp;                        case &#39;J&#39;:
&nbsp;                            type = Long.class;
&nbsp;                    }
&nbsp;
&nbsp;                    if (!type.isInstance(value)) {
&nbsp;                        throw new IllegalStateException(&quot;Field &quot; + name + &quot; defines an incompatible default value &quot; + value);
&nbsp;                    }
&nbsp;
&nbsp;                    if (type == Integer.class) {
&nbsp;                        int minimum;
&nbsp;                        int maximum;
&nbsp;                        switch (descriptor.charAt(0)) {
&nbsp;                            case &#39;B&#39;:
&nbsp;                                minimum = -128;
&nbsp;                                maximum = 127;
&nbsp;                                break;
&nbsp;                            case &#39;C&#39;:
&nbsp;                                minimum = 0;
&nbsp;                                maximum = 65535;
&nbsp;                                break;
&nbsp;                            case &#39;S&#39;:
&nbsp;                                minimum = -32768;
&nbsp;                                maximum = 32767;
&nbsp;                                break;
&nbsp;                            case &#39;Z&#39;:
&nbsp;                                minimum = 0;
&nbsp;                                maximum = 1;
&nbsp;                                break;
&nbsp;                            default:
&nbsp;                                minimum = Integer.MIN_VALUE;
&nbsp;                                maximum = Integer.MAX_VALUE;
&nbsp;                        }
&nbsp;
&nbsp;                        if ((Integer)value &lt; minimum || (Integer)value &gt; maximum) {
&nbsp;                            throw new IllegalStateException(&quot;Field &quot; + name + &quot; defines an incompatible default value &quot; + value);
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                this.constraint.assertField(name, (modifiers &amp; 1) != 0, (modifiers &amp; 8) != 0, (modifiers &amp; 16) != 0, signature != null);
&nbsp;                FieldVisitor fieldVisitor = super.visitField(modifiers, name, descriptor, signature, value);
&nbsp;                return (FieldVisitor)(fieldVisitor == null ? IGNORE_FIELD : new ValidatingFieldVisitor(fieldVisitor));
&nbsp;            }
&nbsp;
&nbsp;            @Nonnull(
&nbsp;                when = When.MAYBE
&nbsp;            )
&nbsp;            public MethodVisitor visitMethod(int modifiers, String name, String descriptor, @Nonnull(when = When.MAYBE) String signature, @Nonnull(when = When.MAYBE) String[] exceptionInternalName) {
<b class="fc">&nbsp;                this.constraint.assertMethod(name, (modifiers &amp; 1024) != 0, (modifiers &amp; 1) != 0, (modifiers &amp; 2) != 0, (modifiers &amp; 8) != 0, !name.equals(&quot;&lt;init&gt;&quot;) &amp;&amp; !name.equals(&quot;&lt;clinit&gt;&quot;) &amp;&amp; (modifiers &amp; 10) == 0, name.equals(&quot;&lt;init&gt;&quot;), !descriptor.startsWith(&quot;()&quot;) || descriptor.endsWith(&quot;V&quot;), signature != null);</b>
&nbsp;                MethodVisitor methodVisitor = super.visitMethod(modifiers, name, descriptor, signature, exceptionInternalName);
&nbsp;                return (MethodVisitor)(methodVisitor == null ? IGNORE_METHOD : new ValidatingMethodVisitor(methodVisitor, name));
&nbsp;            }
&nbsp;
&nbsp;            protected class ValidatingMethodVisitor extends MethodVisitor {
&nbsp;                private final String name;
&nbsp;
&nbsp;                protected ValidatingMethodVisitor(MethodVisitor methodVisitor, String name) {
&nbsp;                    super(OpenedClassReader.ASM_API, methodVisitor);
&nbsp;                    this.name = name;
&nbsp;                }
&nbsp;
&nbsp;                @Nonnull(
<b class="fc">&nbsp;                    when = When.MAYBE</b>
&nbsp;                )
&nbsp;                public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {
<b class="fc">&nbsp;                    ValidatingClassVisitor.this.constraint.assertAnnotation();</b>
<b class="fc">&nbsp;                    return super.visitAnnotation(descriptor, visible);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Nonnull(
&nbsp;                    when = When.MAYBE
&nbsp;                )
&nbsp;                public AnnotationVisitor visitAnnotationDefault() {
&nbsp;                    ValidatingClassVisitor.this.constraint.assertDefaultValue(this.name);
&nbsp;                    return super.visitAnnotationDefault();
&nbsp;                }
&nbsp;
&nbsp;                @SuppressFBWarnings(
&nbsp;                    value = {&quot;SF_SWITCH_NO_DEFAULT&quot;},
&nbsp;                    justification = &quot;Fall through to default case is intentional.&quot;
&nbsp;                )
&nbsp;                public void visitLdcInsn(Object value) {
&nbsp;                    if (value instanceof Type) {
&nbsp;                        Type type = (Type)value;
&nbsp;                        switch (type.getSort()) {
&nbsp;                            case 9:
&nbsp;                            case 10:
&nbsp;                                ValidatingClassVisitor.this.constraint.assertTypeInConstantPool();
&nbsp;                                break;
&nbsp;                            case 11:
&nbsp;                                ValidatingClassVisitor.this.constraint.assertMethodTypeInConstantPool();
&nbsp;                        }
&nbsp;                    } else if (value instanceof Handle) {
&nbsp;                        ValidatingClassVisitor.this.constraint.assertHandleInConstantPool();
&nbsp;                    } else if (value instanceof ConstantDynamic) {
&nbsp;                        ValidatingClassVisitor.this.constraint.assertDynamicValueInConstantPool();
&nbsp;                    }
&nbsp;
&nbsp;                    super.visitLdcInsn(value);
&nbsp;                }
&nbsp;
&nbsp;                public void visitMethodInsn(int opcode, String owner, String name, String descriptor, boolean isInterface) {
&nbsp;                    if (isInterface &amp;&amp; opcode == 183) {
&nbsp;                        ValidatingClassVisitor.this.constraint.assertDefaultMethodCall();
&nbsp;                    }
&nbsp;
&nbsp;                    super.visitMethodInsn(opcode, owner, name, descriptor, isInterface);
&nbsp;                }
&nbsp;
&nbsp;                public void visitInvokeDynamicInsn(String name, String descriptor, Handle bootstrapMethod, Object... bootstrapArgument) {
&nbsp;                    ValidatingClassVisitor.this.constraint.assertInvokeDynamic();
&nbsp;                    Object[] var5 = bootstrapArgument;
&nbsp;                    int var6 = bootstrapArgument.length;
&nbsp;
&nbsp;                    for(int var7 = 0; var7 &lt; var6; ++var7) {
&nbsp;                        Object constant = var5[var7];
&nbsp;                        if (constant instanceof ConstantDynamic) {
&nbsp;                            ValidatingClassVisitor.this.constraint.assertDynamicValueInConstantPool();
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    super.visitInvokeDynamicInsn(name, descriptor, bootstrapMethod, bootstrapArgument);
&nbsp;                }
&nbsp;
&nbsp;                public void visitJumpInsn(int opcode, Label label) {
&nbsp;                    if (opcode == 168) {
&nbsp;                        ValidatingClassVisitor.this.constraint.assertSubRoutine();
&nbsp;                    }
&nbsp;
&nbsp;                    super.visitJumpInsn(opcode, label);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            protected class ValidatingFieldVisitor extends FieldVisitor {
&nbsp;                protected ValidatingFieldVisitor(FieldVisitor fieldVisitor) {
&nbsp;                    super(OpenedClassReader.ASM_API, fieldVisitor);
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {
&nbsp;                    ValidatingClassVisitor.this.constraint.assertAnnotation();
&nbsp;                    return super.visitAnnotation(descriptor, visible);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            protected interface Constraint {
&nbsp;                void assertType(int var1, boolean var2, boolean var3);
&nbsp;
&nbsp;                void assertField(String var1, boolean var2, boolean var3, boolean var4, boolean var5);
&nbsp;
&nbsp;                void assertMethod(String var1, boolean var2, boolean var3, boolean var4, boolean var5, boolean var6, boolean var7, boolean var8, boolean var9);
&nbsp;
&nbsp;                void assertAnnotation();
&nbsp;
&nbsp;                void assertTypeAnnotation();
&nbsp;
&nbsp;                void assertDefaultValue(String var1);
&nbsp;
&nbsp;                void assertDefaultMethodCall();
&nbsp;
&nbsp;                void assertTypeInConstantPool();
&nbsp;
&nbsp;                void assertMethodTypeInConstantPool();
&nbsp;
&nbsp;                void assertHandleInConstantPool();
&nbsp;
&nbsp;                void assertInvokeDynamic();
&nbsp;
&nbsp;                void assertSubRoutine();
&nbsp;
&nbsp;                void assertDynamicValueInConstantPool();
&nbsp;
&nbsp;                void assertNestMate();
&nbsp;
&nbsp;                void assertRecord();
&nbsp;
&nbsp;                void assertPermittedSubclass();
&nbsp;
&nbsp;                @Enhance
&nbsp;                public static class Compound implements Constraint {
&nbsp;                    private final List&lt;Constraint&gt; constraints = new ArrayList();
&nbsp;
&nbsp;                    public Compound(List&lt;? extends Constraint&gt; constraints) {
&nbsp;                        Iterator var2 = constraints.iterator();
&nbsp;
&nbsp;                        while(var2.hasNext()) {
&nbsp;                            Constraint constraint = (Constraint)var2.next();
&nbsp;                            if (constraint instanceof Compound) {
&nbsp;                                this.constraints.addAll(((Compound)constraint).constraints);
&nbsp;                            } else {
&nbsp;                                this.constraints.add(constraint);
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertType(int modifier, boolean definesInterfaces, boolean isGeneric) {
&nbsp;                        Iterator var4 = this.constraints.iterator();
&nbsp;
&nbsp;                        while(var4.hasNext()) {
&nbsp;                            Constraint constraint = (Constraint)var4.next();
&nbsp;                            constraint.assertType(modifier, definesInterfaces, isGeneric);
&nbsp;                        }
&nbsp;
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertField(String name, boolean isPublic, boolean isStatic, boolean isFinal, boolean isGeneric) {
&nbsp;                        Iterator var6 = this.constraints.iterator();
&nbsp;
&nbsp;                        while(var6.hasNext()) {
&nbsp;                            Constraint constraint = (Constraint)var6.next();
&nbsp;                            constraint.assertField(name, isPublic, isStatic, isFinal, isGeneric);
&nbsp;                        }
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                    public void assertMethod(String name, boolean isAbstract, boolean isPublic, boolean isPrivate, boolean isStatic, boolean isVirtual, boolean isConstructor, boolean isDefaultValueIncompatible, boolean isGeneric) {</b>
<b class="fc">&nbsp;                        Iterator var10 = this.constraints.iterator();</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                        while(var10.hasNext()) {</b>
<b class="fc">&nbsp;                            Constraint constraint = (Constraint)var10.next();</b>
<b class="fc">&nbsp;                            constraint.assertMethod(name, isAbstract, isPublic, isPrivate, isStatic, isVirtual, isConstructor, isDefaultValueIncompatible, isGeneric);</b>
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                    public void assertDefaultValue(String name) {</b>
<b class="fc">&nbsp;                        Iterator var2 = this.constraints.iterator();</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                        while(var2.hasNext()) {</b>
<b class="fc">&nbsp;                            Constraint constraint = (Constraint)var2.next();</b>
<b class="fc">&nbsp;                            constraint.assertDefaultValue(name);</b>
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertDefaultMethodCall() {
&nbsp;                        Iterator var1 = this.constraints.iterator();
&nbsp;
&nbsp;                        while(var1.hasNext()) {
&nbsp;                            Constraint constraint = (Constraint)var1.next();
&nbsp;                            constraint.assertDefaultMethodCall();
&nbsp;                        }
&nbsp;
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertAnnotation() {
&nbsp;                        Iterator var1 = this.constraints.iterator();
&nbsp;
&nbsp;                        while(var1.hasNext()) {
&nbsp;                            Constraint constraint = (Constraint)var1.next();
&nbsp;                            constraint.assertAnnotation();
&nbsp;                        }
&nbsp;
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertTypeAnnotation() {
&nbsp;                        Iterator var1 = this.constraints.iterator();
&nbsp;
&nbsp;                        while(var1.hasNext()) {
&nbsp;                            Constraint constraint = (Constraint)var1.next();
&nbsp;                            constraint.assertTypeAnnotation();
&nbsp;                        }
&nbsp;
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertTypeInConstantPool() {
&nbsp;                        Iterator var1 = this.constraints.iterator();
&nbsp;
&nbsp;                        while(var1.hasNext()) {
&nbsp;                            Constraint constraint = (Constraint)var1.next();
&nbsp;                            constraint.assertTypeInConstantPool();
&nbsp;                        }
&nbsp;
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertMethodTypeInConstantPool() {
&nbsp;                        Iterator var1 = this.constraints.iterator();
&nbsp;
&nbsp;                        while(var1.hasNext()) {
&nbsp;                            Constraint constraint = (Constraint)var1.next();
&nbsp;                            constraint.assertMethodTypeInConstantPool();
&nbsp;                        }
&nbsp;
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertHandleInConstantPool() {
&nbsp;                        Iterator var1 = this.constraints.iterator();
&nbsp;
&nbsp;                        while(var1.hasNext()) {
&nbsp;                            Constraint constraint = (Constraint)var1.next();
&nbsp;                            constraint.assertHandleInConstantPool();
&nbsp;                        }
&nbsp;
&nbsp;                    }
<b class="fc">&nbsp;</b>
&nbsp;                    public void assertInvokeDynamic() {
&nbsp;                        Iterator var1 = this.constraints.iterator();
&nbsp;
&nbsp;                        while(var1.hasNext()) {
&nbsp;                            Constraint constraint = (Constraint)var1.next();
<b class="fc">&nbsp;                            constraint.assertInvokeDynamic();</b>
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                    public void assertSubRoutine() {</b>
&nbsp;                        Iterator var1 = this.constraints.iterator();
&nbsp;
&nbsp;                        while(var1.hasNext()) {
&nbsp;                            Constraint constraint = (Constraint)var1.next();
&nbsp;                            constraint.assertSubRoutine();
&nbsp;                        }
&nbsp;
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertDynamicValueInConstantPool() {
&nbsp;                        Iterator var1 = this.constraints.iterator();
&nbsp;
&nbsp;                        while(var1.hasNext()) {
&nbsp;                            Constraint constraint = (Constraint)var1.next();
&nbsp;                            constraint.assertDynamicValueInConstantPool();
&nbsp;                        }
&nbsp;
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertNestMate() {
&nbsp;                        Iterator var1 = this.constraints.iterator();
&nbsp;
&nbsp;                        while(var1.hasNext()) {
&nbsp;                            Constraint constraint = (Constraint)var1.next();
&nbsp;                            constraint.assertNestMate();
&nbsp;                        }
&nbsp;
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertRecord() {
&nbsp;                        Iterator var1 = this.constraints.iterator();
&nbsp;
&nbsp;                        while(var1.hasNext()) {
&nbsp;                            Constraint constraint = (Constraint)var1.next();
&nbsp;                            constraint.assertRecord();
&nbsp;                        }
&nbsp;
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertPermittedSubclass() {
&nbsp;                        Iterator var1 = this.constraints.iterator();
&nbsp;
&nbsp;                        while(var1.hasNext()) {
&nbsp;                            Constraint constraint = (Constraint)var1.next();
&nbsp;                            constraint.assertPermittedSubclass();
&nbsp;                        }
&nbsp;
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(Object var1) {
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return this.constraints.equals(((Compound)var1).constraints);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return this.getClass().hashCode() * 31 + this.constraints.hashCode();
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Enhance
&nbsp;                public static class ForClassFileVersion implements Constraint {
&nbsp;                    private final ClassFileVersion classFileVersion;
&nbsp;
&nbsp;                    protected ForClassFileVersion(ClassFileVersion classFileVersion) {
&nbsp;                        this.classFileVersion = classFileVersion;
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertType(int modifiers, boolean definesInterfaces, boolean isGeneric) {
&nbsp;                        if ((modifiers &amp; 8192) != 0 &amp;&amp; !this.classFileVersion.isAtLeast(ClassFileVersion.JAVA_V5)) {
&nbsp;                            throw new IllegalStateException(&quot;Cannot define annotation type for class file version &quot; + this.classFileVersion);
&nbsp;                        } else if (isGeneric &amp;&amp; !this.classFileVersion.isAtLeast(ClassFileVersion.JAVA_V4)) {
&nbsp;                            throw new IllegalStateException(&quot;Cannot define a generic type for class file version &quot; + this.classFileVersion);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertField(String name, boolean isPublic, boolean isStatic, boolean isFinal, boolean isGeneric) {
&nbsp;                        if (isGeneric &amp;&amp; !this.classFileVersion.isAtLeast(ClassFileVersion.JAVA_V4)) {
&nbsp;                            throw new IllegalStateException(&quot;Cannot define generic field &#39;&quot; + name + &quot;&#39; for class file version &quot; + this.classFileVersion);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertMethod(String name, boolean isAbstract, boolean isPublic, boolean isPrivate, boolean isStatic, boolean isVirtual, boolean isConstructor, boolean isDefaultValueIncompatible, boolean isGeneric) {
&nbsp;                        if (isGeneric &amp;&amp; !this.classFileVersion.isAtLeast(ClassFileVersion.JAVA_V4)) {
&nbsp;                            throw new IllegalStateException(&quot;Cannot define generic method &#39;&quot; + name + &quot;&#39; for class file version &quot; + this.classFileVersion);
&nbsp;                        } else if (!isVirtual &amp;&amp; isAbstract) {
&nbsp;                            throw new IllegalStateException(&quot;Cannot define static or non-virtual method &#39;&quot; + name + &quot;&#39; to be abstract&quot;);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertAnnotation() {
&nbsp;                        if (this.classFileVersion.isLessThan(ClassFileVersion.JAVA_V5)) {
&nbsp;                            throw new IllegalStateException(&quot;Cannot write annotations for class file version &quot; + this.classFileVersion);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertTypeAnnotation() {
&nbsp;                        if (this.classFileVersion.isLessThan(ClassFileVersion.JAVA_V5)) {
&nbsp;                            throw new IllegalStateException(&quot;Cannot write type annotations for class file version &quot; + this.classFileVersion);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertDefaultValue(String name) {
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertDefaultMethodCall() {
&nbsp;                        if (this.classFileVersion.isLessThan(ClassFileVersion.JAVA_V8)) {
&nbsp;                            throw new IllegalStateException(&quot;Cannot invoke default method for class file version &quot; + this.classFileVersion);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertTypeInConstantPool() {
&nbsp;                        if (this.classFileVersion.isLessThan(ClassFileVersion.JAVA_V5)) {
&nbsp;                            throw new IllegalStateException(&quot;Cannot write type to constant pool for class file version &quot; + this.classFileVersion);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertMethodTypeInConstantPool() {
&nbsp;                        if (this.classFileVersion.isLessThan(ClassFileVersion.JAVA_V7)) {
&nbsp;                            throw new IllegalStateException(&quot;Cannot write method type to constant pool for class file version &quot; + this.classFileVersion);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertHandleInConstantPool() {
&nbsp;                        if (this.classFileVersion.isLessThan(ClassFileVersion.JAVA_V7)) {
&nbsp;                            throw new IllegalStateException(&quot;Cannot write method handle to constant pool for class file version &quot; + this.classFileVersion);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertInvokeDynamic() {
&nbsp;                        if (this.classFileVersion.isLessThan(ClassFileVersion.JAVA_V7)) {
&nbsp;                            throw new IllegalStateException(&quot;Cannot write invoke dynamic instruction for class file version &quot; + this.classFileVersion);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertSubRoutine() {
&nbsp;                        if (this.classFileVersion.isGreaterThan(ClassFileVersion.JAVA_V5)) {
&nbsp;                            throw new IllegalStateException(&quot;Cannot write subroutine for class file version &quot; + this.classFileVersion);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertDynamicValueInConstantPool() {
&nbsp;                        if (this.classFileVersion.isLessThan(ClassFileVersion.JAVA_V11)) {
&nbsp;                            throw new IllegalStateException(&quot;Cannot write dynamic constant for class file version &quot; + this.classFileVersion);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertNestMate() {
&nbsp;                        if (this.classFileVersion.isLessThan(ClassFileVersion.JAVA_V11)) {
&nbsp;                            throw new IllegalStateException(&quot;Cannot define nest mate for class file version &quot; + this.classFileVersion);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertRecord() {
&nbsp;                        if (this.classFileVersion.isLessThan(ClassFileVersion.JAVA_V14)) {
&nbsp;                            throw new IllegalStateException(&quot;Cannot define record for class file version &quot; + this.classFileVersion);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertPermittedSubclass() {
&nbsp;                        if (this.classFileVersion.isLessThan(ClassFileVersion.JAVA_V17)) {
&nbsp;                            throw new IllegalStateException(&quot;Cannot define permitted subclasses for class file version &quot; + this.classFileVersion);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(Object var1) {
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return this.classFileVersion.equals(((ForClassFileVersion)var1).classFileVersion);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return this.getClass().hashCode() * 31 + this.classFileVersion.hashCode();
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public static enum ForAnnotation implements Constraint {
&nbsp;                    CLASSIC(true),
&nbsp;                    JAVA_8(false);
&nbsp;
&nbsp;                    private final boolean classic;
&nbsp;
&nbsp;                    private ForAnnotation(boolean classic) {
&nbsp;                        this.classic = classic;
&nbsp;                    }
&nbsp;
<b class="fc">&nbsp;                    public void assertField(String name, boolean isPublic, boolean isStatic, boolean isFinal, boolean isGeneric) {</b>
&nbsp;                        if (!isStatic || !isPublic || !isFinal) {
&nbsp;                            throw new IllegalStateException(&quot;Cannot only define public, static, final field &#39;&quot; + name + &quot;&#39; for interface type&quot;);
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;</b>
&nbsp;                    public void assertMethod(String name, boolean isAbstract, boolean isPublic, boolean isPrivate, boolean isStatic, boolean isVirtual, boolean isConstructor, boolean isDefaultValueIncompatible, boolean isGeneric) {
&nbsp;                        if (!name.equals(&quot;&lt;clinit&gt;&quot;)) {
&nbsp;                            if (isConstructor) {
&nbsp;                                throw new IllegalStateException(&quot;Cannot define constructor for interface type&quot;);
&nbsp;                            }
&nbsp;
&nbsp;                            if (this.classic &amp;&amp; !isVirtual) {
&nbsp;                                throw new IllegalStateException(&quot;Cannot define non-virtual method &#39;&quot; + name + &quot;&#39; for a pre-Java 8 annotation type&quot;);
&nbsp;                            }
&nbsp;
&nbsp;                            if (!isStatic &amp;&amp; isDefaultValueIncompatible) {
&nbsp;                                throw new IllegalStateException(&quot;Cannot define method &#39;&quot; + name + &quot;&#39; with the given signature as an annotation type method&quot;);
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertAnnotation() {
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertTypeAnnotation() {
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertDefaultValue(String name) {
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertDefaultMethodCall() {
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertType(int modifier, boolean definesInterfaces, boolean isGeneric) {
&nbsp;                        if ((modifier &amp; 512) == 0) {
&nbsp;                            throw new IllegalStateException(&quot;Cannot define annotation type without interface modifier&quot;);
&nbsp;                        }
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                    public void assertTypeInConstantPool() {</b>
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertMethodTypeInConstantPool() {
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertHandleInConstantPool() {
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertInvokeDynamic() {
<b class="fc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    public void assertSubRoutine() {
<b class="fc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    public void assertDynamicValueInConstantPool() {
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertNestMate() {
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertRecord() {
&nbsp;                    }
<b class="fc">&nbsp;</b>
&nbsp;                    public void assertPermittedSubclass() {
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public static enum ForRecord implements Constraint {
&nbsp;                    INSTANCE;
&nbsp;
&nbsp;                    private ForRecord() {
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertField(String name, boolean isPublic, boolean isStatic, boolean isFinal, boolean isGeneric) {
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertMethod(String name, boolean isAbstract, boolean isPublic, boolean isPrivate, boolean isStatic, boolean isVirtual, boolean isConstructor, boolean isDefaultValueIncompatible, boolean isGeneric) {
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertAnnotation() {
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertTypeAnnotation() {
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertDefaultValue(String name) {
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertDefaultMethodCall() {
&nbsp;                    }
<b class="fc">&nbsp;</b>
&nbsp;                    public void assertType(int modifier, boolean definesInterfaces, boolean isGeneric) {
&nbsp;                        if ((modifier &amp; 1024) != 0) {
&nbsp;                            throw new IllegalStateException(&quot;Cannot define a record class as abstract&quot;);
&nbsp;                        }
&nbsp;                    }
<b class="fc">&nbsp;</b>
&nbsp;                    public void assertTypeInConstantPool() {
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertMethodTypeInConstantPool() {
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertHandleInConstantPool() {
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertInvokeDynamic() {
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertSubRoutine() {
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertDynamicValueInConstantPool() {
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertNestMate() {
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertRecord() {
&nbsp;                    }
&nbsp;
<b class="fc">&nbsp;                    public void assertPermittedSubclass() {</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public static enum ForInterface implements Constraint {
&nbsp;                    CLASSIC(true),
&nbsp;                    JAVA_8(false);
&nbsp;
&nbsp;                    private final boolean classic;
&nbsp;
&nbsp;                    private ForInterface(boolean classic) {
&nbsp;                        this.classic = classic;
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertField(String name, boolean isPublic, boolean isStatic, boolean isFinal, boolean isGeneric) {
&nbsp;                        if (!isStatic || !isPublic || !isFinal) {
&nbsp;                            throw new IllegalStateException(&quot;Cannot only define public, static, final field &#39;&quot; + name + &quot;&#39; for interface type&quot;);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertMethod(String name, boolean isAbstract, boolean isPublic, boolean isPrivate, boolean isStatic, boolean isVirtual, boolean isConstructor, boolean isDefaultValueIncompatible, boolean isGeneric) {
&nbsp;                        if (!name.equals(&quot;&lt;clinit&gt;&quot;)) {
&nbsp;                            if (isConstructor) {
&nbsp;                                throw new IllegalStateException(&quot;Cannot define constructor for interface type&quot;);
&nbsp;                            }
&nbsp;
&nbsp;                            if (this.classic &amp;&amp; !isPublic) {
&nbsp;                                throw new IllegalStateException(&quot;Cannot define non-public method &#39;&quot; + name + &quot;&#39; for interface type&quot;);
&nbsp;                            }
&nbsp;
&nbsp;                            if (this.classic &amp;&amp; !isVirtual) {
&nbsp;                                throw new IllegalStateException(&quot;Cannot define non-virtual method &#39;&quot; + name + &quot;&#39; for a pre-Java 8 interface type&quot;);
&nbsp;                            }
&nbsp;
&nbsp;                            if (this.classic &amp;&amp; !isAbstract) {
&nbsp;                                throw new IllegalStateException(&quot;Cannot define default method &#39;&quot; + name + &quot;&#39; for pre-Java 8 interface type&quot;);
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertAnnotation() {
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertTypeAnnotation() {
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertDefaultValue(String name) {
&nbsp;                        throw new IllegalStateException(&quot;Cannot define default value for &#39;&quot; + name + &quot;&#39; for non-annotation type&quot;);
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertDefaultMethodCall() {
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertType(int modifier, boolean definesInterfaces, boolean isGeneric) {
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertTypeInConstantPool() {
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertMethodTypeInConstantPool() {
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertHandleInConstantPool() {
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertInvokeDynamic() {
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertSubRoutine() {
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertDynamicValueInConstantPool() {
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertNestMate() {
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertRecord() {
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertPermittedSubclass() {
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public static enum ForPackageType implements Constraint {
&nbsp;                    INSTANCE;
&nbsp;
&nbsp;                    private ForPackageType() {
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertField(String name, boolean isPublic, boolean isStatic, boolean isFinal, boolean isGeneric) {
&nbsp;                        throw new IllegalStateException(&quot;Cannot define a field for a package description type&quot;);
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertMethod(String name, boolean isAbstract, boolean isPublic, boolean isPrivate, boolean isStatic, boolean isVirtual, boolean isConstructor, boolean isNoDefaultValue, boolean isGeneric) {
&nbsp;                        throw new IllegalStateException(&quot;Cannot define a method for a package description type&quot;);
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertAnnotation() {
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertTypeAnnotation() {
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertDefaultValue(String name) {
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertDefaultMethodCall() {
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertTypeInConstantPool() {
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertMethodTypeInConstantPool() {
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertHandleInConstantPool() {
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertInvokeDynamic() {
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertSubRoutine() {
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertType(int modifier, boolean definesInterfaces, boolean isGeneric) {
&nbsp;                        if (modifier != 5632) {
&nbsp;                            throw new IllegalStateException(&quot;A package description type must define 5632 as modifier&quot;);
&nbsp;                        } else if (definesInterfaces) {
&nbsp;                            throw new IllegalStateException(&quot;Cannot implement interface for package type&quot;);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertDynamicValueInConstantPool() {
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertNestMate() {
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertRecord() {
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertPermittedSubclass() {
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public static enum ForClass implements Constraint {
&nbsp;                    MANIFEST(true),
&nbsp;                    ABSTRACT(false);
&nbsp;
&nbsp;                    private final boolean manifestType;
&nbsp;
&nbsp;                    private ForClass(boolean manifestType) {
&nbsp;                        this.manifestType = manifestType;
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertType(int modifier, boolean definesInterfaces, boolean isGeneric) {
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertField(String name, boolean isPublic, boolean isStatic, boolean isFinal, boolean isGeneric) {
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertMethod(String name, boolean isAbstract, boolean isPublic, boolean isPrivate, boolean isStatic, boolean isVirtual, boolean isConstructor, boolean isDefaultValueIncompatible, boolean isGeneric) {
&nbsp;                        if (isAbstract &amp;&amp; this.manifestType) {
&nbsp;                            throw new IllegalStateException(&quot;Cannot define abstract method &#39;&quot; + name + &quot;&#39; for non-abstract class&quot;);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertAnnotation() {
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertTypeAnnotation() {
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertDefaultValue(String name) {
&nbsp;                        throw new IllegalStateException(&quot;Cannot define default value for &#39;&quot; + name + &quot;&#39; for non-annotation type&quot;);
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertDefaultMethodCall() {
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertTypeInConstantPool() {
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertMethodTypeInConstantPool() {
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertHandleInConstantPool() {
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertInvokeDynamic() {
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertSubRoutine() {
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertDynamicValueInConstantPool() {
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertNestMate() {
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertRecord() {
&nbsp;                    }
&nbsp;
&nbsp;                    public void assertPermittedSubclass() {
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Enhance(
&nbsp;            includeSyntheticFields = true
&nbsp;        )
&nbsp;        protected class UnresolvedType {
&nbsp;            private final byte[] binaryRepresentation;
&nbsp;            private final List&lt;? extends DynamicType&gt; auxiliaryTypes;
&nbsp;
&nbsp;            protected UnresolvedType(byte[] binaryRepresentation, List&lt;? extends DynamicType&gt; auxiliaryTypes) {
&nbsp;                this.binaryRepresentation = binaryRepresentation;
&nbsp;                this.auxiliaryTypes = auxiliaryTypes;
&nbsp;            }
&nbsp;
&nbsp;            protected DynamicType.Unloaded&lt;S&gt; toDynamicType(TypeResolutionStrategy.Resolved typeResolutionStrategy) {
&nbsp;                return new DynamicType.Unloaded(Default.this.instrumentedType, this.binaryRepresentation, Default.this.loadedTypeInitializer, CompoundList.of(Default.this.auxiliaryTypes, this.auxiliaryTypes), typeResolutionStrategy);
&nbsp;            }
&nbsp;
&nbsp;            protected byte[] getBinaryRepresentation() {
&nbsp;                return this.binaryRepresentation;
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(Object var1) {
&nbsp;                if (this == var1) {
&nbsp;                    return true;
&nbsp;                } else if (var1 == null) {
&nbsp;                    return false;
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
&nbsp;                } else if (!Arrays.equals(this.binaryRepresentation, ((UnresolvedType)var1).binaryRepresentation)) {
&nbsp;                    return false;
&nbsp;                } else if (!this.auxiliaryTypes.equals(((UnresolvedType)var1).auxiliaryTypes)) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return Default.this.equals(Default.this);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public int hashCode() {
&nbsp;                return ((this.getClass().hashCode() * 31 + Arrays.hashCode(this.binaryRepresentation)) * 31 + this.auxiliaryTypes.hashCode()) * 31 + Default.this.hashCode();
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public interface RecordComponentPool {
&nbsp;        Record target(RecordComponentDescription var1);
&nbsp;
&nbsp;        public static enum Disabled implements RecordComponentPool {
&nbsp;            INSTANCE;
&nbsp;
&nbsp;            private Disabled() {
&nbsp;            }
&nbsp;
&nbsp;            public Record target(RecordComponentDescription recordComponentDescription) {
&nbsp;                throw new IllegalStateException(&quot;Cannot look up record component from disabled pool&quot;);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public interface Record {
&nbsp;            boolean isImplicit();
&nbsp;
&nbsp;            RecordComponentDescription getRecordComponent();
&nbsp;
&nbsp;            RecordComponentAttributeAppender getRecordComponentAppender();
&nbsp;
&nbsp;            void apply(ClassVisitor var1, AnnotationValueFilter.Factory var2);
&nbsp;
&nbsp;            void apply(RecordComponentVisitor var1, AnnotationValueFilter.Factory var2);
&nbsp;
&nbsp;            @Enhance
&nbsp;            public static class ForExplicitRecordComponent implements Record {
&nbsp;                private final RecordComponentAttributeAppender attributeAppender;
&nbsp;                private final RecordComponentDescription recordComponentDescription;
&nbsp;
&nbsp;                public ForExplicitRecordComponent(RecordComponentAttributeAppender attributeAppender, RecordComponentDescription recordComponentDescription) {
&nbsp;                    this.attributeAppender = attributeAppender;
&nbsp;                    this.recordComponentDescription = recordComponentDescription;
&nbsp;                }
&nbsp;
&nbsp;                public boolean isImplicit() {
&nbsp;                    return false;
&nbsp;                }
&nbsp;
&nbsp;                public RecordComponentDescription getRecordComponent() {
&nbsp;                    return this.recordComponentDescription;
&nbsp;                }
&nbsp;
&nbsp;                public RecordComponentAttributeAppender getRecordComponentAppender() {
&nbsp;                    return this.attributeAppender;
&nbsp;                }
&nbsp;
&nbsp;                public void apply(ClassVisitor classVisitor, AnnotationValueFilter.Factory annotationValueFilterFactory) {
&nbsp;                    RecordComponentVisitor recordComponentVisitor = classVisitor.visitRecordComponent(this.recordComponentDescription.getActualName(), this.recordComponentDescription.getDescriptor(), this.recordComponentDescription.getGenericSignature());
&nbsp;                    if (recordComponentVisitor != null) {
&nbsp;                        this.attributeAppender.apply(recordComponentVisitor, this.recordComponentDescription, annotationValueFilterFactory.on(this.recordComponentDescription));
&nbsp;                        recordComponentVisitor.visitEnd();
&nbsp;                    }
&nbsp;
&nbsp;                }
&nbsp;
&nbsp;                public void apply(RecordComponentVisitor recordComponentVisitor, AnnotationValueFilter.Factory annotationValueFilterFactory) {
&nbsp;                    this.attributeAppender.apply(recordComponentVisitor, this.recordComponentDescription, annotationValueFilterFactory.on(this.recordComponentDescription));
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(Object var1) {
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.attributeAppender.equals(((ForExplicitRecordComponent)var1).attributeAppender)) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.recordComponentDescription.equals(((ForExplicitRecordComponent)var1).recordComponentDescription);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return (this.getClass().hashCode() * 31 + this.attributeAppender.hashCode()) * 31 + this.recordComponentDescription.hashCode();
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Enhance
&nbsp;            public static class ForImplicitRecordComponent implements Record {
&nbsp;                private final RecordComponentDescription recordComponentDescription;
&nbsp;
&nbsp;                public ForImplicitRecordComponent(RecordComponentDescription recordComponentDescription) {
&nbsp;                    this.recordComponentDescription = recordComponentDescription;
&nbsp;                }
&nbsp;
&nbsp;                public boolean isImplicit() {
&nbsp;                    return true;
&nbsp;                }
&nbsp;
&nbsp;                public RecordComponentDescription getRecordComponent() {
&nbsp;                    return this.recordComponentDescription;
&nbsp;                }
&nbsp;
&nbsp;                public RecordComponentAttributeAppender getRecordComponentAppender() {
&nbsp;                    throw new IllegalStateException(&quot;An implicit field record does not expose a field appender: &quot; + this);
&nbsp;                }
&nbsp;
&nbsp;                public void apply(ClassVisitor classVisitor, AnnotationValueFilter.Factory annotationValueFilterFactory) {
&nbsp;                    RecordComponentVisitor recordComponentVisitor = classVisitor.visitRecordComponent(this.recordComponentDescription.getActualName(), this.recordComponentDescription.getDescriptor(), this.recordComponentDescription.getGenericSignature());
&nbsp;                    if (recordComponentVisitor != null) {
&nbsp;                        ForInstrumentedRecordComponent.INSTANCE.apply(recordComponentVisitor, this.recordComponentDescription, annotationValueFilterFactory.on(this.recordComponentDescription));
&nbsp;                        recordComponentVisitor.visitEnd();
&nbsp;                    }
&nbsp;
&nbsp;                }
&nbsp;
&nbsp;                public void apply(RecordComponentVisitor recordComponentVisitor, AnnotationValueFilter.Factory annotationValueFilterFactory) {
&nbsp;                    throw new IllegalStateException(&quot;An implicit field record is not intended for partial application: &quot; + this);
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(Object var1) {
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.recordComponentDescription.equals(((ForImplicitRecordComponent)var1).recordComponentDescription);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return this.getClass().hashCode() * 31 + this.recordComponentDescription.hashCode();
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public interface MethodPool {
&nbsp;        Record target(MethodDescription var1);
&nbsp;
&nbsp;        public interface Record {
&nbsp;            Sort getSort();
&nbsp;
&nbsp;            MethodDescription getMethod();
&nbsp;
&nbsp;            Visibility getVisibility();
&nbsp;
&nbsp;            Record prepend(ByteCodeAppender var1);
&nbsp;
&nbsp;            void apply(ClassVisitor var1, Implementation.Context var2, AnnotationValueFilter.Factory var3);
&nbsp;
&nbsp;            void applyHead(MethodVisitor var1);
&nbsp;
&nbsp;            void applyBody(MethodVisitor var1, Implementation.Context var2, AnnotationValueFilter.Factory var3);
&nbsp;
&nbsp;            void applyAttributes(MethodVisitor var1, AnnotationValueFilter.Factory var2);
&nbsp;
&nbsp;            ByteCodeAppender.Size applyCode(MethodVisitor var1, Implementation.Context var2);
&nbsp;
&nbsp;            @Enhance
&nbsp;            public static class AccessBridgeWrapper implements Record {
&nbsp;                private final Record delegate;
&nbsp;                private final TypeDescription instrumentedType;
&nbsp;                private final MethodDescription bridgeTarget;
&nbsp;                private final Set&lt;MethodDescription.TypeToken&gt; bridgeTypes;
&nbsp;                private final MethodAttributeAppender attributeAppender;
&nbsp;
&nbsp;                protected AccessBridgeWrapper(Record delegate, TypeDescription instrumentedType, MethodDescription bridgeTarget, Set&lt;MethodDescription.TypeToken&gt; bridgeTypes, MethodAttributeAppender attributeAppender) {
&nbsp;                    this.delegate = delegate;
&nbsp;                    this.instrumentedType = instrumentedType;
&nbsp;                    this.bridgeTarget = bridgeTarget;
&nbsp;                    this.bridgeTypes = bridgeTypes;
&nbsp;                    this.attributeAppender = attributeAppender;
&nbsp;                }
&nbsp;
&nbsp;                public static Record of(Record delegate, TypeDescription instrumentedType, MethodDescription bridgeTarget, Set&lt;MethodDescription.TypeToken&gt; bridgeTypes, MethodAttributeAppender attributeAppender) {
&nbsp;                    Set&lt;MethodDescription.TypeToken&gt; compatibleBridgeTypes = new HashSet();
&nbsp;                    Iterator var6 = bridgeTypes.iterator();
&nbsp;
&nbsp;                    while(var6.hasNext()) {
&nbsp;                        MethodDescription.TypeToken bridgeType = (MethodDescription.TypeToken)var6.next();
&nbsp;                        if (bridgeTarget.isBridgeCompatible(bridgeType)) {
&nbsp;                            compatibleBridgeTypes.add(bridgeType);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    return (Record)(!compatibleBridgeTypes.isEmpty() &amp;&amp; (!instrumentedType.isInterface() || delegate.getSort().isImplemented()) ? new AccessBridgeWrapper(delegate, instrumentedType, bridgeTarget, compatibleBridgeTypes, attributeAppender) : delegate);
&nbsp;                }
&nbsp;
&nbsp;                public Sort getSort() {
&nbsp;                    return this.delegate.getSort();
&nbsp;                }
&nbsp;
&nbsp;                public MethodDescription getMethod() {
&nbsp;                    return this.bridgeTarget;
&nbsp;                }
&nbsp;
&nbsp;                public Visibility getVisibility() {
&nbsp;                    return this.delegate.getVisibility();
&nbsp;                }
&nbsp;
&nbsp;                public Record prepend(ByteCodeAppender byteCodeAppender) {
&nbsp;                    return new AccessBridgeWrapper(this.delegate.prepend(byteCodeAppender), this.instrumentedType, this.bridgeTarget, this.bridgeTypes, this.attributeAppender);
&nbsp;                }
&nbsp;
&nbsp;                public void apply(ClassVisitor classVisitor, Implementation.Context implementationContext, AnnotationValueFilter.Factory annotationValueFilterFactory) {
&nbsp;                    this.delegate.apply(classVisitor, implementationContext, annotationValueFilterFactory);
&nbsp;                    Iterator var4 = this.bridgeTypes.iterator();
&nbsp;
&nbsp;                    while(var4.hasNext()) {
&nbsp;                        MethodDescription.TypeToken bridgeType = (MethodDescription.TypeToken)var4.next();
&nbsp;                        MethodDescription.InDefinedShape bridgeMethod = new AccessorBridge(this.bridgeTarget, bridgeType, this.instrumentedType);
&nbsp;                        MethodDescription.InDefinedShape bridgeTarget = new BridgeTarget(this.bridgeTarget, this.instrumentedType);
&nbsp;                        MethodVisitor methodVisitor = classVisitor.visitMethod(bridgeMethod.getActualModifiers(true, this.getVisibility()), bridgeMethod.getInternalName(), bridgeMethod.getDescriptor(), MethodDescription.NON_GENERIC_SIGNATURE, bridgeMethod.getExceptionTypes().asErasures().toInternalNames());
&nbsp;                        if (methodVisitor != null) {
&nbsp;                            this.attributeAppender.apply(methodVisitor, bridgeMethod, annotationValueFilterFactory.on(this.instrumentedType));
&nbsp;                            methodVisitor.visitCode();
&nbsp;                            ByteCodeAppender.Size size = (new ByteCodeAppender.Simple(new StackManipulation[]{MethodVariableAccess.allArgumentsOf(bridgeMethod).asBridgeOf(bridgeTarget).prependThisReference(), MethodInvocation.invoke(bridgeTarget).virtual(this.instrumentedType), (StackManipulation)(bridgeTarget.getReturnType().asErasure().isAssignableTo(bridgeMethod.getReturnType().asErasure()) ? Trivial.INSTANCE : TypeCasting.to(bridgeMethod.getReturnType().asErasure())), MethodReturn.of(bridgeMethod.getReturnType())})).apply(methodVisitor, implementationContext, bridgeMethod);
&nbsp;                            methodVisitor.visitMaxs(size.getOperandStackSize(), size.getLocalVariableSize());
&nbsp;                            methodVisitor.visitEnd();
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                }
&nbsp;
&nbsp;                public void applyHead(MethodVisitor methodVisitor) {
&nbsp;                    this.delegate.applyHead(methodVisitor);
&nbsp;                }
&nbsp;
&nbsp;                public void applyBody(MethodVisitor methodVisitor, Implementation.Context implementationContext, AnnotationValueFilter.Factory annotationValueFilterFactory) {
&nbsp;                    this.delegate.applyBody(methodVisitor, implementationContext, annotationValueFilterFactory);
&nbsp;                }
&nbsp;
&nbsp;                public void applyAttributes(MethodVisitor methodVisitor, AnnotationValueFilter.Factory annotationValueFilterFactory) {
&nbsp;                    this.delegate.applyAttributes(methodVisitor, annotationValueFilterFactory);
&nbsp;                }
&nbsp;
&nbsp;                public ByteCodeAppender.Size applyCode(MethodVisitor methodVisitor, Implementation.Context implementationContext) {
&nbsp;                    return this.delegate.applyCode(methodVisitor, implementationContext);
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(Object var1) {
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.delegate.equals(((AccessBridgeWrapper)var1).delegate)) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.instrumentedType.equals(((AccessBridgeWrapper)var1).instrumentedType)) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.bridgeTarget.equals(((AccessBridgeWrapper)var1).bridgeTarget)) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.bridgeTypes.equals(((AccessBridgeWrapper)var1).bridgeTypes)) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.attributeAppender.equals(((AccessBridgeWrapper)var1).attributeAppender);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return ((((this.getClass().hashCode() * 31 + this.delegate.hashCode()) * 31 + this.instrumentedType.hashCode()) * 31 + this.bridgeTarget.hashCode()) * 31 + this.bridgeTypes.hashCode()) * 31 + this.attributeAppender.hashCode();
&nbsp;                }
&nbsp;
&nbsp;                protected static class BridgeTarget extends MethodDescription.InDefinedShape.AbstractBase {
&nbsp;                    private final MethodDescription bridgeTarget;
&nbsp;                    private final TypeDescription instrumentedType;
&nbsp;
&nbsp;                    protected BridgeTarget(MethodDescription bridgeTarget, TypeDescription instrumentedType) {
&nbsp;                        this.bridgeTarget = bridgeTarget;
&nbsp;                        this.instrumentedType = instrumentedType;
&nbsp;                    }
&nbsp;
&nbsp;                    @Nonnull
&nbsp;                    public TypeDescription getDeclaringType() {
&nbsp;                        return this.instrumentedType;
&nbsp;                    }
&nbsp;
&nbsp;                    public ParameterList&lt;ParameterDescription.InDefinedShape&gt; getParameters() {
&nbsp;                        return new ParameterList.ForTokens(this, this.bridgeTarget.getParameters().asTokenList(ElementMatchers.is(this.instrumentedType)));
&nbsp;                    }
&nbsp;
&nbsp;                    public TypeDescription.Generic getReturnType() {
&nbsp;                        return this.bridgeTarget.getReturnType();
&nbsp;                    }
&nbsp;
&nbsp;                    public TypeList.Generic getExceptionTypes() {
&nbsp;                        return this.bridgeTarget.getExceptionTypes();
&nbsp;                    }
&nbsp;
&nbsp;                    @Nonnull(
&nbsp;                        when = When.MAYBE
&nbsp;                    )
&nbsp;                    public AnnotationValue&lt;?, ?&gt; getDefaultValue() {
&nbsp;                        return this.bridgeTarget.getDefaultValue();
&nbsp;                    }
&nbsp;
&nbsp;                    public TypeList.Generic getTypeVariables() {
&nbsp;                        return this.bridgeTarget.getTypeVariables();
&nbsp;                    }
&nbsp;
&nbsp;                    public AnnotationList getDeclaredAnnotations() {
&nbsp;                        return this.bridgeTarget.getDeclaredAnnotations();
&nbsp;                    }
&nbsp;
&nbsp;                    public int getModifiers() {
&nbsp;                        return this.bridgeTarget.getModifiers();
&nbsp;                    }
&nbsp;
&nbsp;                    public String getInternalName() {
&nbsp;                        return this.bridgeTarget.getInternalName();
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                protected static class AccessorBridge extends MethodDescription.InDefinedShape.AbstractBase {
&nbsp;                    private final MethodDescription bridgeTarget;
&nbsp;                    private final MethodDescription.TypeToken bridgeType;
&nbsp;                    private final TypeDescription instrumentedType;
&nbsp;
&nbsp;                    protected AccessorBridge(MethodDescription bridgeTarget, MethodDescription.TypeToken bridgeType, TypeDescription instrumentedType) {
&nbsp;                        this.bridgeTarget = bridgeTarget;
&nbsp;                        this.bridgeType = bridgeType;
&nbsp;                        this.instrumentedType = instrumentedType;
&nbsp;                    }
&nbsp;
&nbsp;                    @Nonnull
&nbsp;                    public TypeDescription getDeclaringType() {
&nbsp;                        return this.instrumentedType;
&nbsp;                    }
&nbsp;
&nbsp;                    public ParameterList&lt;ParameterDescription.InDefinedShape&gt; getParameters() {
&nbsp;                        return new ParameterList.Explicit.ForTypes(this, this.bridgeType.getParameterTypes());
&nbsp;                    }
&nbsp;
&nbsp;                    public TypeDescription.Generic getReturnType() {
&nbsp;                        return this.bridgeType.getReturnType().asGenericType();
&nbsp;                    }
&nbsp;
&nbsp;                    public TypeList.Generic getExceptionTypes() {
&nbsp;                        return this.bridgeTarget.getExceptionTypes().accept(TypeErasing.INSTANCE);
&nbsp;                    }
&nbsp;
&nbsp;                    @Nonnull(
&nbsp;                        when = When.MAYBE
&nbsp;                    )
&nbsp;                    public AnnotationValue&lt;?, ?&gt; getDefaultValue() {
&nbsp;                        return AnnotationValue.UNDEFINED;
&nbsp;                    }
&nbsp;
&nbsp;                    public TypeList.Generic getTypeVariables() {
&nbsp;                        return new TypeList.Generic.Empty();
&nbsp;                    }
&nbsp;
&nbsp;                    public AnnotationList getDeclaredAnnotations() {
&nbsp;                        return new AnnotationList.Empty();
&nbsp;                    }
&nbsp;
&nbsp;                    public int getModifiers() {
&nbsp;                        return (this.bridgeTarget.getModifiers() | 64 | 4096) &amp; -1281;
&nbsp;                    }
&nbsp;
&nbsp;                    public String getInternalName() {
&nbsp;                        return this.bridgeTarget.getInternalName();
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public abstract static class ForDefinedMethod implements Record {
&nbsp;                public ForDefinedMethod() {
&nbsp;                }
&nbsp;
&nbsp;                public void apply(ClassVisitor classVisitor, Implementation.Context implementationContext, AnnotationValueFilter.Factory annotationValueFilterFactory) {
&nbsp;                    MethodVisitor methodVisitor = classVisitor.visitMethod(this.getMethod().getActualModifiers(this.getSort().isImplemented(), this.getVisibility()), this.getMethod().getInternalName(), this.getMethod().getDescriptor(), this.getMethod().getGenericSignature(), this.getMethod().getExceptionTypes().asErasures().toInternalNames());
&nbsp;                    if (methodVisitor != null) {
&nbsp;                        ParameterList&lt;?&gt; parameterList = this.getMethod().getParameters();
&nbsp;                        if (parameterList.hasExplicitMetaData()) {
&nbsp;                            Iterator var6 = parameterList.iterator();
&nbsp;
&nbsp;                            while(var6.hasNext()) {
&nbsp;                                ParameterDescription parameterDescription = (ParameterDescription)var6.next();
&nbsp;                                methodVisitor.visitParameter(parameterDescription.getName(), parameterDescription.getModifiers());
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        this.applyHead(methodVisitor);
&nbsp;                        this.applyBody(methodVisitor, implementationContext, annotationValueFilterFactory);
&nbsp;                        methodVisitor.visitEnd();
&nbsp;                    }
&nbsp;
&nbsp;                }
&nbsp;
&nbsp;                @Enhance
&nbsp;                public static class OfVisibilityBridge extends ForDefinedMethod implements ByteCodeAppender {
&nbsp;                    private final MethodDescription visibilityBridge;
&nbsp;                    private final MethodDescription bridgeTarget;
&nbsp;                    private final TypeDescription bridgeType;
&nbsp;                    private final MethodAttributeAppender attributeAppender;
&nbsp;
&nbsp;                    protected OfVisibilityBridge(MethodDescription visibilityBridge, MethodDescription bridgeTarget, TypeDescription bridgeType, MethodAttributeAppender attributeAppender) {
&nbsp;                        this.visibilityBridge = visibilityBridge;
&nbsp;                        this.bridgeTarget = bridgeTarget;
&nbsp;                        this.bridgeType = bridgeType;
&nbsp;                        this.attributeAppender = attributeAppender;
&nbsp;                    }
&nbsp;
&nbsp;                    public static Record of(TypeDescription instrumentedType, MethodDescription bridgeTarget, MethodAttributeAppender attributeAppender) {
&nbsp;                        TypeDefinition bridgeType = null;
&nbsp;                        if (bridgeTarget.isDefaultMethod()) {
&nbsp;                            TypeDescription declaringType = bridgeTarget.getDeclaringType().asErasure();
&nbsp;                            Iterator var5 = ((TypeList)instrumentedType.getInterfaces().asErasures().filter(ElementMatchers.isSubTypeOf(declaringType))).iterator();
&nbsp;
&nbsp;                            label27:
&nbsp;                            while(true) {
&nbsp;                                TypeDescription interfaceType;
&nbsp;                                do {
&nbsp;                                    if (!var5.hasNext()) {
&nbsp;                                        break label27;
&nbsp;                                    }
&nbsp;
&nbsp;                                    interfaceType = (TypeDescription)var5.next();
&nbsp;                                } while(bridgeType != null &amp;&amp; !declaringType.isAssignableTo(((TypeDefinition)bridgeType).asErasure()));
&nbsp;
&nbsp;                                bridgeType = interfaceType;
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        if (bridgeType == null) {
&nbsp;                            bridgeType = instrumentedType.getSuperClass();
&nbsp;                            if (bridgeType == null) {
&nbsp;                                bridgeType = TypeDescription.OBJECT;
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        return new OfVisibilityBridge(new VisibilityBridge(instrumentedType, bridgeTarget), bridgeTarget, ((TypeDefinition)bridgeType).asErasure(), attributeAppender);
&nbsp;                    }
&nbsp;
&nbsp;                    public MethodDescription getMethod() {
&nbsp;                        return this.visibilityBridge;
&nbsp;                    }
&nbsp;
&nbsp;                    public Sort getSort() {
&nbsp;                        return TypeWriter.MethodPool.Record.Sort.IMPLEMENTED;
&nbsp;                    }
&nbsp;
&nbsp;                    public Visibility getVisibility() {
&nbsp;                        return this.bridgeTarget.getVisibility();
&nbsp;                    }
&nbsp;
&nbsp;                    public Record prepend(ByteCodeAppender byteCodeAppender) {
&nbsp;                        return new WithBody(this.visibilityBridge, new ByteCodeAppender.Compound(new ByteCodeAppender[]{this, byteCodeAppender}), this.attributeAppender, this.bridgeTarget.getVisibility());
&nbsp;                    }
&nbsp;
&nbsp;                    public void applyHead(MethodVisitor methodVisitor) {
&nbsp;                    }
&nbsp;
&nbsp;                    public void applyBody(MethodVisitor methodVisitor, Implementation.Context implementationContext, AnnotationValueFilter.Factory annotationValueFilterFactory) {
&nbsp;                        this.applyAttributes(methodVisitor, annotationValueFilterFactory);
&nbsp;                        methodVisitor.visitCode();
&nbsp;                        ByteCodeAppender.Size size = this.applyCode(methodVisitor, implementationContext);
&nbsp;                        methodVisitor.visitMaxs(size.getOperandStackSize(), size.getLocalVariableSize());
&nbsp;                    }
&nbsp;
&nbsp;                    public void applyAttributes(MethodVisitor methodVisitor, AnnotationValueFilter.Factory annotationValueFilterFactory) {
&nbsp;                        this.attributeAppender.apply(methodVisitor, this.visibilityBridge, annotationValueFilterFactory.on(this.visibilityBridge));
&nbsp;                    }
&nbsp;
&nbsp;                    public ByteCodeAppender.Size applyCode(MethodVisitor methodVisitor, Implementation.Context implementationContext) {
&nbsp;                        return this.apply(methodVisitor, implementationContext, this.visibilityBridge);
&nbsp;                    }
&nbsp;
&nbsp;                    public ByteCodeAppender.Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext, MethodDescription instrumentedMethod) {
&nbsp;                        return (new ByteCodeAppender.Simple(new StackManipulation[]{MethodVariableAccess.allArgumentsOf(instrumentedMethod).prependThisReference(), MethodInvocation.invoke(this.bridgeTarget).special(this.bridgeType), MethodReturn.of(instrumentedMethod.getReturnType())})).apply(methodVisitor, implementationContext, instrumentedMethod);
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(Object var1) {
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else if (!this.visibilityBridge.equals(((OfVisibilityBridge)var1).visibilityBridge)) {
&nbsp;                            return false;
&nbsp;                        } else if (!this.bridgeTarget.equals(((OfVisibilityBridge)var1).bridgeTarget)) {
&nbsp;                            return false;
&nbsp;                        } else if (!this.bridgeType.equals(((OfVisibilityBridge)var1).bridgeType)) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return this.attributeAppender.equals(((OfVisibilityBridge)var1).attributeAppender);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return (((this.getClass().hashCode() * 31 + this.visibilityBridge.hashCode()) * 31 + this.bridgeTarget.hashCode()) * 31 + this.bridgeType.hashCode()) * 31 + this.attributeAppender.hashCode();
&nbsp;                    }
&nbsp;
&nbsp;                    protected static class VisibilityBridge extends MethodDescription.InDefinedShape.AbstractBase {
&nbsp;                        private final TypeDescription instrumentedType;
&nbsp;                        private final MethodDescription bridgeTarget;
&nbsp;
&nbsp;                        protected VisibilityBridge(TypeDescription instrumentedType, MethodDescription bridgeTarget) {
&nbsp;                            this.instrumentedType = instrumentedType;
&nbsp;                            this.bridgeTarget = bridgeTarget;
&nbsp;                        }
&nbsp;
&nbsp;                        @Nonnull
&nbsp;                        public TypeDescription getDeclaringType() {
&nbsp;                            return this.instrumentedType;
&nbsp;                        }
&nbsp;
&nbsp;                        public ParameterList&lt;ParameterDescription.InDefinedShape&gt; getParameters() {
&nbsp;                            return new ParameterList.Explicit.ForTypes(this, this.bridgeTarget.getParameters().asTypeList().asRawTypes());
&nbsp;                        }
&nbsp;
&nbsp;                        public TypeDescription.Generic getReturnType() {
&nbsp;                            return this.bridgeTarget.getReturnType().asRawType();
&nbsp;                        }
&nbsp;
&nbsp;                        public TypeList.Generic getExceptionTypes() {
&nbsp;                            return this.bridgeTarget.getExceptionTypes().asRawTypes();
&nbsp;                        }
&nbsp;
&nbsp;                        @Nonnull(
&nbsp;                            when = When.MAYBE
&nbsp;                        )
&nbsp;                        public AnnotationValue&lt;?, ?&gt; getDefaultValue() {
&nbsp;                            return AnnotationValue.UNDEFINED;
&nbsp;                        }
&nbsp;
&nbsp;                        public TypeList.Generic getTypeVariables() {
&nbsp;                            return new TypeList.Generic.Empty();
&nbsp;                        }
&nbsp;
&nbsp;                        public AnnotationList getDeclaredAnnotations() {
&nbsp;                            return this.bridgeTarget.getDeclaredAnnotations();
&nbsp;                        }
&nbsp;
&nbsp;                        public int getModifiers() {
&nbsp;                            return (this.bridgeTarget.getModifiers() | 4096 | 64) &amp; -257;
&nbsp;                        }
&nbsp;
&nbsp;                        public String getInternalName() {
&nbsp;                            return this.bridgeTarget.getName();
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Enhance
&nbsp;                public static class WithAnnotationDefaultValue extends ForDefinedMethod {
&nbsp;                    private final MethodDescription methodDescription;
&nbsp;                    private final AnnotationValue&lt;?, ?&gt; annotationValue;
&nbsp;                    private final MethodAttributeAppender methodAttributeAppender;
&nbsp;
&nbsp;                    public WithAnnotationDefaultValue(MethodDescription methodDescription, AnnotationValue&lt;?, ?&gt; annotationValue, MethodAttributeAppender methodAttributeAppender) {
&nbsp;                        this.methodDescription = methodDescription;
&nbsp;                        this.annotationValue = annotationValue;
&nbsp;                        this.methodAttributeAppender = methodAttributeAppender;
&nbsp;                    }
&nbsp;
&nbsp;                    public MethodDescription getMethod() {
&nbsp;                        return this.methodDescription;
&nbsp;                    }
&nbsp;
&nbsp;                    public Sort getSort() {
&nbsp;                        return TypeWriter.MethodPool.Record.Sort.DEFINED;
&nbsp;                    }
&nbsp;
&nbsp;                    public Visibility getVisibility() {
&nbsp;                        return this.methodDescription.getVisibility();
&nbsp;                    }
&nbsp;
&nbsp;                    public void applyHead(MethodVisitor methodVisitor) {
&nbsp;                        if (!this.methodDescription.isDefaultValue(this.annotationValue)) {
&nbsp;                            throw new IllegalStateException(&quot;Cannot set &quot; + this.annotationValue + &quot; as default for &quot; + this.methodDescription);
&nbsp;                        } else {
&nbsp;                            AnnotationVisitor annotationVisitor = methodVisitor.visitAnnotationDefault();
&nbsp;                            net.bytebuddy.implementation.attribute.AnnotationAppender.Default.apply(annotationVisitor, this.methodDescription.getReturnType().asErasure(), AnnotationAppender.NO_NAME, this.annotationValue.resolve());
&nbsp;                            annotationVisitor.visitEnd();
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public void applyBody(MethodVisitor methodVisitor, Implementation.Context implementationContext, AnnotationValueFilter.Factory annotationValueFilterFactory) {
&nbsp;                        this.methodAttributeAppender.apply(methodVisitor, this.methodDescription, annotationValueFilterFactory.on(this.methodDescription));
&nbsp;                    }
&nbsp;
&nbsp;                    public void applyAttributes(MethodVisitor methodVisitor, AnnotationValueFilter.Factory annotationValueFilterFactory) {
&nbsp;                        throw new IllegalStateException(&quot;Cannot apply attributes for default value on &quot; + this.methodDescription);
&nbsp;                    }
&nbsp;
&nbsp;                    public ByteCodeAppender.Size applyCode(MethodVisitor methodVisitor, Implementation.Context implementationContext) {
&nbsp;                        throw new IllegalStateException(&quot;Cannot apply code for default value on &quot; + this.methodDescription);
&nbsp;                    }
&nbsp;
&nbsp;                    public Record prepend(ByteCodeAppender byteCodeAppender) {
&nbsp;                        throw new IllegalStateException(&quot;Cannot prepend code for default value on &quot; + this.methodDescription);
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(Object var1) {
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else if (!this.methodDescription.equals(((WithAnnotationDefaultValue)var1).methodDescription)) {
&nbsp;                            return false;
&nbsp;                        } else if (!this.annotationValue.equals(((WithAnnotationDefaultValue)var1).annotationValue)) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return this.methodAttributeAppender.equals(((WithAnnotationDefaultValue)var1).methodAttributeAppender);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return ((this.getClass().hashCode() * 31 + this.methodDescription.hashCode()) * 31 + this.annotationValue.hashCode()) * 31 + this.methodAttributeAppender.hashCode();
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Enhance
&nbsp;                public static class WithoutBody extends ForDefinedMethod {
&nbsp;                    private final MethodDescription methodDescription;
&nbsp;                    private final MethodAttributeAppender methodAttributeAppender;
&nbsp;                    private final Visibility visibility;
&nbsp;
&nbsp;                    public WithoutBody(MethodDescription methodDescription, MethodAttributeAppender methodAttributeAppender, Visibility visibility) {
&nbsp;                        this.methodDescription = methodDescription;
&nbsp;                        this.methodAttributeAppender = methodAttributeAppender;
&nbsp;                        this.visibility = visibility;
&nbsp;                    }
&nbsp;
&nbsp;                    public MethodDescription getMethod() {
&nbsp;                        return this.methodDescription;
&nbsp;                    }
&nbsp;
&nbsp;                    public Sort getSort() {
&nbsp;                        return TypeWriter.MethodPool.Record.Sort.DEFINED;
&nbsp;                    }
&nbsp;
&nbsp;                    public Visibility getVisibility() {
&nbsp;                        return this.visibility;
&nbsp;                    }
&nbsp;
&nbsp;                    public void applyHead(MethodVisitor methodVisitor) {
&nbsp;                    }
&nbsp;
&nbsp;                    public void applyBody(MethodVisitor methodVisitor, Implementation.Context implementationContext, AnnotationValueFilter.Factory annotationValueFilterFactory) {
&nbsp;                        this.applyAttributes(methodVisitor, annotationValueFilterFactory);
&nbsp;                    }
&nbsp;
&nbsp;                    public void applyAttributes(MethodVisitor methodVisitor, AnnotationValueFilter.Factory annotationValueFilterFactory) {
&nbsp;                        this.methodAttributeAppender.apply(methodVisitor, this.methodDescription, annotationValueFilterFactory.on(this.methodDescription));
&nbsp;                    }
&nbsp;
&nbsp;                    public ByteCodeAppender.Size applyCode(MethodVisitor methodVisitor, Implementation.Context implementationContext) {
&nbsp;                        throw new IllegalStateException(&quot;Cannot apply code for abstract method on &quot; + this.methodDescription);
&nbsp;                    }
&nbsp;
&nbsp;                    public Record prepend(ByteCodeAppender byteCodeAppender) {
&nbsp;                        throw new IllegalStateException(&quot;Cannot prepend code for abstract method on &quot; + this.methodDescription);
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(Object var1) {
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else if (!this.visibility.equals(((WithoutBody)var1).visibility)) {
&nbsp;                            return false;
&nbsp;                        } else if (!this.methodDescription.equals(((WithoutBody)var1).methodDescription)) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return this.methodAttributeAppender.equals(((WithoutBody)var1).methodAttributeAppender);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return ((this.getClass().hashCode() * 31 + this.methodDescription.hashCode()) * 31 + this.methodAttributeAppender.hashCode()) * 31 + this.visibility.hashCode();
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Enhance
&nbsp;                public static class WithBody extends ForDefinedMethod {
&nbsp;                    private final MethodDescription methodDescription;
&nbsp;                    private final ByteCodeAppender byteCodeAppender;
&nbsp;                    private final MethodAttributeAppender methodAttributeAppender;
&nbsp;                    private final Visibility visibility;
&nbsp;
&nbsp;                    public WithBody(MethodDescription methodDescription, ByteCodeAppender byteCodeAppender) {
&nbsp;                        this(methodDescription, byteCodeAppender, net.bytebuddy.implementation.attribute.MethodAttributeAppender.NoOp.INSTANCE, methodDescription.getVisibility());
&nbsp;                    }
&nbsp;
&nbsp;                    public WithBody(MethodDescription methodDescription, ByteCodeAppender byteCodeAppender, MethodAttributeAppender methodAttributeAppender, Visibility visibility) {
&nbsp;                        this.methodDescription = methodDescription;
&nbsp;                        this.byteCodeAppender = byteCodeAppender;
&nbsp;                        this.methodAttributeAppender = methodAttributeAppender;
&nbsp;                        this.visibility = visibility;
&nbsp;                    }
&nbsp;
&nbsp;                    public MethodDescription getMethod() {
&nbsp;                        return this.methodDescription;
&nbsp;                    }
&nbsp;
&nbsp;                    public Sort getSort() {
&nbsp;                        return TypeWriter.MethodPool.Record.Sort.IMPLEMENTED;
&nbsp;                    }
&nbsp;
&nbsp;                    public Visibility getVisibility() {
&nbsp;                        return this.visibility;
&nbsp;                    }
&nbsp;
&nbsp;                    public void applyHead(MethodVisitor methodVisitor) {
&nbsp;                    }
&nbsp;
&nbsp;                    public void applyBody(MethodVisitor methodVisitor, Implementation.Context implementationContext, AnnotationValueFilter.Factory annotationValueFilterFactory) {
&nbsp;                        this.applyAttributes(methodVisitor, annotationValueFilterFactory);
&nbsp;                        methodVisitor.visitCode();
&nbsp;                        ByteCodeAppender.Size size = this.applyCode(methodVisitor, implementationContext);
&nbsp;                        methodVisitor.visitMaxs(size.getOperandStackSize(), size.getLocalVariableSize());
&nbsp;                    }
&nbsp;
&nbsp;                    public void applyAttributes(MethodVisitor methodVisitor, AnnotationValueFilter.Factory annotationValueFilterFactory) {
&nbsp;                        this.methodAttributeAppender.apply(methodVisitor, this.methodDescription, annotationValueFilterFactory.on(this.methodDescription));
&nbsp;                    }
&nbsp;
&nbsp;                    public ByteCodeAppender.Size applyCode(MethodVisitor methodVisitor, Implementation.Context implementationContext) {
&nbsp;                        return this.byteCodeAppender.apply(methodVisitor, implementationContext, this.methodDescription);
&nbsp;                    }
&nbsp;
&nbsp;                    public Record prepend(ByteCodeAppender byteCodeAppender) {
&nbsp;                        return new WithBody(this.methodDescription, new ByteCodeAppender.Compound(new ByteCodeAppender[]{byteCodeAppender, this.byteCodeAppender}), this.methodAttributeAppender, this.visibility);
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(Object var1) {
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else if (!this.visibility.equals(((WithBody)var1).visibility)) {
&nbsp;                            return false;
&nbsp;                        } else if (!this.methodDescription.equals(((WithBody)var1).methodDescription)) {
&nbsp;                            return false;
&nbsp;                        } else if (!this.byteCodeAppender.equals(((WithBody)var1).byteCodeAppender)) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return this.methodAttributeAppender.equals(((WithBody)var1).methodAttributeAppender);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return (((this.getClass().hashCode() * 31 + this.methodDescription.hashCode()) * 31 + this.byteCodeAppender.hashCode()) * 31 + this.methodAttributeAppender.hashCode()) * 31 + this.visibility.hashCode();
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Enhance
&nbsp;            public static class ForNonImplementedMethod implements Record {
&nbsp;                private final MethodDescription methodDescription;
&nbsp;
&nbsp;                public ForNonImplementedMethod(MethodDescription methodDescription) {
&nbsp;                    this.methodDescription = methodDescription;
&nbsp;                }
&nbsp;
&nbsp;                public void apply(ClassVisitor classVisitor, Implementation.Context implementationContext, AnnotationValueFilter.Factory annotationValueFilterFactory) {
&nbsp;                }
&nbsp;
&nbsp;                public void applyBody(MethodVisitor methodVisitor, Implementation.Context implementationContext, AnnotationValueFilter.Factory annotationValueFilterFactory) {
&nbsp;                    throw new IllegalStateException(&quot;Cannot apply body for non-implemented method on &quot; + this.methodDescription);
&nbsp;                }
&nbsp;
&nbsp;                public void applyAttributes(MethodVisitor methodVisitor, AnnotationValueFilter.Factory annotationValueFilterFactory) {
&nbsp;                }
&nbsp;
&nbsp;                public ByteCodeAppender.Size applyCode(MethodVisitor methodVisitor, Implementation.Context implementationContext) {
&nbsp;                    throw new IllegalStateException(&quot;Cannot apply code for non-implemented method on &quot; + this.methodDescription);
&nbsp;                }
&nbsp;
&nbsp;                public void applyHead(MethodVisitor methodVisitor) {
&nbsp;                    throw new IllegalStateException(&quot;Cannot apply head for non-implemented method on &quot; + this.methodDescription);
&nbsp;                }
&nbsp;
&nbsp;                public MethodDescription getMethod() {
&nbsp;                    return this.methodDescription;
&nbsp;                }
&nbsp;
&nbsp;                public Visibility getVisibility() {
&nbsp;                    return this.methodDescription.getVisibility();
&nbsp;                }
&nbsp;
&nbsp;                public Sort getSort() {
&nbsp;                    return TypeWriter.MethodPool.Record.Sort.SKIPPED;
&nbsp;                }
&nbsp;
&nbsp;                public Record prepend(ByteCodeAppender byteCodeAppender) {
&nbsp;                    return new ForDefinedMethod.WithBody(this.methodDescription, new ByteCodeAppender.Compound(new ByteCodeAppender[]{byteCodeAppender, new ByteCodeAppender.Simple(new StackManipulation[]{DefaultValue.of(this.methodDescription.getReturnType()), MethodReturn.of(this.methodDescription.getReturnType())})}));
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(Object var1) {
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.methodDescription.equals(((ForNonImplementedMethod)var1).methodDescription);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return this.getClass().hashCode() * 31 + this.methodDescription.hashCode();
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public static enum Sort {
&nbsp;                SKIPPED(false, false),
&nbsp;                DEFINED(true, false),
&nbsp;                IMPLEMENTED(true, true);
&nbsp;
&nbsp;                private final boolean define;
&nbsp;                private final boolean implement;
&nbsp;
&nbsp;                private Sort(boolean define, boolean implement) {
&nbsp;                    this.define = define;
&nbsp;                    this.implement = implement;
&nbsp;                }
&nbsp;
&nbsp;                public boolean isDefined() {
&nbsp;                    return this.define;
&nbsp;                }
&nbsp;
&nbsp;                public boolean isImplemented() {
&nbsp;                    return this.implement;
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public interface FieldPool {
&nbsp;        Record target(FieldDescription var1);
&nbsp;
&nbsp;        public static enum Disabled implements FieldPool {
&nbsp;            INSTANCE;
&nbsp;
&nbsp;            private Disabled() {
&nbsp;            }
&nbsp;
&nbsp;            public Record target(FieldDescription fieldDescription) {
&nbsp;                throw new IllegalStateException(&quot;Cannot look up field from disabled pool&quot;);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public interface Record {
&nbsp;            boolean isImplicit();
&nbsp;
&nbsp;            FieldDescription getField();
&nbsp;
&nbsp;            FieldAttributeAppender getFieldAppender();
&nbsp;
&nbsp;            @Nonnull(
&nbsp;                when = When.MAYBE
&nbsp;            )
&nbsp;            Object resolveDefault(@Nonnull(when = When.MAYBE) Object var1);
&nbsp;
&nbsp;            void apply(ClassVisitor var1, AnnotationValueFilter.Factory var2);
&nbsp;
&nbsp;            void apply(FieldVisitor var1, AnnotationValueFilter.Factory var2);
&nbsp;
&nbsp;            @Enhance
&nbsp;            public static class ForExplicitField implements Record {
&nbsp;                private final FieldAttributeAppender attributeAppender;
&nbsp;                @Nonnull(
&nbsp;                    when = When.MAYBE
&nbsp;                )
&nbsp;                @ValueHandling(net.bytebuddy.build.HashCodeAndEqualsPlugin.ValueHandling.Sort.REVERSE_NULLABILITY)
&nbsp;                private final Object defaultValue;
&nbsp;                private final FieldDescription fieldDescription;
&nbsp;
&nbsp;                public ForExplicitField(FieldAttributeAppender attributeAppender, @Nonnull(when = When.MAYBE) Object defaultValue, FieldDescription fieldDescription) {
&nbsp;                    this.attributeAppender = attributeAppender;
&nbsp;                    this.defaultValue = defaultValue;
&nbsp;                    this.fieldDescription = fieldDescription;
&nbsp;                }
&nbsp;
&nbsp;                public boolean isImplicit() {
&nbsp;                    return false;
&nbsp;                }
&nbsp;
&nbsp;                public FieldDescription getField() {
&nbsp;                    return this.fieldDescription;
&nbsp;                }
&nbsp;
&nbsp;                public FieldAttributeAppender getFieldAppender() {
&nbsp;                    return this.attributeAppender;
&nbsp;                }
&nbsp;
&nbsp;                @Nonnull(
&nbsp;                    when = When.MAYBE
&nbsp;                )
&nbsp;                public Object resolveDefault(@Nonnull(when = When.MAYBE) Object defaultValue) {
&nbsp;                    return this.defaultValue == null ? defaultValue : this.defaultValue;
&nbsp;                }
&nbsp;
&nbsp;                public void apply(ClassVisitor classVisitor, AnnotationValueFilter.Factory annotationValueFilterFactory) {
&nbsp;                    FieldVisitor fieldVisitor = classVisitor.visitField(this.fieldDescription.getActualModifiers(), this.fieldDescription.getInternalName(), this.fieldDescription.getDescriptor(), this.fieldDescription.getGenericSignature(), this.resolveDefault(FieldDescription.NO_DEFAULT_VALUE));
&nbsp;                    if (fieldVisitor != null) {
&nbsp;                        this.attributeAppender.apply(fieldVisitor, this.fieldDescription, annotationValueFilterFactory.on(this.fieldDescription));
&nbsp;                        fieldVisitor.visitEnd();
&nbsp;                    }
&nbsp;
&nbsp;                }
&nbsp;
&nbsp;                public void apply(FieldVisitor fieldVisitor, AnnotationValueFilter.Factory annotationValueFilterFactory) {
&nbsp;                    this.attributeAppender.apply(fieldVisitor, this.fieldDescription, annotationValueFilterFactory.on(this.fieldDescription));
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(Object var1) {
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.attributeAppender.equals(((ForExplicitField)var1).attributeAppender)) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        Object var2 = ((ForExplicitField)var1).defaultValue;
&nbsp;                        Object var3 = this.defaultValue;
&nbsp;                        if (var2 != null) {
&nbsp;                            if (var3 != null) {
&nbsp;                                if (!var3.equals(var2)) {
&nbsp;                                    return false;
&nbsp;                                }
&nbsp;
&nbsp;                                return this.fieldDescription.equals(((ForExplicitField)var1).fieldDescription);
&nbsp;                            }
&nbsp;                        } else if (var3 == null) {
&nbsp;                            return this.fieldDescription.equals(((ForExplicitField)var1).fieldDescription);
&nbsp;                        }
&nbsp;
&nbsp;                        return false;
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    int var10000 = (this.getClass().hashCode() * 31 + this.attributeAppender.hashCode()) * 31;
&nbsp;                    Object var1 = this.defaultValue;
&nbsp;                    if (var1 != null) {
&nbsp;                        var10000 += var1.hashCode();
&nbsp;                    }
&nbsp;
&nbsp;                    return var10000 * 31 + this.fieldDescription.hashCode();
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Enhance
&nbsp;            public static class ForImplicitField implements Record {
&nbsp;                private final FieldDescription fieldDescription;
&nbsp;
&nbsp;                public ForImplicitField(FieldDescription fieldDescription) {
&nbsp;                    this.fieldDescription = fieldDescription;
&nbsp;                }
&nbsp;
&nbsp;                public boolean isImplicit() {
&nbsp;                    return true;
&nbsp;                }
&nbsp;
&nbsp;                public FieldDescription getField() {
&nbsp;                    return this.fieldDescription;
&nbsp;                }
&nbsp;
&nbsp;                public FieldAttributeAppender getFieldAppender() {
&nbsp;                    throw new IllegalStateException(&quot;An implicit field record does not expose a field appender: &quot; + this);
&nbsp;                }
&nbsp;
&nbsp;                public Object resolveDefault(@Nonnull(when = When.MAYBE) Object defaultValue) {
&nbsp;                    throw new IllegalStateException(&quot;An implicit field record does not expose a default value: &quot; + this);
&nbsp;                }
&nbsp;
&nbsp;                public void apply(ClassVisitor classVisitor, AnnotationValueFilter.Factory annotationValueFilterFactory) {
&nbsp;                    FieldVisitor fieldVisitor = classVisitor.visitField(this.fieldDescription.getActualModifiers(), this.fieldDescription.getInternalName(), this.fieldDescription.getDescriptor(), this.fieldDescription.getGenericSignature(), FieldDescription.NO_DEFAULT_VALUE);
&nbsp;                    if (fieldVisitor != null) {
&nbsp;                        ForInstrumentedField.INSTANCE.apply(fieldVisitor, this.fieldDescription, annotationValueFilterFactory.on(this.fieldDescription));
&nbsp;                        fieldVisitor.visitEnd();
&nbsp;                    }
&nbsp;
&nbsp;                }
&nbsp;
&nbsp;                public void apply(FieldVisitor fieldVisitor, AnnotationValueFilter.Factory annotationValueFilterFactory) {
&nbsp;                    throw new IllegalStateException(&quot;An implicit field record is not intended for partial application: &quot; + this);
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(Object var1) {
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.fieldDescription.equals(((ForImplicitField)var1).fieldDescription);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return this.getClass().hashCode() * 31 + this.fieldDescription.hashCode();
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-22 12:48</div>
</div>
</body>
</html>
