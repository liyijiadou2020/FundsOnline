


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=GBK"> 
  <title>Coverage Report > JavaDispatcher</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.utility.dispatcher</a>
</div>

<h1>Coverage Summary for Class: JavaDispatcher (net.bytebuddy.utility.dispatcher)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">JavaDispatcher</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (72/72)
  </span>
</td>
</tr>
  <tr>
    <td class="name">JavaDispatcher$Dispatcher$ForDefaultValue</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (38/38)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JavaDispatcher$Dispatcher$ForDefaultValue$OfNonPrimitiveArray</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JavaDispatcher$Dispatcher$ForInstanceCheck</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JavaDispatcher$Dispatcher$ForNonStaticMethod</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JavaDispatcher$Dispatcher$ForStaticMethod</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JavaDispatcher$Dispatcher$ForUnresolvedMethod</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JavaDispatcher$DynamicClassLoader</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (50/50)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JavaDispatcher$DynamicClassLoader$Resolver$CreationAction</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JavaDispatcher$DynamicClassLoader$Resolver$NoOp</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JavaDispatcher$InvokerCreationAction</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JavaDispatcher$ProxiedInvocationHandler</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (8/8)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (15/15)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (196/196)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;//
&nbsp;// Source code recreated from a .class file by IntelliJ IDEA
&nbsp;// (powered by FernFlower decompiler)
&nbsp;//
&nbsp;
&nbsp;package net.bytebuddy.utility.dispatcher;
&nbsp;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import java.lang.annotation.Annotation;
&nbsp;import java.lang.annotation.Documented;
&nbsp;import java.lang.annotation.ElementType;
&nbsp;import java.lang.annotation.Retention;
&nbsp;import java.lang.annotation.RetentionPolicy;
&nbsp;import java.lang.annotation.Target;
&nbsp;import java.lang.reflect.Array;
&nbsp;import java.lang.reflect.Constructor;
&nbsp;import java.lang.reflect.InvocationHandler;
&nbsp;import java.lang.reflect.InvocationTargetException;
&nbsp;import java.lang.reflect.Method;
&nbsp;import java.lang.reflect.Modifier;
&nbsp;import java.lang.reflect.Proxy;
&nbsp;import java.security.AccessController;
&nbsp;import java.security.Permission;
&nbsp;import java.security.PrivilegedAction;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.Iterator;
&nbsp;import java.util.Map;
&nbsp;import javax.annotation.Nonnull;
&nbsp;import javax.annotation.meta.When;
&nbsp;import net.bytebuddy.ClassFileVersion;
&nbsp;import net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance;
&nbsp;import net.bytebuddy.build.HashCodeAndEqualsPlugin.ValueHandling;
&nbsp;import net.bytebuddy.build.HashCodeAndEqualsPlugin.ValueHandling.Sort;
&nbsp;import net.bytebuddy.jar.asm.ClassWriter;
&nbsp;import net.bytebuddy.jar.asm.MethodVisitor;
&nbsp;import net.bytebuddy.jar.asm.Type;
&nbsp;import net.bytebuddy.utility.Invoker;
&nbsp;import net.bytebuddy.utility.privilege.GetSystemPropertyAction;
&nbsp;
&nbsp;@Enhance
&nbsp;public class JavaDispatcher&lt;T&gt; implements PrivilegedAction&lt;T&gt; {
&nbsp;    public static final String GENERATE_PROPERTY = &quot;net.bytebuddy.generate&quot;;
&nbsp;    private static final boolean GENERATE;
&nbsp;    private static final DynamicClassLoader.Resolver RESOLVER;
&nbsp;    private static final Invoker INVOKER;
&nbsp;    private final Class&lt;T&gt; proxy;
&nbsp;    @Nonnull(
&nbsp;        when = When.MAYBE
&nbsp;    )
&nbsp;    @ValueHandling(Sort.REVERSE_NULLABILITY)
&nbsp;    private final ClassLoader classLoader;
&nbsp;    private final boolean generate;
&nbsp;    private static final boolean ACCESS_CONTROLLER;
&nbsp;
&nbsp;    protected JavaDispatcher(Class&lt;T&gt; proxy, @Nonnull(when = When.MAYBE) ClassLoader classLoader, boolean generate) {
&nbsp;        this.proxy = proxy;
<b class="fc">&nbsp;        this.classLoader = classLoader;</b>
&nbsp;        this.generate = generate;
&nbsp;    }
&nbsp;
&nbsp;    @net.bytebuddy.build.AccessControllerPlugin.Enhance
&nbsp;    private static &lt;T&gt; T doPrivileged(PrivilegedAction&lt;T&gt; action) {
&nbsp;        return ACCESS_CONTROLLER ? AccessController.doPrivileged(action) : action.run();
&nbsp;    }
&nbsp;
&nbsp;    public static &lt;T&gt; PrivilegedAction&lt;T&gt; of(Class&lt;T&gt; type) {
<b class="fc">&nbsp;        return of(type, (ClassLoader)null);</b>
&nbsp;    }
&nbsp;
&nbsp;    protected static &lt;T&gt; PrivilegedAction&lt;T&gt; of(Class&lt;T&gt; type, @Nonnull(when = When.MAYBE) ClassLoader classLoader) {
&nbsp;        return of(type, classLoader, GENERATE);
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    protected static &lt;T&gt; PrivilegedAction&lt;T&gt; of(Class&lt;T&gt; type, @Nonnull(when = When.MAYBE) ClassLoader classLoader, boolean generate) {</b>
&nbsp;        if (!type.isInterface()) {
&nbsp;            throw new IllegalArgumentException(&quot;Expected an interface instead of &quot; + type);
&nbsp;        } else if (!type.isAnnotationPresent(Proxied.class)) {
&nbsp;            throw new IllegalArgumentException(&quot;Expected &quot; + type.getName() + &quot; to be annotated with &quot; + Proxied.class.getName());
&nbsp;        } else if (((Proxied)type.getAnnotation(Proxied.class)).value().startsWith(&quot;java.security.&quot;)) {
<b class="fc">&nbsp;            throw new IllegalArgumentException(&quot;Classes related to Java security cannot be proxied: &quot; + type.getName());</b>
&nbsp;        } else {
&nbsp;            return new JavaDispatcher(type, classLoader, generate);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public T run() {
&nbsp;        try {
&nbsp;            Object securityManager = System.class.getMethod(&quot;getSecurityManager&quot;).invoke((Object)null);
&nbsp;            if (securityManager != null) {
&nbsp;                Class.forName(&quot;java.lang.SecurityManager&quot;).getMethod(&quot;checkPermission&quot;, Permission.class).invoke(securityManager, new RuntimePermission(&quot;net.bytebuddy.createJavaDispatcher&quot;));
&nbsp;            }
&nbsp;        } catch (NoSuchMethodException var24) {
&nbsp;        } catch (ClassNotFoundException var25) {
&nbsp;        } catch (InvocationTargetException var26) {
&nbsp;            Throwable cause = var26.getTargetException();
&nbsp;            if (cause instanceof RuntimeException) {
&nbsp;                throw (RuntimeException)cause;
&nbsp;            }
&nbsp;
&nbsp;            throw new IllegalStateException(&quot;Failed to assert access rights using security manager&quot;, cause);
&nbsp;        } catch (IllegalAccessException var27) {
&nbsp;            throw new IllegalStateException(&quot;Failed to access security manager&quot;, var27);
&nbsp;        }
&nbsp;
&nbsp;        Map&lt;Method, Dispatcher&gt; dispatchers = new HashMap();
<b class="fc">&nbsp;        boolean defaults = this.proxy.isAnnotationPresent(Defaults.class);</b>
<b class="fc">&nbsp;        String name = ((Proxied)this.proxy.getAnnotation(Proxied.class)).value();</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;        Class target;</b>
&nbsp;        Method[] var6;
&nbsp;        int var7;
&nbsp;        int var8;
&nbsp;        Method method;
&nbsp;        try {
&nbsp;            target = Class.forName(name, false, this.classLoader);
&nbsp;        } catch (ClassNotFoundException var23) {
&nbsp;            ClassNotFoundException exception = var23;
&nbsp;            var6 = this.proxy.getMethods();
&nbsp;            var7 = var6.length;
&nbsp;
&nbsp;            for(var8 = 0; var8 &lt; var7; ++var8) {
&nbsp;                method = var6[var8];
&nbsp;                if (method.getDeclaringClass() != Object.class) {
&nbsp;                    if (method.isAnnotationPresent(Instance.class)) {
&nbsp;                        if (method.getParameterTypes().length != 1 || method.getParameterTypes()[0].isPrimitive() || method.getParameterTypes()[0].isArray()) {
&nbsp;                            throw new IllegalStateException(&quot;Instance check requires a single regular-typed argument: &quot; + method);
&nbsp;                        }
&nbsp;
&nbsp;                        if (method.getReturnType() != Boolean.TYPE) {
&nbsp;                            throw new IllegalStateException(&quot;Instance check requires a boolean return type: &quot; + method);
&nbsp;                        }
<b class="fc">&nbsp;</b>
&nbsp;                        dispatchers.put(method, JavaDispatcher.Dispatcher.ForDefaultValue.BOOLEAN);
&nbsp;                    } else {
&nbsp;                        dispatchers.put(method, !defaults &amp;&amp; !method.isAnnotationPresent(Defaults.class) ? new Dispatcher.ForUnresolvedMethod(&quot;Type not available on current VM: &quot; + exception.getMessage()) : JavaDispatcher.Dispatcher.ForDefaultValue.of(method.getReturnType()));
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            if (this.generate) {
&nbsp;                return JavaDispatcher.DynamicClassLoader.proxy(this.proxy, dispatchers);
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            return Proxy.newProxyInstance(this.proxy.getClassLoader(), new Class[]{this.proxy}, new ProxiedInvocationHandler(name, dispatchers));</b>
&nbsp;        }
&nbsp;
&nbsp;        boolean generate = this.generate;
&nbsp;        var6 = this.proxy.getMethods();
&nbsp;        var7 = var6.length;
&nbsp;
&nbsp;        for(var8 = 0; var8 &lt; var7; ++var8) {
&nbsp;            method = var6[var8];
&nbsp;            if (method.getDeclaringClass() != Object.class) {
&nbsp;                if (method.isAnnotationPresent(Instance.class)) {
&nbsp;                    if (method.getParameterTypes().length != 1 || !method.getParameterTypes()[0].isAssignableFrom(target)) {
&nbsp;                        throw new IllegalStateException(&quot;Instance check requires a single regular-typed argument: &quot; + method);
<b class="fc">&nbsp;                    }</b>
&nbsp;
<b class="fc">&nbsp;                    if (method.getReturnType() != Boolean.TYPE) {</b>
&nbsp;                        throw new IllegalStateException(&quot;Instance check requires a boolean return type: &quot; + method);
<b class="fc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    dispatchers.put(method, new Dispatcher.ForInstanceCheck(target));
<b class="fc">&nbsp;                } else if (method.isAnnotationPresent(Container.class)) {</b>
&nbsp;                    if (method.getParameterTypes().length != 1 || method.getParameterTypes()[0] != Integer.TYPE) {
&nbsp;                        throw new IllegalStateException(&quot;Container creation requires a single int-typed argument: &quot; + method);
&nbsp;                    }
&nbsp;
&nbsp;                    if (!method.getReturnType().isArray() || !method.getReturnType().getComponentType().isAssignableFrom(target)) {
&nbsp;                        throw new IllegalStateException(&quot;Container creation requires an assignable array as return value: &quot; + method);
&nbsp;                    }
&nbsp;
&nbsp;                    dispatchers.put(method, new Dispatcher.ForContainerCreation(target));
<b class="fc">&nbsp;                } else {</b>
<b class="fc">&nbsp;                    if (target.getName().equals(&quot;java.lang.invoke.MethodHandles&quot;) &amp;&amp; method.getName().equals(&quot;lookup&quot;)) {</b>
&nbsp;                        throw new UnsupportedOperationException(&quot;Cannot resolve Byte Buddy lookup via dispatcher&quot;);
&nbsp;                    }
&nbsp;
&nbsp;                    try {
&nbsp;                        Class&lt;?&gt;[] parameterType = method.getParameterTypes();
&nbsp;                        byte offset;
&nbsp;                        if (!method.isAnnotationPresent(IsStatic.class) &amp;&amp; !method.isAnnotationPresent(IsConstructor.class)) {
&nbsp;                            offset = 1;
&nbsp;                            if (parameterType.length == 0) {
&nbsp;                                throw new IllegalStateException(&quot;Expected self type: &quot; + method);
&nbsp;                            }
&nbsp;
&nbsp;                            if (!parameterType[0].isAssignableFrom(target)) {
&nbsp;                                throw new IllegalStateException(&quot;Cannot assign self type: &quot; + target + &quot; on &quot; + method);
&nbsp;                            }
&nbsp;
&nbsp;                            Class&lt;?&gt;[] adjusted = new Class[parameterType.length - 1];
<b class="fc">&nbsp;                            System.arraycopy(parameterType, 1, adjusted, 0, adjusted.length);</b>
<b class="fc">&nbsp;                            parameterType = adjusted;</b>
<b class="fc">&nbsp;                        } else {</b>
<b class="fc">&nbsp;                            offset = 0;</b>
&nbsp;                        }
&nbsp;
<b class="fc">&nbsp;                        Annotation[][] parameterAnnotation = method.getParameterAnnotations();</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                        int var16;</b>
<b class="fc">&nbsp;                        for(int index = 0; index &lt; parameterType.length; ++index) {</b>
&nbsp;                            Annotation[] var14 = parameterAnnotation[index + offset];
&nbsp;                            int var15 = var14.length;
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                            for(var16 = 0; var16 &lt; var15; ++var16) {</b>
&nbsp;                                Annotation annotation = var14[var16];
<b class="fc">&nbsp;                                if (annotation instanceof Proxied) {</b>
&nbsp;                                    int arity;
&nbsp;                                    for(arity = 0; parameterType[index].isArray(); parameterType[index] = parameterType[index].getComponentType()) {
<b class="fc">&nbsp;                                        ++arity;</b>
&nbsp;                                    }
&nbsp;
<b class="fc">&nbsp;                                    if (arity &lt;= 0) {</b>
&nbsp;                                        Class&lt;?&gt; resolved = Class.forName(((Proxied)annotation).value(), false, this.classLoader);
<b class="fc">&nbsp;                                        if (!parameterType[index].isAssignableFrom(resolved)) {</b>
&nbsp;                                            throw new IllegalStateException(&quot;Cannot resolve to type: &quot; + resolved.getName() + &quot; at &quot; + index + &quot; of &quot; + method);
&nbsp;                                        }
<b class="fc">&nbsp;</b>
&nbsp;                                        parameterType[index] = resolved;
&nbsp;                                        break;
<b class="fc">&nbsp;                                    }</b>
&nbsp;
&nbsp;                                    if (parameterType[index].isPrimitive()) {
&nbsp;                                        throw new IllegalStateException(&quot;Primitive values are not supposed to be proxied: &quot; + index + &quot; of &quot; + method);
<b class="fc">&nbsp;                                    }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                                    if (!parameterType[index].isAssignableFrom(Class.forName(((Proxied)annotation).value(), false, this.classLoader))) {</b>
<b class="fc">&nbsp;                                        throw new IllegalStateException(&quot;Cannot resolve to component type: &quot; + ((Proxied)annotation).value() + &quot; at &quot; + index + &quot; of &quot; + method);</b>
&nbsp;                                    }
&nbsp;
<b class="fc">&nbsp;                                    StringBuilder stringBuilder = new StringBuilder();</b>
<b class="fc">&nbsp;</b>
&nbsp;                                    while(arity-- &gt; 0) {
<b class="fc">&nbsp;                                        stringBuilder.append(&#39;[&#39;);</b>
&nbsp;                                    }
&nbsp;
<b class="fc">&nbsp;                                    parameterType[index] = Class.forName(stringBuilder.append(&#39;L&#39;).append(((Proxied)annotation).value()).append(&#39;;&#39;).toString(), false, this.classLoader);</b>
&nbsp;                                    break;
<b class="fc">&nbsp;                                }</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        if (method.isAnnotationPresent(IsConstructor.class)) {
&nbsp;                            Constructor&lt;?&gt; resolved = target.getConstructor(parameterType);
&nbsp;                            if (!method.getReturnType().isAssignableFrom(target)) {
&nbsp;                                throw new IllegalStateException(&quot;Cannot assign &quot; + resolved.getDeclaringClass().getName() + &quot; to &quot; + method);
<b class="fc">&nbsp;                            }</b>
&nbsp;
&nbsp;                            if ((resolved.getModifiers() &amp; 1) == 0 || (target.getModifiers() &amp; 1) == 0) {
&nbsp;                                resolved.setAccessible(true);
<b class="fc">&nbsp;                                generate = false;</b>
&nbsp;                            }
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                            dispatchers.put(method, new Dispatcher.ForConstructor(resolved));</b>
&nbsp;                        } else {
<b class="fc">&nbsp;                            Proxied proxied = (Proxied)method.getAnnotation(Proxied.class);</b>
<b class="fc">&nbsp;                            Method resolved = target.getMethod(proxied == null ? method.getName() : proxied.value(), parameterType);</b>
&nbsp;                            if (!method.getReturnType().isAssignableFrom(resolved.getReturnType())) {
<b class="fc">&nbsp;                                throw new IllegalStateException(&quot;Cannot assign &quot; + resolved.getReturnType().getName() + &quot; to &quot; + method);</b>
&nbsp;                            }
&nbsp;
<b class="fc">&nbsp;                            Class[] var38 = resolved.getExceptionTypes();</b>
<b class="fc">&nbsp;                            var16 = var38.length;</b>
<b class="fc">&nbsp;</b>
&nbsp;                            label239:
<b class="fc">&nbsp;                            for(int var39 = 0; var39 &lt; var16; ++var39) {</b>
<b class="fc">&nbsp;                                Class&lt;?&gt; type = var38[var39];</b>
<b class="fc">&nbsp;                                if (!RuntimeException.class.isAssignableFrom(type) &amp;&amp; !Error.class.isAssignableFrom(type)) {</b>
&nbsp;                                    Class[] var42 = method.getExceptionTypes();
&nbsp;                                    int var20 = var42.length;
&nbsp;
&nbsp;                                    for(int var21 = 0; var21 &lt; var20; ++var21) {
&nbsp;                                        Class&lt;?&gt; exception = var42[var21];
&nbsp;                                        if (exception.isAssignableFrom(type)) {
&nbsp;                                            continue label239;
&nbsp;                                        }
&nbsp;                                    }
&nbsp;
&nbsp;                                    throw new IllegalStateException(&quot;Resolved method for &quot; + method + &quot; throws undeclared checked exception &quot; + type.getName());
&nbsp;                                }
&nbsp;                            }
&nbsp;
&nbsp;                            if ((resolved.getModifiers() &amp; 1) == 0 || (resolved.getDeclaringClass().getModifiers() &amp; 1) == 0) {
&nbsp;                                resolved.setAccessible(true);
&nbsp;                                generate = false;
&nbsp;                            }
&nbsp;
&nbsp;                            if (Modifier.isStatic(resolved.getModifiers())) {
&nbsp;                                if (!method.isAnnotationPresent(IsStatic.class)) {
&nbsp;                                    throw new IllegalStateException(&quot;Resolved method for &quot; + method + &quot; was expected to be static: &quot; + resolved);
&nbsp;                                }
&nbsp;
&nbsp;                                dispatchers.put(method, new Dispatcher.ForStaticMethod(resolved));
&nbsp;                            } else {
&nbsp;                                if (method.isAnnotationPresent(IsStatic.class)) {
&nbsp;                                    throw new IllegalStateException(&quot;Resolved method for &quot; + method + &quot; was expected to be virtual: &quot; + resolved);
&nbsp;                                }
&nbsp;
&nbsp;                                dispatchers.put(method, new Dispatcher.ForNonStaticMethod(resolved));
<b class="fc">&nbsp;                            }</b>
&nbsp;                        }
&nbsp;                    } catch (ClassNotFoundException var28) {
&nbsp;                        dispatchers.put(method, !defaults &amp;&amp; !method.isAnnotationPresent(Defaults.class) ? new Dispatcher.ForUnresolvedMethod(&quot;Class not available on current VM: &quot; + var28.getMessage()) : JavaDispatcher.Dispatcher.ForDefaultValue.of(method.getReturnType()));
&nbsp;                    } catch (NoSuchMethodException var29) {
&nbsp;                        dispatchers.put(method, !defaults &amp;&amp; !method.isAnnotationPresent(Defaults.class) ? new Dispatcher.ForUnresolvedMethod(&quot;Method not available on current VM: &quot; + var29.getMessage()) : JavaDispatcher.Dispatcher.ForDefaultValue.of(method.getReturnType()));
&nbsp;                    } catch (Throwable var30) {
&nbsp;                        dispatchers.put(method, new Dispatcher.ForUnresolvedMethod(&quot;Unexpected error: &quot; + var30.getMessage()));
&nbsp;                    }
&nbsp;                }
&nbsp;            }
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;        if (generate) {</b>
&nbsp;            return JavaDispatcher.DynamicClassLoader.proxy(this.proxy, dispatchers);
&nbsp;        } else {
&nbsp;            return Proxy.newProxyInstance(this.proxy.getClassLoader(), new Class[]{this.proxy}, new ProxiedInvocationHandler(target.getName(), dispatchers));
<b class="fc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    static {
&nbsp;        try {
&nbsp;            Class.forName(&quot;java.security.AccessController&quot;, false, (ClassLoader)null);
&nbsp;            ACCESS_CONTROLLER = Boolean.parseBoolean(System.getProperty(&quot;net.bytebuddy.securitymanager&quot;, &quot;true&quot;));
&nbsp;        } catch (ClassNotFoundException var0) {
&nbsp;            ACCESS_CONTROLLER = false;
&nbsp;        } catch (SecurityException var1) {
&nbsp;            ACCESS_CONTROLLER = true;
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        GENERATE = Boolean.parseBoolean((String)doPrivileged(new GetSystemPropertyAction(&quot;net.bytebuddy.generate&quot;)));
&nbsp;        RESOLVER = (DynamicClassLoader.Resolver)doPrivileged(JavaDispatcher.DynamicClassLoader.Resolver.CreationAction.INSTANCE);
<b class="fc">&nbsp;        INVOKER = (Invoker)doPrivileged(new InvokerCreationAction());</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    public boolean equals(Object var1) {
<b class="fc">&nbsp;        if (this == var1) {</b>
&nbsp;            return true;
<b class="fc">&nbsp;        } else if (var1 == null) {</b>
&nbsp;            return false;
&nbsp;        } else if (this.getClass() != var1.getClass()) {
<b class="fc">&nbsp;            return false;</b>
&nbsp;        } else if (this.generate != ((JavaDispatcher)var1).generate) {
&nbsp;            return false;
&nbsp;        } else if (!this.proxy.equals(((JavaDispatcher)var1).proxy)) {
&nbsp;            return false;
&nbsp;        } else {
&nbsp;            ClassLoader var2 = ((JavaDispatcher)var1).classLoader;
<b class="fc">&nbsp;            ClassLoader var3 = this.classLoader;</b>
<b class="fc">&nbsp;            if (var2 != null) {</b>
<b class="fc">&nbsp;                if (var3 == null) {</b>
&nbsp;                    return false;
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                if (!var3.equals(var2)) {</b>
&nbsp;                    return false;
&nbsp;                }
<b class="fc">&nbsp;            } else if (var3 != null) {</b>
&nbsp;                return false;
&nbsp;            }
<b class="fc">&nbsp;</b>
&nbsp;            return true;
<b class="fc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    public int hashCode() {
&nbsp;        int var10000 = (this.getClass().hashCode() * 31 + this.proxy.hashCode()) * 31;
&nbsp;        ClassLoader var1 = this.classLoader;
&nbsp;        if (var1 != null) {
&nbsp;            var10000 += var1.hashCode();
&nbsp;        }
&nbsp;
&nbsp;        return var10000 * 31 + this.generate;
&nbsp;    }
&nbsp;
&nbsp;    protected static class DynamicClassLoader extends ClassLoader {
&nbsp;        private static final Class&lt;?&gt;[] NO_PARAMETER = new Class[0];
&nbsp;        private static final Object[] NO_ARGUMENT = new Object[0];
&nbsp;
&nbsp;        protected DynamicClassLoader(Class&lt;?&gt; target) {
&nbsp;            super(target.getClassLoader());
&nbsp;            JavaDispatcher.RESOLVER.accept(this, target);
&nbsp;        }
&nbsp;
&nbsp;        @SuppressFBWarnings(
&nbsp;            value = {&quot;REC_CATCH_EXCEPTION&quot;, &quot;DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEGED&quot;},
&nbsp;            justification = &quot;Expected internal invocation.&quot;
&nbsp;        )
&nbsp;        protected static Object proxy(Class&lt;?&gt; proxy, Map&lt;Method, Dispatcher&gt; dispatchers) {
&nbsp;            ClassWriter classWriter = new ClassWriter(0);
&nbsp;            classWriter.visit(ClassFileVersion.ofThisVm(ClassFileVersion.JAVA_V5).getMinorMajorVersion(), 1, Type.getInternalName(proxy) + &quot;$Proxy&quot;, (String)null, Type.getInternalName(Object.class), new String[]{Type.getInternalName(proxy)});
&nbsp;            Iterator var3 = dispatchers.entrySet().iterator();
&nbsp;
&nbsp;            while(var3.hasNext()) {
&nbsp;                Map.Entry&lt;Method, Dispatcher&gt; entry = (Map.Entry)var3.next();
&nbsp;                Class&lt;?&gt;[] exceptionType = ((Method)entry.getKey()).getExceptionTypes();
&nbsp;                String[] exceptionTypeName = new String[exceptionType.length];
&nbsp;
&nbsp;                for(int index = 0; index &lt; exceptionType.length; ++index) {
&nbsp;                    exceptionTypeName[index] = Type.getInternalName(exceptionType[index]);
&nbsp;                }
&nbsp;
&nbsp;                MethodVisitor methodVisitor = classWriter.visitMethod(1, ((Method)entry.getKey()).getName(), Type.getMethodDescriptor((Method)entry.getKey()), (String)null, exceptionTypeName);
&nbsp;                methodVisitor.visitCode();
&nbsp;                int offset = (((Method)entry.getKey()).getModifiers() &amp; 8) == 0 ? 1 : 0;
&nbsp;                Class[] var9 = ((Method)entry.getKey()).getParameterTypes();
&nbsp;                int var10 = var9.length;
&nbsp;
&nbsp;                for(int var11 = 0; var11 &lt; var10; ++var11) {
&nbsp;                    Class&lt;?&gt; type = var9[var11];
&nbsp;                    offset += Type.getType(type).getSize();
&nbsp;                }
&nbsp;
&nbsp;                methodVisitor.visitMaxs(((Dispatcher)entry.getValue()).apply(methodVisitor, (Method)entry.getKey()), offset);
&nbsp;                methodVisitor.visitEnd();
&nbsp;            }
&nbsp;
&nbsp;            MethodVisitor methodVisitor = classWriter.visitMethod(1, &quot;&lt;init&gt;&quot;, Type.getMethodDescriptor(Type.VOID_TYPE, new Type[0]), (String)null, (String[])null);
&nbsp;            methodVisitor.visitCode();
&nbsp;            methodVisitor.visitVarInsn(25, 0);
&nbsp;            methodVisitor.visitMethodInsn(183, Type.getInternalName(Object.class), &quot;&lt;init&gt;&quot;, Type.getMethodDescriptor(Type.VOID_TYPE, new Type[0]), false);
&nbsp;            methodVisitor.visitInsn(177);
&nbsp;            methodVisitor.visitMaxs(1, 1);
&nbsp;            methodVisitor.visitEnd();
&nbsp;            classWriter.visitEnd();
&nbsp;            byte[] binaryRepresentation = classWriter.toByteArray();
&nbsp;
&nbsp;            try {
&nbsp;                return (new DynamicClassLoader(proxy)).defineClass(proxy.getName() + &quot;$Proxy&quot;, binaryRepresentation, 0, binaryRepresentation.length, JavaDispatcher.class.getProtectionDomain()).getConstructor(NO_PARAMETER).newInstance(NO_ARGUMENT);
&nbsp;            } catch (Exception var13) {
&nbsp;                throw new IllegalStateException(&quot;Failed to create proxy for &quot; + proxy.getName(), var13);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @SuppressFBWarnings(
&nbsp;            value = {&quot;REC_CATCH_EXCEPTION&quot;, &quot;DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEGED&quot;},
&nbsp;            justification = &quot;Expected internal invocation.&quot;
&nbsp;        )
&nbsp;        protected static Invoker invoker() {
<b class="fc">&nbsp;            ClassWriter classWriter = new ClassWriter(0);</b>
&nbsp;            classWriter.visit(ClassFileVersion.ofThisVm(ClassFileVersion.JAVA_V5).getMinorMajorVersion(), 1, Type.getInternalName(Invoker.class) + &quot;$Dispatcher&quot;, (String)null, Type.getInternalName(Object.class), new String[]{Type.getInternalName(Invoker.class)});
&nbsp;            Method[] var1 = Invoker.class.getMethods();
&nbsp;            int var2 = var1.length;
&nbsp;
&nbsp;            for(int var3 = 0; var3 &lt; var2; ++var3) {
<b class="fc">&nbsp;                Method method = var1[var3];</b>
&nbsp;                Class&lt;?&gt;[] exceptionType = method.getExceptionTypes();
&nbsp;                String[] exceptionTypeName = new String[exceptionType.length];
&nbsp;
&nbsp;                for(int index = 0; index &lt; exceptionType.length; ++index) {
&nbsp;                    exceptionTypeName[index] = Type.getInternalName(exceptionType[index]);
&nbsp;                }
&nbsp;
&nbsp;                MethodVisitor methodVisitor = classWriter.visitMethod(1, method.getName(), Type.getMethodDescriptor(method), (String)null, exceptionTypeName);
&nbsp;                methodVisitor.visitCode();
&nbsp;                int offset = 1;
&nbsp;                Type[] parameter = new Type[method.getParameterTypes().length - 1];
&nbsp;
&nbsp;                for(int index = 0; index &lt; method.getParameterTypes().length; ++index) {
&nbsp;                    Type type = Type.getType(method.getParameterTypes()[index]);
&nbsp;                    if (index &gt; 0) {
&nbsp;                        parameter[index - 1] = type;
&nbsp;                    }
&nbsp;
&nbsp;                    methodVisitor.visitVarInsn(type.getOpcode(21), offset);
&nbsp;                    offset += type.getSize();
&nbsp;                }
&nbsp;
&nbsp;                methodVisitor.visitMethodInsn(182, Type.getInternalName(method.getParameterTypes()[0]), method.getName(), Type.getMethodDescriptor(Type.getReturnType(method), parameter), false);
&nbsp;                methodVisitor.visitInsn(Type.getReturnType(method).getOpcode(172));
&nbsp;                methodVisitor.visitMaxs(Math.max(offset - 1, Type.getReturnType(method).getSize()), offset);
&nbsp;                methodVisitor.visitEnd();
&nbsp;            }
&nbsp;
&nbsp;            MethodVisitor methodVisitor = classWriter.visitMethod(1, &quot;&lt;init&gt;&quot;, Type.getMethodDescriptor(Type.VOID_TYPE, new Type[0]), (String)null, (String[])null);
&nbsp;            methodVisitor.visitCode();
&nbsp;            methodVisitor.visitVarInsn(25, 0);
&nbsp;            methodVisitor.visitMethodInsn(183, Type.getInternalName(Object.class), &quot;&lt;init&gt;&quot;, Type.getMethodDescriptor(Type.VOID_TYPE, new Type[0]), false);
&nbsp;            methodVisitor.visitInsn(177);
&nbsp;            methodVisitor.visitMaxs(1, 1);
&nbsp;            methodVisitor.visitEnd();
&nbsp;            classWriter.visitEnd();
&nbsp;            byte[] binaryRepresentation = classWriter.toByteArray();
&nbsp;
&nbsp;            try {
&nbsp;                return (Invoker)(new DynamicClassLoader(Invoker.class)).defineClass(Invoker.class.getName() + &quot;$Dispatcher&quot;, binaryRepresentation, 0, binaryRepresentation.length, JavaDispatcher.class.getProtectionDomain()).getConstructor(NO_PARAMETER).newInstance(NO_ARGUMENT);
&nbsp;            } catch (UnsupportedOperationException var12) {
&nbsp;                return new DirectInvoker();
&nbsp;            } catch (Exception var13) {
&nbsp;                throw new IllegalStateException(&quot;Failed to create invoker for &quot; + Invoker.class.getName(), var13);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        protected interface Resolver {
&nbsp;            void accept(@Nonnull(when = When.MAYBE) ClassLoader var1, Class&lt;?&gt; var2);
&nbsp;
&nbsp;            @Enhance
&nbsp;            public static class ForModuleSystem implements Resolver {
&nbsp;                private final Method getModule;
&nbsp;                private final Method isExported;
&nbsp;                private final Method addExports;
&nbsp;                private final Method getUnnamedModule;
&nbsp;
&nbsp;                protected ForModuleSystem(Method getModule, Method isExported, Method addExports, Method getUnnamedModule) {
&nbsp;                    this.getModule = getModule;
&nbsp;                    this.isExported = isExported;
&nbsp;                    this.addExports = addExports;
&nbsp;                    this.getUnnamedModule = getUnnamedModule;
&nbsp;                }
&nbsp;
&nbsp;                @SuppressFBWarnings(
<b class="fc">&nbsp;                    value = {&quot;REC_CATCH_EXCEPTION&quot;},</b>
<b class="fc">&nbsp;                    justification = &quot;Exception should always be wrapped for clarity.&quot;</b>
&nbsp;                )
&nbsp;                public void accept(@Nonnull(when = When.MAYBE) ClassLoader classLoader, Class&lt;?&gt; target) {
&nbsp;                    Package location = target.getPackage();
&nbsp;                    if (location != null) {
&nbsp;                        try {
&nbsp;                            Object module = this.getModule.invoke(target);
<b class="fc">&nbsp;                            if (!(Boolean)this.isExported.invoke(module, location.getName())) {</b>
&nbsp;                                this.addExports.invoke(module, location.getName(), this.getUnnamedModule.invoke(classLoader));
&nbsp;                            }
&nbsp;                        } catch (Exception var5) {
&nbsp;                            throw new IllegalStateException(&quot;Failed to adjust module graph for dispatcher&quot;, var5);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(Object var1) {
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.getModule.equals(((ForModuleSystem)var1).getModule)) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.isExported.equals(((ForModuleSystem)var1).isExported)) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.addExports.equals(((ForModuleSystem)var1).addExports)) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.getUnnamedModule.equals(((ForModuleSystem)var1).getUnnamedModule);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return (((this.getClass().hashCode() * 31 + this.getModule.hashCode()) * 31 + this.isExported.hashCode()) * 31 + this.addExports.hashCode()) * 31 + this.getUnnamedModule.hashCode();
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public static enum NoOp implements Resolver {
&nbsp;                INSTANCE;
&nbsp;
&nbsp;                private NoOp() {
&nbsp;                }
&nbsp;
&nbsp;                public void accept(@Nonnull(when = When.MAYBE) ClassLoader classLoader, Class&lt;?&gt; target) {
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public static enum CreationAction implements PrivilegedAction&lt;Resolver&gt; {
&nbsp;                INSTANCE;
&nbsp;
&nbsp;                private CreationAction() {
&nbsp;                }
&nbsp;
&nbsp;                @SuppressFBWarnings(
&nbsp;                    value = {&quot;REC_CATCH_EXCEPTION&quot;},
&nbsp;                    justification = &quot;Exception should not be rethrown but trigger a fallback.&quot;
&nbsp;                )
&nbsp;                public Resolver run() {
&nbsp;                    try {
<b class="fc">&nbsp;                        Class&lt;?&gt; module = Class.forName(&quot;java.lang.Module&quot;, false, (ClassLoader)null);</b>
&nbsp;                        return new ForModuleSystem(Class.class.getMethod(&quot;getModule&quot;), module.getMethod(&quot;isExported&quot;, String.class), module.getMethod(&quot;addExports&quot;, String.class, module), ClassLoader.class.getMethod(&quot;getUnnamedModule&quot;));
&nbsp;                    } catch (Exception var2) {
&nbsp;                        return JavaDispatcher.DynamicClassLoader.Resolver.NoOp.INSTANCE;
&nbsp;                    }
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    @Enhance</b>
&nbsp;    protected static class ProxiedInvocationHandler implements InvocationHandler {
&nbsp;        private static final Object[] NO_ARGUMENTS = new Object[0];
&nbsp;        private final String name;
&nbsp;        private final Map&lt;Method, Dispatcher&gt; targets;
<b class="fc">&nbsp;</b>
&nbsp;        protected ProxiedInvocationHandler(String name, Map&lt;Method, Dispatcher&gt; targets) {
&nbsp;            this.name = name;
&nbsp;            this.targets = targets;
&nbsp;        }
<b class="fc">&nbsp;</b>
&nbsp;        @Nonnull(
&nbsp;            when = When.MAYBE
&nbsp;        )
&nbsp;        public Object invoke(Object proxy, Method method, @Nonnull(when = When.MAYBE) Object[] argument) throws Throwable {
<b class="fc">&nbsp;            if (method.getDeclaringClass() != Object.class) {</b>
&nbsp;                Dispatcher dispatcher = (Dispatcher)this.targets.get(method);
&nbsp;
&nbsp;                try {
&nbsp;                    try {
<b class="fc">&nbsp;                        if (dispatcher == null) {</b>
&nbsp;                            throw new IllegalStateException(&quot;No proxy target found for &quot; + method);
&nbsp;                        } else {
&nbsp;                            return dispatcher.invoke(argument == null ? NO_ARGUMENTS : argument);
&nbsp;                        }
<b class="fc">&nbsp;                    } catch (InvocationTargetException var10) {</b>
&nbsp;                        throw var10.getTargetException();
&nbsp;                    }
&nbsp;                } catch (RuntimeException var11) {
&nbsp;                    throw var11;
<b class="fc">&nbsp;                } catch (Throwable var12) {</b>
&nbsp;                    Throwable throwable = var12;
&nbsp;                    Class[] var6 = method.getExceptionTypes();
&nbsp;                    int var7 = var6.length;
&nbsp;
<b class="fc">&nbsp;                    for(int var8 = 0; var8 &lt; var7; ++var8) {</b>
&nbsp;                        Class&lt;?&gt; type = var6[var8];
&nbsp;                        if (type.isInstance(throwable)) {
&nbsp;                            throw throwable;
&nbsp;                        }
<b class="fc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    throw new IllegalStateException(&quot;Failed to invoke proxy for &quot; + method, throwable);
&nbsp;                }
&nbsp;            } else if (method.getName().equals(&quot;hashCode&quot;)) {
<b class="fc">&nbsp;                return this.hashCode();</b>
&nbsp;            } else if (!method.getName().equals(&quot;equals&quot;)) {
&nbsp;                if (method.getName().equals(&quot;toString&quot;)) {
&nbsp;                    return &quot;Call proxy for &quot; + this.name;
&nbsp;                } else {
&nbsp;                    throw new IllegalStateException(&quot;Unexpected object method: &quot; + method);
&nbsp;                }
&nbsp;            } else {
&nbsp;                return argument[0] != null &amp;&amp; Proxy.isProxyClass(argument[0].getClass()) &amp;&amp; Proxy.getInvocationHandler(argument[0]).equals(this);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public boolean equals(Object var1) {
&nbsp;            if (this == var1) {
&nbsp;                return true;
&nbsp;            } else if (var1 == null) {
&nbsp;                return false;
&nbsp;            } else if (this.getClass() != var1.getClass()) {
&nbsp;                return false;
&nbsp;            } else if (!this.name.equals(((ProxiedInvocationHandler)var1).name)) {
&nbsp;                return false;
&nbsp;            } else {
&nbsp;                return this.targets.equals(((ProxiedInvocationHandler)var1).targets);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public int hashCode() {
&nbsp;            return (this.getClass().hashCode() * 31 + this.name.hashCode()) * 31 + this.targets.hashCode();
&nbsp;        }
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    protected interface Dispatcher {</b>
<b class="fc">&nbsp;        @Nonnull(</b>
<b class="fc">&nbsp;            when = When.MAYBE</b>
<b class="fc">&nbsp;        )</b>
<b class="fc">&nbsp;        Object invoke(Object[] var1) throws Throwable;</b>
&nbsp;
&nbsp;        int apply(MethodVisitor var1, Method var2);
&nbsp;
&nbsp;        @Enhance
&nbsp;        public static class ForUnresolvedMethod implements Dispatcher {
&nbsp;            private final String message;
&nbsp;
&nbsp;            protected ForUnresolvedMethod(String message) {
&nbsp;                this.message = message;
<b class="fc">&nbsp;            }</b>
&nbsp;
<b class="fc">&nbsp;            public Object invoke(Object[] argument) throws Throwable {</b>
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;Could not invoke proxy: &quot; + this.message);</b>
<b class="fc">&nbsp;            }</b>
&nbsp;
<b class="fc">&nbsp;            public int apply(MethodVisitor methodVisitor, Method method) {</b>
&nbsp;                methodVisitor.visitTypeInsn(187, Type.getInternalName(IllegalStateException.class));
<b class="fc">&nbsp;                methodVisitor.visitInsn(89);</b>
&nbsp;                methodVisitor.visitLdcInsn(this.message);
<b class="fc">&nbsp;                methodVisitor.visitMethodInsn(183, Type.getInternalName(IllegalStateException.class), &quot;&lt;init&gt;&quot;, Type.getMethodDescriptor(Type.VOID_TYPE, new Type[]{Type.getType(String.class)}), false);</b>
&nbsp;                methodVisitor.visitInsn(191);
<b class="fc">&nbsp;                return 3;</b>
&nbsp;            }
<b class="fc">&nbsp;</b>
&nbsp;            public boolean equals(Object var1) {
<b class="fc">&nbsp;                if (this == var1) {</b>
&nbsp;                    return true;
<b class="fc">&nbsp;                } else if (var1 == null) {</b>
<b class="fc">&nbsp;                    return false;</b>
&nbsp;                } else if (this.getClass() != var1.getClass()) {
<b class="fc">&nbsp;                    return false;</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    return this.message.equals(((ForUnresolvedMethod)var1).message);</b>
&nbsp;                }
<b class="fc">&nbsp;            }</b>
&nbsp;
<b class="fc">&nbsp;            public int hashCode() {</b>
&nbsp;                return this.getClass().hashCode() * 31 + this.message.hashCode();
<b class="fc">&nbsp;            }</b>
&nbsp;        }
<b class="fc">&nbsp;</b>
&nbsp;        @Enhance
<b class="fc">&nbsp;        public static class ForNonStaticMethod implements Dispatcher {</b>
&nbsp;            private static final Object[] NO_ARGUMENTS = new Object[0];
&nbsp;            private final Method method;
<b class="fc">&nbsp;</b>
&nbsp;            protected ForNonStaticMethod(Method method) {
&nbsp;                this.method = method;
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            public Object invoke(Object[] argument) throws Throwable {
&nbsp;                Object[] reduced;
&nbsp;                if (argument.length == 1) {
&nbsp;                    reduced = NO_ARGUMENTS;
&nbsp;                } else {
&nbsp;                    reduced = new Object[argument.length - 1];
&nbsp;                    System.arraycopy(argument, 1, reduced, 0, reduced.length);
&nbsp;                }
&nbsp;
&nbsp;                return JavaDispatcher.INVOKER.invoke(this.method, argument[0], reduced);
&nbsp;            }
&nbsp;
&nbsp;            public int apply(MethodVisitor methodVisitor, Method method) {
&nbsp;                Class&lt;?&gt;[] source = method.getParameterTypes();
&nbsp;                Class&lt;?&gt;[] target = this.method.getParameterTypes();
&nbsp;                int offset = 1;
&nbsp;
&nbsp;                for(int index = 0; index &lt; source.length; ++index) {
&nbsp;                    Type type = Type.getType(source[index]);
&nbsp;                    methodVisitor.visitVarInsn(type.getOpcode(21), offset);
&nbsp;                    if (source[index] != (index == 0 ? this.method.getDeclaringClass() : target[index - 1])) {
&nbsp;                        methodVisitor.visitTypeInsn(192, Type.getInternalName(index == 0 ? this.method.getDeclaringClass() : target[index - 1]));
&nbsp;                    }
&nbsp;
&nbsp;                    offset += type.getSize();
&nbsp;                }
&nbsp;
&nbsp;                methodVisitor.visitMethodInsn(this.method.getDeclaringClass().isInterface() ? 185 : 182, Type.getInternalName(this.method.getDeclaringClass()), this.method.getName(), Type.getMethodDescriptor(this.method), this.method.getDeclaringClass().isInterface());
&nbsp;                methodVisitor.visitInsn(Type.getReturnType(this.method).getOpcode(172));
&nbsp;                return Math.max(offset - 1, Type.getReturnType(this.method).getSize());
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(Object var1) {
&nbsp;                if (this == var1) {
&nbsp;                    return true;
&nbsp;                } else if (var1 == null) {
&nbsp;                    return false;
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return this.method.equals(((ForNonStaticMethod)var1).method);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public int hashCode() {
&nbsp;                return this.getClass().hashCode() * 31 + this.method.hashCode();
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Enhance
&nbsp;        public static class ForStaticMethod implements Dispatcher {
&nbsp;            private final Method method;
&nbsp;
&nbsp;            protected ForStaticMethod(Method method) {
&nbsp;                this.method = method;
&nbsp;            }
&nbsp;
&nbsp;            @Nonnull(
&nbsp;                when = When.MAYBE
&nbsp;            )
&nbsp;            public Object invoke(Object[] argument) throws Throwable {
&nbsp;                return JavaDispatcher.INVOKER.invoke(this.method, (Object)null, argument);
&nbsp;            }
&nbsp;
&nbsp;            public int apply(MethodVisitor methodVisitor, Method method) {
&nbsp;                Class&lt;?&gt;[] source = method.getParameterTypes();
&nbsp;                Class&lt;?&gt;[] target = this.method.getParameterTypes();
&nbsp;                int offset = 1;
&nbsp;
&nbsp;                for(int index = 0; index &lt; source.length; ++index) {
&nbsp;                    Type type = Type.getType(source[index]);
&nbsp;                    methodVisitor.visitVarInsn(type.getOpcode(21), offset);
&nbsp;                    if (source[index] != target[index]) {
&nbsp;                        methodVisitor.visitTypeInsn(192, Type.getInternalName(target[index]));
&nbsp;                    }
&nbsp;
&nbsp;                    offset += type.getSize();
&nbsp;                }
&nbsp;
&nbsp;                methodVisitor.visitMethodInsn(184, Type.getInternalName(this.method.getDeclaringClass()), this.method.getName(), Type.getMethodDescriptor(this.method), this.method.getDeclaringClass().isInterface());
&nbsp;                methodVisitor.visitInsn(Type.getReturnType(this.method).getOpcode(172));
&nbsp;                return Math.max(offset - 1, Type.getReturnType(this.method).getSize());
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(Object var1) {
&nbsp;                if (this == var1) {
&nbsp;                    return true;
&nbsp;                } else if (var1 == null) {
&nbsp;                    return false;
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return this.method.equals(((ForStaticMethod)var1).method);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public int hashCode() {
&nbsp;                return this.getClass().hashCode() * 31 + this.method.hashCode();
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Enhance
&nbsp;        public static class ForConstructor implements Dispatcher {
&nbsp;            private final Constructor&lt;?&gt; constructor;
&nbsp;
&nbsp;            protected ForConstructor(Constructor&lt;?&gt; constructor) {
&nbsp;                this.constructor = constructor;
&nbsp;            }
&nbsp;
&nbsp;            public Object invoke(Object[] argument) throws Throwable {
&nbsp;                return JavaDispatcher.INVOKER.newInstance(this.constructor, argument);
&nbsp;            }
&nbsp;
&nbsp;            public int apply(MethodVisitor methodVisitor, Method method) {
&nbsp;                Class&lt;?&gt;[] source = method.getParameterTypes();
&nbsp;                Class&lt;?&gt;[] target = this.constructor.getParameterTypes();
&nbsp;                methodVisitor.visitTypeInsn(187, Type.getInternalName(this.constructor.getDeclaringClass()));
&nbsp;                methodVisitor.visitInsn(89);
&nbsp;                int offset = 1;
&nbsp;
&nbsp;                for(int index = 0; index &lt; source.length; ++index) {
&nbsp;                    Type type = Type.getType(source[index]);
&nbsp;                    methodVisitor.visitVarInsn(type.getOpcode(21), offset);
&nbsp;                    if (source[index] != target[index]) {
&nbsp;                        methodVisitor.visitTypeInsn(192, Type.getInternalName(target[index]));
&nbsp;                    }
&nbsp;
&nbsp;                    offset += type.getSize();
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                methodVisitor.visitMethodInsn(183, Type.getInternalName(this.constructor.getDeclaringClass()), &quot;&lt;init&gt;&quot;, Type.getConstructorDescriptor(this.constructor), false);</b>
&nbsp;                methodVisitor.visitInsn(176);
&nbsp;                return offset + 1;
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(Object var1) {
&nbsp;                if (this == var1) {
&nbsp;                    return true;
&nbsp;                } else if (var1 == null) {
&nbsp;                    return false;
<b class="fc">&nbsp;                } else if (this.getClass() != var1.getClass()) {</b>
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return this.constructor.equals(((ForConstructor)var1).constructor);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public int hashCode() {
&nbsp;                return this.getClass().hashCode() * 31 + this.constructor.hashCode();
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public static enum ForDefaultValue implements Dispatcher {
&nbsp;            VOID((Object)null, 0, 177, 0),
&nbsp;            BOOLEAN(false, 3, 172, 1),
&nbsp;            BOOLEAN_REVERSE(true, 4, 172, 1),
&nbsp;            BYTE((byte)0, 3, 172, 1),
&nbsp;            SHORT(Short.valueOf((short)0), 3, 172, 1),
&nbsp;            CHARACTER(&#39;\u0000&#39;, 3, 172, 1),
&nbsp;            INTEGER(0, 3, 172, 1),
&nbsp;            LONG(0L, 9, 173, 2),
&nbsp;            FLOAT(0.0F, 11, 174, 1),
&nbsp;            DOUBLE(0.0, 14, 175, 2),
&nbsp;            REFERENCE((Object)null, 1, 176, 1);
&nbsp;
&nbsp;            @Nonnull(
&nbsp;                when = When.MAYBE
&nbsp;            )
&nbsp;            private final Object value;
&nbsp;            private final int load;
&nbsp;            private final int returned;
&nbsp;            private final int size;
&nbsp;
&nbsp;            private ForDefaultValue(@Nonnull(when = When.MAYBE) Object value, int load, int returned, int size) {
&nbsp;                this.value = value;
&nbsp;                this.load = load;
&nbsp;                this.returned = returned;
&nbsp;                this.size = size;
&nbsp;            }
&nbsp;
&nbsp;            protected static Dispatcher of(Class&lt;?&gt; type) {
&nbsp;                if (type == Void.TYPE) {
&nbsp;                    return VOID;
&nbsp;                } else if (type == Boolean.TYPE) {
&nbsp;                    return BOOLEAN;
&nbsp;                } else if (type == Byte.TYPE) {
&nbsp;                    return BYTE;
&nbsp;                } else if (type == Short.TYPE) {
&nbsp;                    return SHORT;
&nbsp;                } else if (type == Character.TYPE) {
&nbsp;                    return CHARACTER;
&nbsp;                } else if (type == Integer.TYPE) {
&nbsp;                    return INTEGER;
&nbsp;                } else if (type == Long.TYPE) {
&nbsp;                    return LONG;
&nbsp;                } else if (type == Float.TYPE) {
&nbsp;                    return FLOAT;
&nbsp;                } else if (type == Double.TYPE) {
&nbsp;                    return DOUBLE;
&nbsp;                } else if (type.isArray()) {
&nbsp;                    if (type.getComponentType() == Boolean.TYPE) {
&nbsp;                        return JavaDispatcher.Dispatcher.ForDefaultValue.OfPrimitiveArray.BOOLEAN;
&nbsp;                    } else if (type.getComponentType() == Byte.TYPE) {
&nbsp;                        return JavaDispatcher.Dispatcher.ForDefaultValue.OfPrimitiveArray.BYTE;
&nbsp;                    } else if (type.getComponentType() == Short.TYPE) {
&nbsp;                        return JavaDispatcher.Dispatcher.ForDefaultValue.OfPrimitiveArray.SHORT;
&nbsp;                    } else if (type.getComponentType() == Character.TYPE) {
&nbsp;                        return JavaDispatcher.Dispatcher.ForDefaultValue.OfPrimitiveArray.CHARACTER;
&nbsp;                    } else if (type.getComponentType() == Integer.TYPE) {
&nbsp;                        return JavaDispatcher.Dispatcher.ForDefaultValue.OfPrimitiveArray.INTEGER;
&nbsp;                    } else if (type.getComponentType() == Long.TYPE) {
&nbsp;                        return JavaDispatcher.Dispatcher.ForDefaultValue.OfPrimitiveArray.LONG;
&nbsp;                    } else if (type.getComponentType() == Float.TYPE) {
&nbsp;                        return JavaDispatcher.Dispatcher.ForDefaultValue.OfPrimitiveArray.FLOAT;
&nbsp;                    } else {
&nbsp;                        return (Dispatcher)(type.getComponentType() == Double.TYPE ? JavaDispatcher.Dispatcher.ForDefaultValue.OfPrimitiveArray.DOUBLE : JavaDispatcher.Dispatcher.ForDefaultValue.OfNonPrimitiveArray.of(type.getComponentType()));
&nbsp;                    }
&nbsp;                } else {
&nbsp;                    return REFERENCE;
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Nonnull(
&nbsp;                when = When.MAYBE
&nbsp;            )
&nbsp;            public Object invoke(Object[] argument) {
&nbsp;                return this.value;
&nbsp;            }
&nbsp;
&nbsp;            public int apply(MethodVisitor methodVisitor, Method method) {
&nbsp;                if (this.load != 0) {
<b class="fc">&nbsp;                    methodVisitor.visitInsn(this.load);</b>
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                methodVisitor.visitInsn(this.returned);
&nbsp;                return this.size;
&nbsp;            }
&nbsp;
&nbsp;            @Enhance
&nbsp;            protected static class OfNonPrimitiveArray implements Dispatcher {
<b class="fc">&nbsp;                @ValueHandling(Sort.IGNORE)</b>
&nbsp;                private final Object value;
&nbsp;                private final Class&lt;?&gt; componentType;
&nbsp;
&nbsp;                protected OfNonPrimitiveArray(Object value, Class&lt;?&gt; componentType) {
&nbsp;                    this.value = value;
&nbsp;                    this.componentType = componentType;
&nbsp;                }
&nbsp;
&nbsp;                protected static Dispatcher of(Class&lt;?&gt; componentType) {
&nbsp;                    return new OfNonPrimitiveArray(Array.newInstance(componentType, 0), componentType);
&nbsp;                }
&nbsp;
&nbsp;                public Object invoke(Object[] argument) {
&nbsp;                    return this.value;
&nbsp;                }
&nbsp;
&nbsp;                public int apply(MethodVisitor methodVisitor, Method method) {
&nbsp;                    methodVisitor.visitInsn(3);
&nbsp;                    methodVisitor.visitTypeInsn(189, Type.getInternalName(this.componentType));
&nbsp;                    methodVisitor.visitInsn(176);
&nbsp;                    return 1;
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(Object var1) {
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.componentType.equals(((OfNonPrimitiveArray)var1).componentType);
&nbsp;                    }
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                public int hashCode() {</b>
&nbsp;                    return this.getClass().hashCode() * 31 + this.componentType.hashCode();
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            protected static enum OfPrimitiveArray implements Dispatcher {
&nbsp;                BOOLEAN(new boolean[0], 4),
&nbsp;                BYTE(new byte[0], 8),
&nbsp;                SHORT(new short[0], 9),
&nbsp;                CHARACTER(new char[0], 5),
&nbsp;                INTEGER(new int[0], 10),
&nbsp;                LONG(new long[0], 11),
<b class="fc">&nbsp;                FLOAT(new float[0], 6),</b>
<b class="fc">&nbsp;                DOUBLE(new double[0], 7);</b>
&nbsp;
&nbsp;                private final Object value;
&nbsp;                private final int operand;
&nbsp;
&nbsp;                private OfPrimitiveArray(Object value, int operand) {
&nbsp;                    this.value = value;
&nbsp;                    this.operand = operand;
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;</b>
&nbsp;                public Object invoke(Object[] argument) {
&nbsp;                    return this.value;
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                public int apply(MethodVisitor methodVisitor, Method method) {</b>
&nbsp;                    methodVisitor.visitInsn(3);
&nbsp;                    methodVisitor.visitIntInsn(188, this.operand);
&nbsp;                    methodVisitor.visitInsn(176);
&nbsp;                    return 1;
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Enhance
&nbsp;        public static class ForContainerCreation implements Dispatcher {
&nbsp;            private final Class&lt;?&gt; target;
&nbsp;
&nbsp;            protected ForContainerCreation(Class&lt;?&gt; target) {
&nbsp;                this.target = target;
&nbsp;            }
&nbsp;
&nbsp;            public Object invoke(Object[] argument) {
&nbsp;                return Array.newInstance(this.target, (Integer)argument[0]);
&nbsp;            }
&nbsp;
&nbsp;            public int apply(MethodVisitor methodVisitor, Method method) {
&nbsp;                methodVisitor.visitVarInsn(21, 1);
&nbsp;                methodVisitor.visitTypeInsn(189, Type.getInternalName(this.target));
&nbsp;                methodVisitor.visitInsn(176);
&nbsp;                return 1;
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(Object var1) {
&nbsp;                if (this == var1) {
&nbsp;                    return true;
&nbsp;                } else if (var1 == null) {
&nbsp;                    return false;
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return this.target.equals(((ForContainerCreation)var1).target);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public int hashCode() {
&nbsp;                return this.getClass().hashCode() * 31 + this.target.hashCode();
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        @Enhance</b>
<b class="fc">&nbsp;        public static class ForInstanceCheck implements Dispatcher {</b>
&nbsp;            private final Class&lt;?&gt; target;
&nbsp;
&nbsp;            protected ForInstanceCheck(Class&lt;?&gt; target) {
&nbsp;                this.target = target;
&nbsp;            }
&nbsp;
&nbsp;            public Object invoke(Object[] argument) {
&nbsp;                return this.target.isInstance(argument[0]);
&nbsp;            }
&nbsp;
&nbsp;            public int apply(MethodVisitor methodVisitor, Method method) {
&nbsp;                methodVisitor.visitVarInsn(25, 1);
&nbsp;                methodVisitor.visitTypeInsn(193, Type.getInternalName(this.target));
&nbsp;                methodVisitor.visitInsn(172);
&nbsp;                return 1;
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(Object var1) {
&nbsp;                if (this == var1) {
&nbsp;                    return true;
&nbsp;                } else if (var1 == null) {
&nbsp;                    return false;
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return this.target.equals(((ForInstanceCheck)var1).target);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public int hashCode() {
&nbsp;                return this.getClass().hashCode() * 31 + this.target.hashCode();
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Enhance
<b class="fc">&nbsp;    private static class DirectInvoker implements Invoker {</b>
&nbsp;        private DirectInvoker() {
&nbsp;        }
&nbsp;
&nbsp;        public Object newInstance(Constructor&lt;?&gt; constructor, Object[] argument) throws InstantiationException, IllegalAccessException, InvocationTargetException {
&nbsp;            return constructor.newInstance(argument);
&nbsp;        }
&nbsp;
&nbsp;        public Object invoke(Method method, @Nonnull(when = When.MAYBE) Object instance, Object[] argument) throws IllegalAccessException, InvocationTargetException {
&nbsp;            return method.invoke(instance, argument);
&nbsp;        }
&nbsp;
&nbsp;        public boolean equals(Object var1) {
&nbsp;            if (this == var1) {
&nbsp;                return true;
&nbsp;            } else if (var1 == null) {
&nbsp;                return false;
&nbsp;            } else {
<b class="fc">&nbsp;                return this.getClass() == var1.getClass();</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        public int hashCode() {
&nbsp;            return this.getClass().hashCode();
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Enhance
<b class="fc">&nbsp;    private static class InvokerCreationAction implements PrivilegedAction&lt;Invoker&gt; {</b>
&nbsp;        private InvokerCreationAction() {
&nbsp;        }
&nbsp;
&nbsp;        public Invoker run() {
&nbsp;            return JavaDispatcher.DynamicClassLoader.invoker();
&nbsp;        }
&nbsp;
&nbsp;        public boolean equals(Object var1) {
&nbsp;            if (this == var1) {
&nbsp;                return true;
&nbsp;            } else if (var1 == null) {
&nbsp;                return false;
<b class="fc">&nbsp;            } else {</b>
&nbsp;                return this.getClass() == var1.getClass();
&nbsp;            }
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        public int hashCode() {
<b class="fc">&nbsp;            return this.getClass().hashCode();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Documented
&nbsp;    @Target({ElementType.TYPE, ElementType.METHOD})
&nbsp;    @Retention(RetentionPolicy.RUNTIME)
&nbsp;    public @interface Defaults {
&nbsp;    }
&nbsp;
&nbsp;    @Documented
&nbsp;    @Target({ElementType.METHOD})
&nbsp;    @Retention(RetentionPolicy.RUNTIME)
&nbsp;    public @interface Container {
&nbsp;    }
&nbsp;
&nbsp;    @Documented
&nbsp;    @Target({ElementType.METHOD})
&nbsp;    @Retention(RetentionPolicy.RUNTIME)
&nbsp;    public @interface Instance {
&nbsp;    }
&nbsp;
&nbsp;    @Documented
&nbsp;    @Target({ElementType.METHOD})
&nbsp;    @Retention(RetentionPolicy.RUNTIME)
&nbsp;    public @interface IsConstructor {
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    @Documented</b>
&nbsp;    @Target({ElementType.METHOD})
&nbsp;    @Retention(RetentionPolicy.RUNTIME)
&nbsp;    public @interface IsStatic {
&nbsp;    }
<b class="fc">&nbsp;</b>
&nbsp;    @Documented
&nbsp;    @Target({ElementType.TYPE, ElementType.METHOD, ElementType.PARAMETER})
&nbsp;    @Retention(RetentionPolicy.RUNTIME)
&nbsp;    public @interface Proxied {
&nbsp;        String value();
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-22 12:48</div>
</div>
</body>
</html>
