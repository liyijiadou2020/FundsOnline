


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=GBK"> 
  <title>Coverage Report > DynamicType</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.dynamic</a>
</div>

<h1>Coverage Summary for Class: DynamicType (net.bytebuddy.dynamic)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
  <tr>
    <td class="name">DynamicType$Builder$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (19/19)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$AbstractBase$Adapter</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (26/26)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$AbstractBase$Adapter$FieldDefinitionAdapter</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (8/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$AbstractBase$Adapter$MethodDefinitionAdapter</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$AbstractBase$Adapter$MethodDefinitionAdapter$AnnotationAdapter</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$AbstractBase$Adapter$MethodDefinitionAdapter$SimpleParameterAnnotationAdapter</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (11/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$AbstractBase$Adapter$MethodMatchAdapter</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$AbstractBase$Adapter$MethodMatchAdapter$AnnotationAdapter</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$AbstractBase$Adapter$OptionalMethodMatchAdapter</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$AbstractBase$Delegator</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$FieldDefinition$Optional$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$FieldDefinition$Optional$Valuable$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$FieldDefinition$Optional$Valuable$AbstractBase$Adapter</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$MethodDefinition$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$MethodDefinition$AbstractBase$Adapter</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$MethodDefinition$ExceptionDefinition$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$MethodDefinition$ImplementationDefinition$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$MethodDefinition$ParameterDefinition$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$MethodDefinition$ParameterDefinition$Initial$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$MethodDefinition$ParameterDefinition$Simple$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$MethodDefinition$ParameterDefinition$Simple$Annotatable$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$MethodDefinition$ParameterDefinition$Simple$Annotatable$AbstractBase$Adapter</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$MethodDefinition$ReceiverTypeDefinition$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$MethodDefinition$TypeVariableDefinition$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Default</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (18/18)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Default$Loaded</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Default$Unloaded</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (20/20)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (157/157)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;//
&nbsp;// Source code recreated from a .class file by IntelliJ IDEA
&nbsp;// (powered by FernFlower decompiler)
&nbsp;//
&nbsp;
&nbsp;package net.bytebuddy.dynamic;
&nbsp;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import java.io.File;
&nbsp;import java.io.FileInputStream;
&nbsp;import java.io.FileOutputStream;
&nbsp;import java.io.IOException;
&nbsp;import java.io.OutputStream;
&nbsp;import java.lang.annotation.Annotation;
&nbsp;import java.lang.reflect.AnnotatedElement;
&nbsp;import java.lang.reflect.Constructor;
&nbsp;import java.lang.reflect.Field;
&nbsp;import java.lang.reflect.Method;
&nbsp;import java.lang.reflect.Type;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Collection;
&nbsp;import java.util.Collections;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.Iterator;
&nbsp;import java.util.LinkedHashMap;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.jar.JarEntry;
&nbsp;import java.util.jar.JarInputStream;
&nbsp;import java.util.jar.JarOutputStream;
&nbsp;import java.util.jar.Manifest;
&nbsp;import java.util.jar.Attributes.Name;
&nbsp;import javax.annotation.Nonnull;
&nbsp;import javax.annotation.meta.When;
&nbsp;import net.bytebuddy.ClassFileVersion;
&nbsp;import net.bytebuddy.asm.AsmVisitorWrapper;
&nbsp;import net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance;
&nbsp;import net.bytebuddy.build.HashCodeAndEqualsPlugin.ValueHandling;
&nbsp;import net.bytebuddy.description.annotation.AnnotationDescription;
&nbsp;import net.bytebuddy.description.annotation.AnnotationList;
&nbsp;import net.bytebuddy.description.annotation.AnnotationValue;
&nbsp;import net.bytebuddy.description.annotation.AnnotationDescription.ForLoadedAnnotation;
&nbsp;import net.bytebuddy.description.field.FieldDescription;
&nbsp;import net.bytebuddy.description.method.MethodDescription;
&nbsp;import net.bytebuddy.description.method.ParameterDescription;
&nbsp;import net.bytebuddy.description.method.ParameterList;
&nbsp;import net.bytebuddy.description.modifier.FieldManifestation;
&nbsp;import net.bytebuddy.description.modifier.MethodManifestation;
&nbsp;import net.bytebuddy.description.modifier.ModifierContributor;
&nbsp;import net.bytebuddy.description.modifier.Ownership;
&nbsp;import net.bytebuddy.description.modifier.Visibility;
&nbsp;import net.bytebuddy.description.modifier.ModifierContributor.Resolver;
&nbsp;import net.bytebuddy.description.type.RecordComponentDescription;
&nbsp;import net.bytebuddy.description.type.TypeDefinition;
&nbsp;import net.bytebuddy.description.type.TypeDescription;
&nbsp;import net.bytebuddy.description.type.TypeList;
&nbsp;import net.bytebuddy.description.type.TypeVariableToken;
&nbsp;import net.bytebuddy.description.type.TypeDefinition.Sort;
&nbsp;import net.bytebuddy.description.type.TypeDescription.ForLoadedType;
&nbsp;import net.bytebuddy.description.type.TypeDescription.Generic;
&nbsp;import net.bytebuddy.dynamic.TypeResolutionStrategy.Passive;
&nbsp;import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;
&nbsp;import net.bytebuddy.dynamic.loading.InjectionClassLoader;
&nbsp;import net.bytebuddy.dynamic.loading.ClassLoadingStrategy.ForPreloadedTypes;
&nbsp;import net.bytebuddy.dynamic.loading.InjectionClassLoader.Strategy;
&nbsp;import net.bytebuddy.dynamic.scaffold.ClassWriterStrategy;
&nbsp;import net.bytebuddy.dynamic.scaffold.FieldRegistry;
&nbsp;import net.bytebuddy.dynamic.scaffold.InstrumentedType;
&nbsp;import net.bytebuddy.dynamic.scaffold.MethodGraph;
&nbsp;import net.bytebuddy.dynamic.scaffold.MethodRegistry;
&nbsp;import net.bytebuddy.dynamic.scaffold.RecordComponentRegistry;
&nbsp;import net.bytebuddy.dynamic.scaffold.TypeValidation;
&nbsp;import net.bytebuddy.dynamic.scaffold.MethodRegistry.Handler.ForAbstractMethod;
&nbsp;import net.bytebuddy.implementation.EqualsMethod;
&nbsp;import net.bytebuddy.implementation.FieldAccessor;
&nbsp;import net.bytebuddy.implementation.HashCodeMethod;
&nbsp;import net.bytebuddy.implementation.Implementation;
&nbsp;import net.bytebuddy.implementation.LoadedTypeInitializer;
&nbsp;import net.bytebuddy.implementation.ToStringMethod;
&nbsp;import net.bytebuddy.implementation.LoadedTypeInitializer.NoOp;
&nbsp;import net.bytebuddy.implementation.attribute.AnnotationRetention;
&nbsp;import net.bytebuddy.implementation.attribute.AnnotationValueFilter;
&nbsp;import net.bytebuddy.implementation.attribute.FieldAttributeAppender;
&nbsp;import net.bytebuddy.implementation.attribute.MethodAttributeAppender;
&nbsp;import net.bytebuddy.implementation.attribute.RecordComponentAttributeAppender;
&nbsp;import net.bytebuddy.implementation.attribute.TypeAttributeAppender;
&nbsp;import net.bytebuddy.implementation.attribute.FieldAttributeAppender.ForInstrumentedField;
&nbsp;import net.bytebuddy.implementation.attribute.MethodAttributeAppender.ForInstrumentedMethod;
&nbsp;import net.bytebuddy.implementation.attribute.RecordComponentAttributeAppender.ForInstrumentedRecordComponent;
&nbsp;import net.bytebuddy.implementation.auxiliary.AuxiliaryType;
&nbsp;import net.bytebuddy.implementation.bytecode.ByteCodeAppender;
&nbsp;import net.bytebuddy.matcher.ElementMatcher;
&nbsp;import net.bytebuddy.matcher.ElementMatchers;
&nbsp;import net.bytebuddy.matcher.LatentMatcher;
&nbsp;import net.bytebuddy.pool.TypePool;
&nbsp;import net.bytebuddy.utility.CompoundList;
&nbsp;import net.bytebuddy.utility.FileSystem;
&nbsp;import net.bytebuddy.utility.GraalImageCode;
&nbsp;
&nbsp;public interface DynamicType {
&nbsp;    TypeDescription getTypeDescription();
&nbsp;
&nbsp;    byte[] getBytes();
&nbsp;
&nbsp;    Map&lt;TypeDescription, byte[]&gt; getAuxiliaryTypes();
&nbsp;
&nbsp;    Map&lt;TypeDescription, byte[]&gt; getAllTypes();
&nbsp;
&nbsp;    Map&lt;TypeDescription, LoadedTypeInitializer&gt; getLoadedTypeInitializers();
&nbsp;
&nbsp;    boolean hasAliveLoadedTypeInitializers();
&nbsp;
&nbsp;    Map&lt;TypeDescription, File&gt; saveIn(File var1) throws IOException;
&nbsp;
&nbsp;    File inject(File var1, File var2) throws IOException;
&nbsp;
&nbsp;    File inject(File var1) throws IOException;
&nbsp;
&nbsp;    File toJar(File var1) throws IOException;
&nbsp;
&nbsp;    File toJar(File var1, Manifest var2) throws IOException;
&nbsp;
&nbsp;    @Enhance
&nbsp;    public static class Default implements DynamicType {
&nbsp;        private static final String CLASS_FILE_EXTENSION = &quot;.class&quot;;
&nbsp;        private static final String MANIFEST_VERSION = &quot;1.0&quot;;
&nbsp;        private static final int BUFFER_SIZE = 1024;
&nbsp;        private static final int FROM_BEGINNING = 0;
&nbsp;        private static final int END_OF_FILE = -1;
&nbsp;        private static final String TEMP_SUFFIX = &quot;tmp&quot;;
&nbsp;        protected final TypeDescription typeDescription;
&nbsp;        protected final byte[] binaryRepresentation;
&nbsp;        protected final LoadedTypeInitializer loadedTypeInitializer;
&nbsp;        protected final List&lt;? extends DynamicType&gt; auxiliaryTypes;
&nbsp;
&nbsp;        @SuppressFBWarnings(
&nbsp;            value = {&quot;EI_EXPOSE_REP2&quot;},
&nbsp;            justification = &quot;The array is not modified by class contract.&quot;
&nbsp;        )
&nbsp;        public Default(TypeDescription typeDescription, byte[] binaryRepresentation, LoadedTypeInitializer loadedTypeInitializer, List&lt;? extends DynamicType&gt; auxiliaryTypes) {
&nbsp;            this.typeDescription = typeDescription;
&nbsp;            this.binaryRepresentation = binaryRepresentation;
&nbsp;            this.loadedTypeInitializer = loadedTypeInitializer;
&nbsp;            this.auxiliaryTypes = auxiliaryTypes;
&nbsp;        }
&nbsp;
&nbsp;        public TypeDescription getTypeDescription() {
&nbsp;            return this.typeDescription;
&nbsp;        }
&nbsp;
&nbsp;        public Map&lt;TypeDescription, byte[]&gt; getAllTypes() {
&nbsp;            Map&lt;TypeDescription, byte[]&gt; allTypes = new LinkedHashMap();
&nbsp;            allTypes.put(this.typeDescription, this.binaryRepresentation);
&nbsp;            Iterator var2 = this.auxiliaryTypes.iterator();
&nbsp;
&nbsp;            while(var2.hasNext()) {
&nbsp;                DynamicType auxiliaryType = (DynamicType)var2.next();
&nbsp;                allTypes.putAll(auxiliaryType.getAllTypes());
&nbsp;            }
&nbsp;
&nbsp;            return allTypes;
&nbsp;        }
&nbsp;
&nbsp;        public Map&lt;TypeDescription, LoadedTypeInitializer&gt; getLoadedTypeInitializers() {
&nbsp;            Map&lt;TypeDescription, LoadedTypeInitializer&gt; classLoadingCallbacks = new HashMap();
&nbsp;            Iterator var2 = this.auxiliaryTypes.iterator();
&nbsp;
&nbsp;            while(var2.hasNext()) {
&nbsp;                DynamicType auxiliaryType = (DynamicType)var2.next();
&nbsp;                classLoadingCallbacks.putAll(auxiliaryType.getLoadedTypeInitializers());
&nbsp;            }
&nbsp;
&nbsp;            classLoadingCallbacks.put(this.typeDescription, this.loadedTypeInitializer);
&nbsp;            return classLoadingCallbacks;
&nbsp;        }
&nbsp;
&nbsp;        public boolean hasAliveLoadedTypeInitializers() {
&nbsp;            Iterator var1 = this.getLoadedTypeInitializers().values().iterator();
&nbsp;
&nbsp;            LoadedTypeInitializer loadedTypeInitializer;
&nbsp;            do {
&nbsp;                if (!var1.hasNext()) {
&nbsp;                    return false;
&nbsp;                }
&nbsp;
&nbsp;                loadedTypeInitializer = (LoadedTypeInitializer)var1.next();
&nbsp;            } while(!loadedTypeInitializer.isAlive());
&nbsp;
&nbsp;            return true;
&nbsp;        }
&nbsp;
&nbsp;        @SuppressFBWarnings(
&nbsp;            value = {&quot;EI_EXPOSE_REP&quot;},
&nbsp;            justification = &quot;The array is not modified by class contract.&quot;
&nbsp;        )
&nbsp;        public byte[] getBytes() {
&nbsp;            return this.binaryRepresentation;
&nbsp;        }
&nbsp;
&nbsp;        public Map&lt;TypeDescription, byte[]&gt; getAuxiliaryTypes() {
&nbsp;            Map&lt;TypeDescription, byte[]&gt; auxiliaryTypes = new HashMap();
&nbsp;            Iterator var2 = this.auxiliaryTypes.iterator();
&nbsp;
&nbsp;            while(var2.hasNext()) {
&nbsp;                DynamicType auxiliaryType = (DynamicType)var2.next();
&nbsp;                auxiliaryTypes.put(auxiliaryType.getTypeDescription(), auxiliaryType.getBytes());
&nbsp;                auxiliaryTypes.putAll(auxiliaryType.getAuxiliaryTypes());
&nbsp;            }
&nbsp;
&nbsp;            return auxiliaryTypes;
&nbsp;        }
&nbsp;
&nbsp;        public Map&lt;TypeDescription, File&gt; saveIn(File folder) throws IOException {
&nbsp;            Map&lt;TypeDescription, File&gt; files = new HashMap();
&nbsp;            File target = new File(folder, this.typeDescription.getName().replace(&#39;.&#39;, File.separatorChar) + &quot;.class&quot;);
&nbsp;            if (target.getParentFile() != null &amp;&amp; !target.getParentFile().isDirectory() &amp;&amp; !target.getParentFile().mkdirs()) {
&nbsp;                throw new IllegalArgumentException(&quot;Could not create directory: &quot; + target.getParentFile());
&nbsp;            } else {
&nbsp;                OutputStream outputStream = new FileOutputStream(target);
&nbsp;
&nbsp;                try {
&nbsp;                    outputStream.write(this.binaryRepresentation);
&nbsp;                } finally {
&nbsp;                    outputStream.close();
&nbsp;                }
&nbsp;
&nbsp;                files.put(this.typeDescription, target);
&nbsp;                Iterator var5 = this.auxiliaryTypes.iterator();
&nbsp;
&nbsp;                while(var5.hasNext()) {
&nbsp;                    DynamicType auxiliaryType = (DynamicType)var5.next();
&nbsp;                    files.putAll(auxiliaryType.saveIn(folder));
&nbsp;                }
&nbsp;
&nbsp;                return files;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public File inject(File sourceJar, File targetJar) throws IOException {
&nbsp;            return sourceJar.equals(targetJar) ? this.inject(sourceJar) : this.doInject(sourceJar, targetJar);
&nbsp;        }
&nbsp;
&nbsp;        public File inject(File jar) throws IOException {
&nbsp;            FileSystem.getInstance().move(this.doInject(jar, File.createTempFile(jar.getName(), &quot;tmp&quot;)), jar);
&nbsp;            return jar;
&nbsp;        }
&nbsp;
&nbsp;        private File doInject(File sourceJar, File targetJar) throws IOException {
&nbsp;            JarInputStream inputStream = new JarInputStream(new FileInputStream(sourceJar));
&nbsp;
&nbsp;            try {
&nbsp;                if (!targetJar.isFile() &amp;&amp; !targetJar.createNewFile()) {
&nbsp;                    throw new IllegalArgumentException(&quot;Could not create file: &quot; + targetJar);
&nbsp;                } else {
&nbsp;                    Manifest manifest = inputStream.getManifest();
&nbsp;                    JarOutputStream outputStream = manifest == null ? new JarOutputStream(new FileOutputStream(targetJar)) : new JarOutputStream(new FileOutputStream(targetJar), manifest);
&nbsp;
&nbsp;                    try {
&nbsp;                        Map&lt;TypeDescription, byte[]&gt; rawAuxiliaryTypes = this.getAuxiliaryTypes();
&nbsp;                        Map&lt;String, byte[]&gt; files = new HashMap();
&nbsp;                        Iterator var8 = rawAuxiliaryTypes.entrySet().iterator();
&nbsp;
&nbsp;                        while(var8.hasNext()) {
&nbsp;                            Map.Entry&lt;TypeDescription, byte[]&gt; entry = (Map.Entry)var8.next();
&nbsp;                            files.put(((TypeDescription)entry.getKey()).getInternalName() + &quot;.class&quot;, entry.getValue());
&nbsp;                        }
&nbsp;
&nbsp;                        files.put(this.typeDescription.getInternalName() + &quot;.class&quot;, this.binaryRepresentation);
&nbsp;
&nbsp;                        JarEntry jarEntry;
&nbsp;                        while((jarEntry = inputStream.getNextJarEntry()) != null) {
&nbsp;                            byte[] replacement = (byte[])files.remove(jarEntry.getName());
&nbsp;                            if (replacement == null) {
&nbsp;                                outputStream.putNextEntry(jarEntry);
&nbsp;                                byte[] buffer = new byte[1024];
&nbsp;
&nbsp;                                int index;
&nbsp;                                while((index = inputStream.read(buffer)) != -1) {
&nbsp;                                    outputStream.write(buffer, 0, index);
&nbsp;                                }
&nbsp;                            } else {
&nbsp;                                outputStream.putNextEntry(new JarEntry(jarEntry.getName()));
&nbsp;                                outputStream.write(replacement);
&nbsp;                            }
&nbsp;
&nbsp;                            inputStream.closeEntry();
&nbsp;                            outputStream.closeEntry();
&nbsp;                        }
&nbsp;
&nbsp;                        Iterator var22 = files.entrySet().iterator();
&nbsp;
&nbsp;                        while(var22.hasNext()) {
&nbsp;                            Map.Entry&lt;String, byte[]&gt; entry = (Map.Entry)var22.next();
&nbsp;                            outputStream.putNextEntry(new JarEntry((String)entry.getKey()));
&nbsp;                            outputStream.write((byte[])entry.getValue());
&nbsp;                            outputStream.closeEntry();
&nbsp;                        }
&nbsp;
&nbsp;                        return targetJar;
&nbsp;                    } finally {
&nbsp;                        outputStream.close();
&nbsp;                    }
&nbsp;                }
&nbsp;            } finally {
&nbsp;                inputStream.close();
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public File toJar(File file) throws IOException {
&nbsp;            Manifest manifest = new Manifest();
&nbsp;            manifest.getMainAttributes().put(Name.MANIFEST_VERSION, &quot;1.0&quot;);
&nbsp;            return this.toJar(file, manifest);
&nbsp;        }
&nbsp;
&nbsp;        public File toJar(File file, Manifest manifest) throws IOException {
&nbsp;            if (!file.isFile() &amp;&amp; !file.createNewFile()) {
&nbsp;                throw new IllegalArgumentException(&quot;Could not create file: &quot; + file);
&nbsp;            } else {
&nbsp;                JarOutputStream outputStream = new JarOutputStream(new FileOutputStream(file), manifest);
&nbsp;
&nbsp;                try {
&nbsp;                    Iterator var4 = this.getAuxiliaryTypes().entrySet().iterator();
&nbsp;
&nbsp;                    while(var4.hasNext()) {
&nbsp;                        Map.Entry&lt;TypeDescription, byte[]&gt; entry = (Map.Entry)var4.next();
&nbsp;                        outputStream.putNextEntry(new JarEntry(((TypeDescription)entry.getKey()).getInternalName() + &quot;.class&quot;));
&nbsp;                        outputStream.write((byte[])entry.getValue());
&nbsp;                        outputStream.closeEntry();
&nbsp;                    }
&nbsp;
&nbsp;                    outputStream.putNextEntry(new JarEntry(this.typeDescription.getInternalName() + &quot;.class&quot;));
&nbsp;                    outputStream.write(this.binaryRepresentation);
&nbsp;                    outputStream.closeEntry();
&nbsp;                    return file;
&nbsp;                } finally {
&nbsp;                    outputStream.close();
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public boolean equals(Object var1) {
&nbsp;            if (this == var1) {
&nbsp;                return true;
&nbsp;            } else if (var1 == null) {
&nbsp;                return false;
&nbsp;            } else if (this.getClass() != var1.getClass()) {
&nbsp;                return false;
&nbsp;            } else if (!this.typeDescription.equals(((Default)var1).typeDescription)) {
&nbsp;                return false;
&nbsp;            } else if (!Arrays.equals(this.binaryRepresentation, ((Default)var1).binaryRepresentation)) {
&nbsp;                return false;
&nbsp;            } else if (!this.loadedTypeInitializer.equals(((Default)var1).loadedTypeInitializer)) {
&nbsp;                return false;
&nbsp;            } else {
&nbsp;                return this.auxiliaryTypes.equals(((Default)var1).auxiliaryTypes);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public int hashCode() {
&nbsp;            return (((this.getClass().hashCode() * 31 + this.typeDescription.hashCode()) * 31 + Arrays.hashCode(this.binaryRepresentation)) * 31 + this.loadedTypeInitializer.hashCode()) * 31 + this.auxiliaryTypes.hashCode();
&nbsp;        }
&nbsp;
&nbsp;        @Enhance
&nbsp;        protected static class Loaded&lt;T&gt; extends Default implements Loaded&lt;T&gt; {
&nbsp;            private final Map&lt;TypeDescription, Class&lt;?&gt;&gt; loadedTypes;
&nbsp;
&nbsp;            protected Loaded(TypeDescription typeDescription, byte[] typeByte, LoadedTypeInitializer loadedTypeInitializer, List&lt;? extends DynamicType&gt; auxiliaryTypes, Map&lt;TypeDescription, Class&lt;?&gt;&gt; loadedTypes) {
&nbsp;                super(typeDescription, typeByte, loadedTypeInitializer, auxiliaryTypes);
&nbsp;                this.loadedTypes = loadedTypes;
&nbsp;            }
&nbsp;
&nbsp;            public Class&lt;? extends T&gt; getLoaded() {
&nbsp;                return (Class)this.loadedTypes.get(this.typeDescription);
&nbsp;            }
&nbsp;
&nbsp;            public Map&lt;TypeDescription, Class&lt;?&gt;&gt; getLoadedAuxiliaryTypes() {
&nbsp;                Map&lt;TypeDescription, Class&lt;?&gt;&gt; loadedAuxiliaryTypes = new HashMap(this.loadedTypes);
&nbsp;                loadedAuxiliaryTypes.remove(this.typeDescription);
&nbsp;                return loadedAuxiliaryTypes;
&nbsp;            }
&nbsp;
&nbsp;            public Map&lt;TypeDescription, Class&lt;?&gt;&gt; getAllLoaded() {
&nbsp;                return new HashMap(this.loadedTypes);
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(Object var1) {
&nbsp;                if (!super.equals(var1)) {
&nbsp;                    return false;
&nbsp;                } else if (this == var1) {
&nbsp;                    return true;
&nbsp;                } else if (var1 == null) {
&nbsp;                    return false;
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return this.loadedTypes.equals(((Loaded)var1).loadedTypes);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public int hashCode() {
&nbsp;                return super.hashCode() * 31 + this.loadedTypes.hashCode();
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Enhance
&nbsp;        public static class Unloaded&lt;T&gt; extends Default implements Unloaded&lt;T&gt; {
&nbsp;            private final TypeResolutionStrategy.Resolved typeResolutionStrategy;
&nbsp;
&nbsp;            public Unloaded(TypeDescription typeDescription, byte[] binaryRepresentation, LoadedTypeInitializer loadedTypeInitializer, List&lt;? extends DynamicType&gt; auxiliaryTypes, TypeResolutionStrategy.Resolved typeResolutionStrategy) {
&nbsp;                super(typeDescription, binaryRepresentation, loadedTypeInitializer, auxiliaryTypes);
&nbsp;                this.typeResolutionStrategy = typeResolutionStrategy;
&nbsp;            }
&nbsp;
&nbsp;            public Loaded&lt;T&gt; load(@Nonnull(when = When.MAYBE) ClassLoader classLoader) {
&nbsp;                if (GraalImageCode.getCurrent().isNativeImageExecution()) {
&nbsp;                    return this.load(classLoader, ForPreloadedTypes.INSTANCE);
&nbsp;                } else {
&nbsp;                    return classLoader instanceof InjectionClassLoader &amp;&amp; !((InjectionClassLoader)classLoader).isSealed() ? this.load((InjectionClassLoader)classLoader, Strategy.INSTANCE) : this.load(classLoader, net.bytebuddy.dynamic.loading.ClassLoadingStrategy.Default.WRAPPER);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public &lt;S extends ClassLoader&gt; Loaded&lt;T&gt; load(@Nonnull(when = When.MAYBE) S classLoader, ClassLoadingStrategy&lt;? super S&gt; classLoadingStrategy) {
&nbsp;                return new Loaded(this.typeDescription, this.binaryRepresentation, this.loadedTypeInitializer, this.auxiliaryTypes, this.typeResolutionStrategy.initialize(this, classLoader, classLoadingStrategy));
&nbsp;            }
&nbsp;
&nbsp;            public Unloaded&lt;T&gt; include(DynamicType... dynamicType) {
&nbsp;                return this.include(Arrays.asList(dynamicType));
&nbsp;            }
&nbsp;
&nbsp;            public Unloaded&lt;T&gt; include(List&lt;? extends DynamicType&gt; dynamicType) {
&nbsp;                return new Unloaded(this.typeDescription, this.binaryRepresentation, this.loadedTypeInitializer, CompoundList.of(this.auxiliaryTypes, dynamicType), this.typeResolutionStrategy);
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(Object var1) {
&nbsp;                if (!super.equals(var1)) {
&nbsp;                    return false;
&nbsp;                } else if (this == var1) {
&nbsp;                    return true;
&nbsp;                } else if (var1 == null) {
&nbsp;                    return false;
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return this.typeResolutionStrategy.equals(((Unloaded)var1).typeResolutionStrategy);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public int hashCode() {
&nbsp;                return super.hashCode() * 31 + this.typeResolutionStrategy.hashCode();
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public interface Loaded&lt;T&gt; extends DynamicType {
&nbsp;        Class&lt;? extends T&gt; getLoaded();
&nbsp;
&nbsp;        Map&lt;TypeDescription, Class&lt;?&gt;&gt; getLoadedAuxiliaryTypes();
&nbsp;
&nbsp;        Map&lt;TypeDescription, Class&lt;?&gt;&gt; getAllLoaded();
&nbsp;    }
&nbsp;
&nbsp;    public interface Unloaded&lt;T&gt; extends DynamicType {
&nbsp;        Loaded&lt;T&gt; load(@Nonnull(when = When.MAYBE) ClassLoader var1);
&nbsp;
&nbsp;        &lt;S extends ClassLoader&gt; Loaded&lt;T&gt; load(@Nonnull(when = When.MAYBE) S var1, ClassLoadingStrategy&lt;? super S&gt; var2);
&nbsp;
&nbsp;        Unloaded&lt;T&gt; include(DynamicType... var1);
&nbsp;
&nbsp;        Unloaded&lt;T&gt; include(List&lt;? extends DynamicType&gt; var1);
&nbsp;    }
&nbsp;
&nbsp;    public interface Builder&lt;T&gt; {
&nbsp;        Builder&lt;T&gt; visit(AsmVisitorWrapper var1);
&nbsp;
&nbsp;        Builder&lt;T&gt; name(String var1);
&nbsp;
&nbsp;        Builder&lt;T&gt; suffix(String var1);
&nbsp;
&nbsp;        Builder&lt;T&gt; modifiers(ModifierContributor.ForType... var1);
&nbsp;
&nbsp;        Builder&lt;T&gt; modifiers(Collection&lt;? extends ModifierContributor.ForType&gt; var1);
&nbsp;
&nbsp;        Builder&lt;T&gt; modifiers(int var1);
&nbsp;
&nbsp;        Builder&lt;T&gt; merge(ModifierContributor.ForType... var1);
&nbsp;
&nbsp;        Builder&lt;T&gt; merge(Collection&lt;? extends ModifierContributor.ForType&gt; var1);
&nbsp;
&nbsp;        Builder&lt;T&gt; topLevelType();
&nbsp;
&nbsp;        InnerTypeDefinition.ForType&lt;T&gt; innerTypeOf(Class&lt;?&gt; var1);
&nbsp;
&nbsp;        InnerTypeDefinition.ForType&lt;T&gt; innerTypeOf(TypeDescription var1);
&nbsp;
&nbsp;        InnerTypeDefinition&lt;T&gt; innerTypeOf(Method var1);
&nbsp;
&nbsp;        InnerTypeDefinition&lt;T&gt; innerTypeOf(Constructor&lt;?&gt; var1);
&nbsp;
&nbsp;        InnerTypeDefinition&lt;T&gt; innerTypeOf(MethodDescription.InDefinedShape var1);
&nbsp;
&nbsp;        Builder&lt;T&gt; declaredTypes(Class&lt;?&gt;... var1);
&nbsp;
&nbsp;        Builder&lt;T&gt; declaredTypes(TypeDescription... var1);
&nbsp;
&nbsp;        Builder&lt;T&gt; declaredTypes(List&lt;? extends Class&lt;?&gt;&gt; var1);
&nbsp;
&nbsp;        Builder&lt;T&gt; declaredTypes(Collection&lt;? extends TypeDescription&gt; var1);
&nbsp;
&nbsp;        Builder&lt;T&gt; noNestMate();
&nbsp;
&nbsp;        Builder&lt;T&gt; nestHost(Class&lt;?&gt; var1);
&nbsp;
&nbsp;        Builder&lt;T&gt; nestHost(TypeDescription var1);
&nbsp;
&nbsp;        Builder&lt;T&gt; nestMembers(Class&lt;?&gt;... var1);
&nbsp;
&nbsp;        Builder&lt;T&gt; nestMembers(TypeDescription... var1);
&nbsp;
&nbsp;        Builder&lt;T&gt; nestMembers(List&lt;? extends Class&lt;?&gt;&gt; var1);
&nbsp;
&nbsp;        Builder&lt;T&gt; nestMembers(Collection&lt;? extends TypeDescription&gt; var1);
&nbsp;
&nbsp;        Builder&lt;T&gt; permittedSubclass(Class&lt;?&gt;... var1);
&nbsp;
&nbsp;        Builder&lt;T&gt; permittedSubclass(TypeDescription... var1);
&nbsp;
&nbsp;        Builder&lt;T&gt; permittedSubclass(List&lt;? extends Class&lt;?&gt;&gt; var1);
&nbsp;
&nbsp;        Builder&lt;T&gt; permittedSubclass(Collection&lt;? extends TypeDescription&gt; var1);
&nbsp;
&nbsp;        Builder&lt;T&gt; unsealed();
&nbsp;
&nbsp;        Builder&lt;T&gt; attribute(TypeAttributeAppender var1);
&nbsp;
&nbsp;        Builder&lt;T&gt; annotateType(Annotation... var1);
&nbsp;
&nbsp;        Builder&lt;T&gt; annotateType(List&lt;? extends Annotation&gt; var1);
&nbsp;
&nbsp;        Builder&lt;T&gt; annotateType(AnnotationDescription... var1);
&nbsp;
&nbsp;        Builder&lt;T&gt; annotateType(Collection&lt;? extends AnnotationDescription&gt; var1);
&nbsp;
&nbsp;        MethodDefinition.ImplementationDefinition.Optional&lt;T&gt; implement(Type... var1);
&nbsp;
&nbsp;        MethodDefinition.ImplementationDefinition.Optional&lt;T&gt; implement(List&lt;? extends Type&gt; var1);
&nbsp;
&nbsp;        MethodDefinition.ImplementationDefinition.Optional&lt;T&gt; implement(TypeDefinition... var1);
&nbsp;
&nbsp;        MethodDefinition.ImplementationDefinition.Optional&lt;T&gt; implement(Collection&lt;? extends TypeDefinition&gt; var1);
&nbsp;
&nbsp;        Builder&lt;T&gt; initializer(ByteCodeAppender var1);
&nbsp;
&nbsp;        Builder&lt;T&gt; initializer(LoadedTypeInitializer var1);
&nbsp;
&nbsp;        Builder&lt;T&gt; require(TypeDescription var1, byte[] var2);
&nbsp;
&nbsp;        Builder&lt;T&gt; require(TypeDescription var1, byte[] var2, LoadedTypeInitializer var3);
&nbsp;
&nbsp;        Builder&lt;T&gt; require(DynamicType... var1);
&nbsp;
&nbsp;        Builder&lt;T&gt; require(Collection&lt;DynamicType&gt; var1);
&nbsp;
&nbsp;        TypeVariableDefinition&lt;T&gt; typeVariable(String var1);
&nbsp;
&nbsp;        TypeVariableDefinition&lt;T&gt; typeVariable(String var1, Type... var2);
&nbsp;
&nbsp;        TypeVariableDefinition&lt;T&gt; typeVariable(String var1, List&lt;? extends Type&gt; var2);
&nbsp;
&nbsp;        TypeVariableDefinition&lt;T&gt; typeVariable(String var1, TypeDefinition... var2);
&nbsp;
&nbsp;        TypeVariableDefinition&lt;T&gt; typeVariable(String var1, Collection&lt;? extends TypeDefinition&gt; var2);
&nbsp;
&nbsp;        Builder&lt;T&gt; transform(ElementMatcher&lt;? super TypeDescription.Generic&gt; var1, Transformer&lt;TypeVariableToken&gt; var2);
&nbsp;
&nbsp;        FieldDefinition.Optional.Valuable&lt;T&gt; defineField(String var1, Type var2, ModifierContributor.ForField... var3);
&nbsp;
&nbsp;        FieldDefinition.Optional.Valuable&lt;T&gt; defineField(String var1, Type var2, Collection&lt;? extends ModifierContributor.ForField&gt; var3);
&nbsp;
&nbsp;        FieldDefinition.Optional.Valuable&lt;T&gt; defineField(String var1, Type var2, int var3);
&nbsp;
&nbsp;        FieldDefinition.Optional.Valuable&lt;T&gt; defineField(String var1, TypeDefinition var2, ModifierContributor.ForField... var3);
&nbsp;
&nbsp;        FieldDefinition.Optional.Valuable&lt;T&gt; defineField(String var1, TypeDefinition var2, Collection&lt;? extends ModifierContributor.ForField&gt; var3);
&nbsp;
&nbsp;        FieldDefinition.Optional.Valuable&lt;T&gt; defineField(String var1, TypeDefinition var2, int var3);
&nbsp;
&nbsp;        FieldDefinition.Optional.Valuable&lt;T&gt; define(Field var1);
&nbsp;
&nbsp;        FieldDefinition.Optional.Valuable&lt;T&gt; define(FieldDescription var1);
&nbsp;
&nbsp;        FieldDefinition.Optional&lt;T&gt; serialVersionUid(long var1);
&nbsp;
&nbsp;        FieldDefinition.Valuable&lt;T&gt; field(ElementMatcher&lt;? super FieldDescription&gt; var1);
&nbsp;
&nbsp;        FieldDefinition.Valuable&lt;T&gt; field(LatentMatcher&lt;? super FieldDescription&gt; var1);
&nbsp;
&nbsp;        Builder&lt;T&gt; ignoreAlso(ElementMatcher&lt;? super MethodDescription&gt; var1);
&nbsp;
&nbsp;        Builder&lt;T&gt; ignoreAlso(LatentMatcher&lt;? super MethodDescription&gt; var1);
&nbsp;
&nbsp;        MethodDefinition.ParameterDefinition.Initial&lt;T&gt; defineMethod(String var1, Type var2, ModifierContributor.ForMethod... var3);
&nbsp;
&nbsp;        MethodDefinition.ParameterDefinition.Initial&lt;T&gt; defineMethod(String var1, Type var2, Collection&lt;? extends ModifierContributor.ForMethod&gt; var3);
&nbsp;
&nbsp;        MethodDefinition.ParameterDefinition.Initial&lt;T&gt; defineMethod(String var1, Type var2, int var3);
&nbsp;
&nbsp;        MethodDefinition.ParameterDefinition.Initial&lt;T&gt; defineMethod(String var1, TypeDefinition var2, ModifierContributor.ForMethod... var3);
&nbsp;
&nbsp;        MethodDefinition.ParameterDefinition.Initial&lt;T&gt; defineMethod(String var1, TypeDefinition var2, Collection&lt;? extends ModifierContributor.ForMethod&gt; var3);
&nbsp;
&nbsp;        MethodDefinition.ParameterDefinition.Initial&lt;T&gt; defineMethod(String var1, TypeDefinition var2, int var3);
&nbsp;
&nbsp;        MethodDefinition.ParameterDefinition.Initial&lt;T&gt; defineConstructor(ModifierContributor.ForMethod... var1);
&nbsp;
&nbsp;        MethodDefinition.ParameterDefinition.Initial&lt;T&gt; defineConstructor(Collection&lt;? extends ModifierContributor.ForMethod&gt; var1);
&nbsp;
&nbsp;        MethodDefinition.ParameterDefinition.Initial&lt;T&gt; defineConstructor(int var1);
&nbsp;
&nbsp;        MethodDefinition.ImplementationDefinition&lt;T&gt; define(Method var1);
&nbsp;
&nbsp;        MethodDefinition.ImplementationDefinition&lt;T&gt; define(Constructor&lt;?&gt; var1);
&nbsp;
&nbsp;        MethodDefinition.ImplementationDefinition&lt;T&gt; define(MethodDescription var1);
&nbsp;
&nbsp;        FieldDefinition.Optional&lt;T&gt; defineProperty(String var1, Type var2);
&nbsp;
&nbsp;        FieldDefinition.Optional&lt;T&gt; defineProperty(String var1, Type var2, boolean var3);
&nbsp;
&nbsp;        FieldDefinition.Optional&lt;T&gt; defineProperty(String var1, TypeDefinition var2);
&nbsp;
&nbsp;        FieldDefinition.Optional&lt;T&gt; defineProperty(String var1, TypeDefinition var2, boolean var3);
&nbsp;
&nbsp;        MethodDefinition.ImplementationDefinition&lt;T&gt; method(ElementMatcher&lt;? super MethodDescription&gt; var1);
&nbsp;
&nbsp;        MethodDefinition.ImplementationDefinition&lt;T&gt; constructor(ElementMatcher&lt;? super MethodDescription&gt; var1);
&nbsp;
&nbsp;        MethodDefinition.ImplementationDefinition&lt;T&gt; invokable(ElementMatcher&lt;? super MethodDescription&gt; var1);
&nbsp;
&nbsp;        MethodDefinition.ImplementationDefinition&lt;T&gt; invokable(LatentMatcher&lt;? super MethodDescription&gt; var1);
&nbsp;
&nbsp;        Builder&lt;T&gt; withHashCodeEquals();
&nbsp;
&nbsp;        Builder&lt;T&gt; withToString();
&nbsp;
&nbsp;        RecordComponentDefinition.Optional&lt;T&gt; defineRecordComponent(String var1, Type var2);
&nbsp;
&nbsp;        RecordComponentDefinition.Optional&lt;T&gt; defineRecordComponent(String var1, TypeDefinition var2);
&nbsp;
&nbsp;        RecordComponentDefinition.Optional&lt;T&gt; define(RecordComponentDescription var1);
&nbsp;
&nbsp;        RecordComponentDefinition&lt;T&gt; recordComponent(ElementMatcher&lt;? super RecordComponentDescription&gt; var1);
&nbsp;
&nbsp;        RecordComponentDefinition&lt;T&gt; recordComponent(LatentMatcher&lt;? super RecordComponentDescription&gt; var1);
&nbsp;
&nbsp;        Unloaded&lt;T&gt; make();
&nbsp;
&nbsp;        Unloaded&lt;T&gt; make(TypeResolutionStrategy var1);
&nbsp;
&nbsp;        Unloaded&lt;T&gt; make(TypePool var1);
&nbsp;
&nbsp;        Unloaded&lt;T&gt; make(TypeResolutionStrategy var1, TypePool var2);
&nbsp;
&nbsp;        TypeDescription toTypeDescription();
&nbsp;
&nbsp;        public abstract static class AbstractBase&lt;S&gt; implements Builder&lt;S&gt; {
&nbsp;            public AbstractBase() {
&nbsp;            }
&nbsp;
&nbsp;            public InnerTypeDefinition.ForType&lt;S&gt; innerTypeOf(Class&lt;?&gt; type) {
&nbsp;                return this.innerTypeOf((TypeDescription)ForLoadedType.of(type));
&nbsp;            }
&nbsp;
&nbsp;            public InnerTypeDefinition&lt;S&gt; innerTypeOf(Method method) {
&nbsp;                return this.innerTypeOf((MethodDescription.InDefinedShape)(new MethodDescription.ForLoadedMethod(method)));
&nbsp;            }
&nbsp;
&nbsp;            public InnerTypeDefinition&lt;S&gt; innerTypeOf(Constructor&lt;?&gt; constructor) {
&nbsp;                return this.innerTypeOf((MethodDescription.InDefinedShape)(new MethodDescription.ForLoadedConstructor(constructor)));
&nbsp;            }
&nbsp;
&nbsp;            public Builder&lt;S&gt; declaredTypes(Class&lt;?&gt;... type) {
&nbsp;                return this.declaredTypes(Arrays.asList(type));
&nbsp;            }
&nbsp;
&nbsp;            public Builder&lt;S&gt; declaredTypes(TypeDescription... type) {
&nbsp;                return this.declaredTypes((Collection)Arrays.asList(type));
&nbsp;            }
&nbsp;
&nbsp;            public Builder&lt;S&gt; declaredTypes(List&lt;? extends Class&lt;?&gt;&gt; type) {
&nbsp;                return this.declaredTypes((Collection)(new TypeList.ForLoadedTypes(type)));
&nbsp;            }
&nbsp;
&nbsp;            public Builder&lt;S&gt; noNestMate() {
&nbsp;                return this.nestHost(TargetType.DESCRIPTION);
&nbsp;            }
&nbsp;
&nbsp;            public Builder&lt;S&gt; nestHost(Class&lt;?&gt; type) {
&nbsp;                return this.nestHost(ForLoadedType.of(type));
&nbsp;            }
&nbsp;
&nbsp;            public Builder&lt;S&gt; nestMembers(Class&lt;?&gt;... type) {
&nbsp;                return this.nestMembers(Arrays.asList(type));
&nbsp;            }
&nbsp;
&nbsp;            public Builder&lt;S&gt; nestMembers(TypeDescription... type) {
&nbsp;                return this.nestMembers((Collection)Arrays.asList(type));
&nbsp;            }
&nbsp;
&nbsp;            public Builder&lt;S&gt; nestMembers(List&lt;? extends Class&lt;?&gt;&gt; types) {
&nbsp;                return this.nestMembers((Collection)(new TypeList.ForLoadedTypes(types)));
&nbsp;            }
&nbsp;
&nbsp;            public Builder&lt;S&gt; permittedSubclass(Class&lt;?&gt;... type) {
&nbsp;                return this.permittedSubclass(Arrays.asList(type));
&nbsp;            }
&nbsp;
&nbsp;            public Builder&lt;S&gt; permittedSubclass(TypeDescription... type) {
&nbsp;                return this.permittedSubclass((Collection)Arrays.asList(type));
&nbsp;            }
&nbsp;
&nbsp;            public Builder&lt;S&gt; permittedSubclass(List&lt;? extends Class&lt;?&gt;&gt; types) {
&nbsp;                return this.permittedSubclass((Collection)(new TypeList.ForLoadedTypes(types)));
&nbsp;            }
&nbsp;
&nbsp;            public Builder&lt;S&gt; annotateType(Annotation... annotation) {
&nbsp;                return this.annotateType(Arrays.asList(annotation));
&nbsp;            }
&nbsp;
&nbsp;            public Builder&lt;S&gt; annotateType(List&lt;? extends Annotation&gt; annotations) {
&nbsp;                return this.annotateType((Collection)(new AnnotationList.ForLoadedAnnotations(annotations)));
&nbsp;            }
&nbsp;
&nbsp;            public Builder&lt;S&gt; annotateType(AnnotationDescription... annotation) {
&nbsp;                return this.annotateType((Collection)Arrays.asList(annotation));
&nbsp;            }
&nbsp;
&nbsp;            public Builder&lt;S&gt; modifiers(ModifierContributor.ForType... modifierContributor) {
&nbsp;                return this.modifiers((Collection)Arrays.asList(modifierContributor));
&nbsp;            }
&nbsp;
&nbsp;            public Builder&lt;S&gt; modifiers(Collection&lt;? extends ModifierContributor.ForType&gt; modifierContributors) {
&nbsp;                return this.modifiers(Resolver.of(modifierContributors).resolve());
&nbsp;            }
&nbsp;
&nbsp;            public Builder&lt;S&gt; merge(ModifierContributor.ForType... modifierContributor) {
&nbsp;                return this.merge(Arrays.asList(modifierContributor));
&nbsp;            }
&nbsp;
&nbsp;            public MethodDefinition.ImplementationDefinition.Optional&lt;S&gt; implement(Type... interfaceType) {
&nbsp;                return this.implement(Arrays.asList(interfaceType));
&nbsp;            }
&nbsp;
&nbsp;            public MethodDefinition.ImplementationDefinition.Optional&lt;S&gt; implement(List&lt;? extends Type&gt; interfaceTypes) {
&nbsp;                return this.implement((Collection)(new TypeList.Generic.ForLoadedTypes(interfaceTypes)));
&nbsp;            }
&nbsp;
&nbsp;            public MethodDefinition.ImplementationDefinition.Optional&lt;S&gt; implement(TypeDefinition... interfaceType) {
&nbsp;                return this.implement((Collection)Arrays.asList(interfaceType));
&nbsp;            }
&nbsp;
&nbsp;            public TypeVariableDefinition&lt;S&gt; typeVariable(String symbol) {
&nbsp;                return this.typeVariable(symbol, Generic.OBJECT);
&nbsp;            }
&nbsp;
&nbsp;            public TypeVariableDefinition&lt;S&gt; typeVariable(String symbol, Type... bound) {
&nbsp;                return this.typeVariable(symbol, Arrays.asList(bound));
&nbsp;            }
&nbsp;
&nbsp;            public TypeVariableDefinition&lt;S&gt; typeVariable(String symbol, List&lt;? extends Type&gt; bounds) {
&nbsp;                return this.typeVariable(symbol, (Collection)(new TypeList.Generic.ForLoadedTypes(bounds)));
&nbsp;            }
&nbsp;
&nbsp;            public TypeVariableDefinition&lt;S&gt; typeVariable(String symbol, TypeDefinition... bound) {
&nbsp;                return this.typeVariable(symbol, (Collection)Arrays.asList(bound));
&nbsp;            }
&nbsp;
&nbsp;            public RecordComponentDefinition.Optional&lt;S&gt; defineRecordComponent(String name, Type type) {
&nbsp;                return this.defineRecordComponent(name, Sort.describe(type));
&nbsp;            }
&nbsp;
&nbsp;            public RecordComponentDefinition.Optional&lt;S&gt; define(RecordComponentDescription recordComponentDescription) {
&nbsp;                return this.defineRecordComponent(recordComponentDescription.getActualName(), recordComponentDescription.getType());
&nbsp;            }
&nbsp;
&nbsp;            public RecordComponentDefinition&lt;S&gt; recordComponent(ElementMatcher&lt;? super RecordComponentDescription&gt; matcher) {
&nbsp;                return this.recordComponent(new LatentMatcher.Resolved(matcher));
&nbsp;            }
&nbsp;
&nbsp;            public FieldDefinition.Optional.Valuable&lt;S&gt; defineField(String name, Type type, ModifierContributor.ForField... modifierContributor) {
&nbsp;                return this.defineField(name, (Type)type, (Collection)Arrays.asList(modifierContributor));
&nbsp;            }
&nbsp;
&nbsp;            public FieldDefinition.Optional.Valuable&lt;S&gt; defineField(String name, Type type, Collection&lt;? extends ModifierContributor.ForField&gt; modifierContributors) {
&nbsp;                return this.defineField(name, type, Resolver.of(modifierContributors).resolve());
&nbsp;            }
&nbsp;
&nbsp;            public FieldDefinition.Optional.Valuable&lt;S&gt; defineField(String name, Type type, int modifiers) {
&nbsp;                return this.defineField(name, Sort.describe(type), modifiers);
&nbsp;            }
&nbsp;
&nbsp;            public FieldDefinition.Optional.Valuable&lt;S&gt; defineField(String name, TypeDefinition type, ModifierContributor.ForField... modifierContributor) {
&nbsp;                return this.defineField(name, (TypeDefinition)type, (Collection)Arrays.asList(modifierContributor));
&nbsp;            }
&nbsp;
&nbsp;            public FieldDefinition.Optional.Valuable&lt;S&gt; defineField(String name, TypeDefinition type, Collection&lt;? extends ModifierContributor.ForField&gt; modifierContributors) {
&nbsp;                return this.defineField(name, type, Resolver.of(modifierContributors).resolve());
&nbsp;            }
&nbsp;
&nbsp;            public FieldDefinition.Optional.Valuable&lt;S&gt; define(Field field) {
&nbsp;                return this.define((FieldDescription)(new FieldDescription.ForLoadedField(field)));
&nbsp;            }
&nbsp;
&nbsp;            public FieldDefinition.Optional.Valuable&lt;S&gt; define(FieldDescription field) {
&nbsp;                return this.defineField(field.getName(), field.getType(), field.getModifiers());
&nbsp;            }
&nbsp;
&nbsp;            public FieldDefinition.Optional&lt;S&gt; serialVersionUid(long serialVersionUid) {
&nbsp;                return this.defineField(&quot;serialVersionUID&quot;, (Type)Long.TYPE, (ModifierContributor.ForField[])(Visibility.PRIVATE, FieldManifestation.FINAL, Ownership.STATIC)).value(serialVersionUid);
&nbsp;            }
&nbsp;
&nbsp;            public FieldDefinition.Valuable&lt;S&gt; field(ElementMatcher&lt;? super FieldDescription&gt; matcher) {
&nbsp;                return this.field(new LatentMatcher.Resolved(matcher));
&nbsp;            }
&nbsp;
&nbsp;            public Builder&lt;S&gt; ignoreAlso(ElementMatcher&lt;? super MethodDescription&gt; ignoredMethods) {
&nbsp;                return this.ignoreAlso(new LatentMatcher.Resolved(ignoredMethods));
&nbsp;            }
&nbsp;
&nbsp;            public MethodDefinition.ParameterDefinition.Initial&lt;S&gt; defineMethod(String name, Type returnType, ModifierContributor.ForMethod... modifierContributor) {
&nbsp;                return this.defineMethod(name, (Type)returnType, (Collection)Arrays.asList(modifierContributor));
&nbsp;            }
&nbsp;
&nbsp;            public MethodDefinition.ParameterDefinition.Initial&lt;S&gt; defineMethod(String name, Type returnType, Collection&lt;? extends ModifierContributor.ForMethod&gt; modifierContributors) {
&nbsp;                return this.defineMethod(name, returnType, Resolver.of(modifierContributors).resolve());
&nbsp;            }
&nbsp;
&nbsp;            public MethodDefinition.ParameterDefinition.Initial&lt;S&gt; defineMethod(String name, Type returnType, int modifiers) {
&nbsp;                return this.defineMethod(name, Sort.describe(returnType), modifiers);
&nbsp;            }
&nbsp;
&nbsp;            public MethodDefinition.ParameterDefinition.Initial&lt;S&gt; defineMethod(String name, TypeDefinition returnType, ModifierContributor.ForMethod... modifierContributor) {
&nbsp;                return this.defineMethod(name, (TypeDefinition)returnType, (Collection)Arrays.asList(modifierContributor));
&nbsp;            }
&nbsp;
&nbsp;            public MethodDefinition.ParameterDefinition.Initial&lt;S&gt; defineMethod(String name, TypeDefinition returnType, Collection&lt;? extends ModifierContributor.ForMethod&gt; modifierContributors) {
&nbsp;                return this.defineMethod(name, returnType, Resolver.of(modifierContributors).resolve());
&nbsp;            }
&nbsp;
&nbsp;            public MethodDefinition.ParameterDefinition.Initial&lt;S&gt; defineConstructor(ModifierContributor.ForMethod... modifierContributor) {
&nbsp;                return this.defineConstructor((Collection)Arrays.asList(modifierContributor));
&nbsp;            }
&nbsp;
&nbsp;            public MethodDefinition.ParameterDefinition.Initial&lt;S&gt; defineConstructor(Collection&lt;? extends ModifierContributor.ForMethod&gt; modifierContributors) {
&nbsp;                return this.defineConstructor(Resolver.of(modifierContributors).resolve());
&nbsp;            }
&nbsp;
&nbsp;            public MethodDefinition.ImplementationDefinition&lt;S&gt; define(Method method) {
&nbsp;                return this.define((MethodDescription)(new MethodDescription.ForLoadedMethod(method)));
&nbsp;            }
&nbsp;
&nbsp;            public MethodDefinition.ImplementationDefinition&lt;S&gt; define(Constructor&lt;?&gt; constructor) {
&nbsp;                return this.define((MethodDescription)(new MethodDescription.ForLoadedConstructor(constructor)));
&nbsp;            }
&nbsp;
&nbsp;            public MethodDefinition.ImplementationDefinition&lt;S&gt; define(MethodDescription methodDescription) {
&nbsp;                MethodDefinition.ParameterDefinition.Initial&lt;S&gt; initialParameterDefinition = methodDescription.isConstructor() ? this.defineConstructor(methodDescription.getModifiers()) : this.defineMethod(methodDescription.getInternalName(), methodDescription.getReturnType(), methodDescription.getModifiers());
&nbsp;                ParameterList&lt;?&gt; parameterList = methodDescription.getParameters();
&nbsp;                Object exceptionDefinition;
&nbsp;                Object typeVariableDefinition;
&nbsp;                Iterator var6;
&nbsp;                if (parameterList.hasExplicitMetaData()) {
&nbsp;                    typeVariableDefinition = initialParameterDefinition;
&nbsp;
&nbsp;                    ParameterDescription parameter;
&nbsp;                    for(var6 = parameterList.iterator(); var6.hasNext(); typeVariableDefinition = ((MethodDefinition.ParameterDefinition)typeVariableDefinition).withParameter((TypeDefinition)parameter.getType(), parameter.getName(), parameter.getModifiers())) {
&nbsp;                        parameter = (ParameterDescription)var6.next();
&nbsp;                    }
&nbsp;
&nbsp;                    exceptionDefinition = typeVariableDefinition;
&nbsp;                } else {
&nbsp;                    exceptionDefinition = initialParameterDefinition.withParameters((Collection)parameterList.asTypeList());
&nbsp;                }
&nbsp;
&nbsp;                typeVariableDefinition = ((MethodDefinition.ExceptionDefinition)exceptionDefinition).throwing((Collection)methodDescription.getExceptionTypes());
&nbsp;
&nbsp;                TypeDescription.Generic typeVariable;
&nbsp;                for(var6 = methodDescription.getTypeVariables().iterator(); var6.hasNext(); typeVariableDefinition = ((MethodDefinition.TypeVariableDefinition)typeVariableDefinition).typeVariable(typeVariable.getSymbol(), (Collection)typeVariable.getUpperBounds())) {
&nbsp;                    typeVariable = (TypeDescription.Generic)var6.next();
&nbsp;                }
&nbsp;
&nbsp;                return (MethodDefinition.ImplementationDefinition)typeVariableDefinition;
&nbsp;            }
&nbsp;
&nbsp;            public FieldDefinition.Optional&lt;S&gt; defineProperty(String name, Type type) {
&nbsp;                return this.defineProperty(name, (TypeDefinition)Sort.describe(type));
&nbsp;            }
&nbsp;
&nbsp;            public FieldDefinition.Optional&lt;S&gt; defineProperty(String name, Type type, boolean readOnly) {
&nbsp;                return this.defineProperty(name, (TypeDefinition)Sort.describe(type), readOnly);
&nbsp;            }
&nbsp;
&nbsp;            public FieldDefinition.Optional&lt;S&gt; defineProperty(String name, TypeDefinition type) {
&nbsp;                return this.defineProperty(name, type, false);
&nbsp;            }
&nbsp;
&nbsp;            public FieldDefinition.Optional&lt;S&gt; defineProperty(String name, TypeDefinition type, boolean readOnly) {
&nbsp;                if (name.length() == 0) {
&nbsp;                    throw new IllegalArgumentException(&quot;A bean property cannot have an empty name&quot;);
&nbsp;                } else if (type.represents(Void.TYPE)) {
&nbsp;                    throw new IllegalArgumentException(&quot;A bean property cannot have a void type&quot;);
&nbsp;                } else {
&nbsp;                    Builder&lt;S&gt; builder = this;
&nbsp;                    FieldManifestation fieldManifestation;
&nbsp;                    if (!readOnly) {
&nbsp;                        builder = this.defineMethod(&quot;set&quot; + Character.toUpperCase(name.charAt(0)) + name.substring(1), (Type)Void.TYPE, (ModifierContributor.ForMethod[])(Visibility.PUBLIC)).withParameters(type).intercept(FieldAccessor.ofField(name));
&nbsp;                        fieldManifestation = FieldManifestation.PLAIN;
&nbsp;                    } else {
&nbsp;                        fieldManifestation = FieldManifestation.FINAL;
&nbsp;                    }
&nbsp;
&nbsp;                    return ((Builder)builder).defineMethod((type.represents(Boolean.TYPE) ? &quot;is&quot; : &quot;get&quot;) + Character.toUpperCase(name.charAt(0)) + name.substring(1), type, Visibility.PUBLIC).intercept(FieldAccessor.ofField(name)).defineField(name, type, new ModifierContributor.ForField[]{Visibility.PRIVATE, fieldManifestation});
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public MethodDefinition.ImplementationDefinition&lt;S&gt; method(ElementMatcher&lt;? super MethodDescription&gt; matcher) {
&nbsp;                return this.invokable(ElementMatchers.isMethod().and(matcher));
&nbsp;            }
&nbsp;
&nbsp;            public MethodDefinition.ImplementationDefinition&lt;S&gt; constructor(ElementMatcher&lt;? super MethodDescription&gt; matcher) {
&nbsp;                return this.invokable(ElementMatchers.isConstructor().and(matcher));
&nbsp;            }
&nbsp;
&nbsp;            public MethodDefinition.ImplementationDefinition&lt;S&gt; invokable(ElementMatcher&lt;? super MethodDescription&gt; matcher) {
&nbsp;                return this.invokable(new LatentMatcher.Resolved(matcher));
&nbsp;            }
&nbsp;
&nbsp;            public Builder&lt;S&gt; withHashCodeEquals() {
&nbsp;                return this.method(ElementMatchers.isHashCode()).intercept(HashCodeMethod.usingDefaultOffset().withIgnoredFields(ElementMatchers.isSynthetic())).method(ElementMatchers.isEquals()).intercept(EqualsMethod.isolated().withIgnoredFields(ElementMatchers.isSynthetic()));
&nbsp;            }
&nbsp;
&nbsp;            public Builder&lt;S&gt; withToString() {
&nbsp;                return this.method(ElementMatchers.isToString()).intercept(ToStringMethod.prefixedBySimpleClassName());
&nbsp;            }
&nbsp;
&nbsp;            public Builder&lt;S&gt; require(TypeDescription type, byte[] binaryRepresentation) {
&nbsp;                return this.require(type, binaryRepresentation, NoOp.INSTANCE);
&nbsp;            }
&nbsp;
&nbsp;            public Builder&lt;S&gt; require(TypeDescription type, byte[] binaryRepresentation, LoadedTypeInitializer typeInitializer) {
&nbsp;                return this.require(new Default(type, binaryRepresentation, typeInitializer, Collections.emptyList()));
&nbsp;            }
&nbsp;
&nbsp;            public Builder&lt;S&gt; require(DynamicType... auxiliaryType) {
&nbsp;                return this.require(Arrays.asList(auxiliaryType));
&nbsp;            }
&nbsp;
&nbsp;            public Unloaded&lt;S&gt; make(TypePool typePool) {
&nbsp;                return this.make(Passive.INSTANCE, typePool);
&nbsp;            }
&nbsp;
&nbsp;            public Unloaded&lt;S&gt; make() {
&nbsp;                return this.make(Passive.INSTANCE);
&nbsp;            }
&nbsp;
&nbsp;            @Enhance
&nbsp;            public abstract static class Adapter&lt;U&gt; extends AbstractBase&lt;U&gt; {
&nbsp;                protected final InstrumentedType.WithFlexibleName instrumentedType;
&nbsp;                protected final FieldRegistry fieldRegistry;
&nbsp;                protected final MethodRegistry methodRegistry;
&nbsp;                protected final RecordComponentRegistry recordComponentRegistry;
&nbsp;                protected final TypeAttributeAppender typeAttributeAppender;
&nbsp;                protected final AsmVisitorWrapper asmVisitorWrapper;
&nbsp;                protected final ClassFileVersion classFileVersion;
&nbsp;                protected final AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy;
&nbsp;                protected final AnnotationValueFilter.Factory annotationValueFilterFactory;
&nbsp;                protected final AnnotationRetention annotationRetention;
&nbsp;                protected final Implementation.Context.Factory implementationContextFactory;
&nbsp;                protected final MethodGraph.Compiler methodGraphCompiler;
&nbsp;                protected final TypeValidation typeValidation;
&nbsp;                protected final VisibilityBridgeStrategy visibilityBridgeStrategy;
&nbsp;                protected final ClassWriterStrategy classWriterStrategy;
&nbsp;                protected final LatentMatcher&lt;? super MethodDescription&gt; ignoredMethods;
&nbsp;                protected final List&lt;? extends DynamicType&gt; auxiliaryTypes;
&nbsp;
&nbsp;                protected Adapter(InstrumentedType.WithFlexibleName instrumentedType, FieldRegistry fieldRegistry, MethodRegistry methodRegistry, RecordComponentRegistry recordComponentRegistry, TypeAttributeAppender typeAttributeAppender, AsmVisitorWrapper asmVisitorWrapper, ClassFileVersion classFileVersion, AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy, AnnotationValueFilter.Factory annotationValueFilterFactory, AnnotationRetention annotationRetention, Implementation.Context.Factory implementationContextFactory, MethodGraph.Compiler methodGraphCompiler, TypeValidation typeValidation, VisibilityBridgeStrategy visibilityBridgeStrategy, ClassWriterStrategy classWriterStrategy, LatentMatcher&lt;? super MethodDescription&gt; ignoredMethods, List&lt;? extends DynamicType&gt; auxiliaryTypes) {
&nbsp;                    this.instrumentedType = instrumentedType;
&nbsp;                    this.fieldRegistry = fieldRegistry;
&nbsp;                    this.methodRegistry = methodRegistry;
&nbsp;                    this.recordComponentRegistry = recordComponentRegistry;
&nbsp;                    this.typeAttributeAppender = typeAttributeAppender;
&nbsp;                    this.asmVisitorWrapper = asmVisitorWrapper;
&nbsp;                    this.classFileVersion = classFileVersion;
&nbsp;                    this.auxiliaryTypeNamingStrategy = auxiliaryTypeNamingStrategy;
&nbsp;                    this.annotationValueFilterFactory = annotationValueFilterFactory;
&nbsp;                    this.annotationRetention = annotationRetention;
&nbsp;                    this.implementationContextFactory = implementationContextFactory;
&nbsp;                    this.methodGraphCompiler = methodGraphCompiler;
&nbsp;                    this.typeValidation = typeValidation;
&nbsp;                    this.visibilityBridgeStrategy = visibilityBridgeStrategy;
&nbsp;                    this.classWriterStrategy = classWriterStrategy;
&nbsp;                    this.ignoredMethods = ignoredMethods;
&nbsp;                    this.auxiliaryTypes = auxiliaryTypes;
&nbsp;                }
&nbsp;
&nbsp;                public FieldDefinition.Optional.Valuable&lt;U&gt; defineField(String name, TypeDefinition type, int modifiers) {
&nbsp;                    return new FieldDefinitionAdapter(new FieldDescription.Token(name, modifiers, type.asGenericType()));
&nbsp;                }
&nbsp;
&nbsp;                public FieldDefinition.Valuable&lt;U&gt; field(LatentMatcher&lt;? super FieldDescription&gt; matcher) {
&nbsp;                    return new FieldMatchAdapter(matcher);
&nbsp;                }
&nbsp;
&nbsp;                public MethodDefinition.ParameterDefinition.Initial&lt;U&gt; defineMethod(String name, TypeDefinition returnType, int modifiers) {
&nbsp;                    return new MethodDefinitionAdapter(new MethodDescription.Token(name, modifiers, returnType.asGenericType()));
&nbsp;                }
&nbsp;
&nbsp;                public MethodDefinition.ParameterDefinition.Initial&lt;U&gt; defineConstructor(int modifiers) {
&nbsp;                    return new MethodDefinitionAdapter(new MethodDescription.Token(modifiers));
&nbsp;                }
&nbsp;
&nbsp;                public MethodDefinition.ImplementationDefinition&lt;U&gt; invokable(LatentMatcher&lt;? super MethodDescription&gt; matcher) {
&nbsp;                    return new MethodMatchAdapter(matcher);
&nbsp;                }
&nbsp;
&nbsp;                public MethodDefinition.ImplementationDefinition.Optional&lt;U&gt; implement(Collection&lt;? extends TypeDefinition&gt; interfaceTypes) {
&nbsp;                    return new OptionalMethodMatchAdapter(new TypeList.Generic.Explicit(new ArrayList(interfaceTypes)));
&nbsp;                }
&nbsp;
&nbsp;                public Builder&lt;U&gt; ignoreAlso(LatentMatcher&lt;? super MethodDescription&gt; ignoredMethods) {
&nbsp;                    return this.materialize(this.instrumentedType, this.fieldRegistry, this.methodRegistry, this.recordComponentRegistry, this.typeAttributeAppender, this.asmVisitorWrapper, this.classFileVersion, this.auxiliaryTypeNamingStrategy, this.annotationValueFilterFactory, this.annotationRetention, this.implementationContextFactory, this.methodGraphCompiler, this.typeValidation, this.visibilityBridgeStrategy, this.classWriterStrategy, new LatentMatcher.Disjunction(new LatentMatcher[]{this.ignoredMethods, ignoredMethods}), this.auxiliaryTypes);
&nbsp;                }
&nbsp;
&nbsp;                public RecordComponentDefinition.Optional&lt;U&gt; defineRecordComponent(String name, TypeDefinition type) {
&nbsp;                    return new RecordComponentDefinitionAdapter(new RecordComponentDescription.Token(name, type.asGenericType()));
&nbsp;                }
&nbsp;
&nbsp;                public RecordComponentDefinition&lt;U&gt; recordComponent(LatentMatcher&lt;? super RecordComponentDescription&gt; matcher) {
&nbsp;                    return new RecordComponentMatchAdapter(matcher);
&nbsp;                }
&nbsp;
&nbsp;                public Builder&lt;U&gt; initializer(ByteCodeAppender byteCodeAppender) {
&nbsp;                    return this.materialize(this.instrumentedType.withInitializer(byteCodeAppender), this.fieldRegistry, this.methodRegistry, this.recordComponentRegistry, this.typeAttributeAppender, this.asmVisitorWrapper, this.classFileVersion, this.auxiliaryTypeNamingStrategy, this.annotationValueFilterFactory, this.annotationRetention, this.implementationContextFactory, this.methodGraphCompiler, this.typeValidation, this.visibilityBridgeStrategy, this.classWriterStrategy, this.ignoredMethods, this.auxiliaryTypes);
&nbsp;                }
&nbsp;
&nbsp;                public Builder&lt;U&gt; initializer(LoadedTypeInitializer loadedTypeInitializer) {
&nbsp;                    return this.materialize(this.instrumentedType.withInitializer(loadedTypeInitializer), this.fieldRegistry, this.methodRegistry, this.recordComponentRegistry, this.typeAttributeAppender, this.asmVisitorWrapper, this.classFileVersion, this.auxiliaryTypeNamingStrategy, this.annotationValueFilterFactory, this.annotationRetention, this.implementationContextFactory, this.methodGraphCompiler, this.typeValidation, this.visibilityBridgeStrategy, this.classWriterStrategy, this.ignoredMethods, this.auxiliaryTypes);
&nbsp;                }
&nbsp;
&nbsp;                public Builder&lt;U&gt; name(String name) {
&nbsp;                    return this.materialize(this.instrumentedType.withName(name), this.fieldRegistry, this.methodRegistry, this.recordComponentRegistry, this.typeAttributeAppender, this.asmVisitorWrapper, this.classFileVersion, this.auxiliaryTypeNamingStrategy, this.annotationValueFilterFactory, this.annotationRetention, this.implementationContextFactory, this.methodGraphCompiler, this.typeValidation, this.visibilityBridgeStrategy, this.classWriterStrategy, this.ignoredMethods, this.auxiliaryTypes);
&nbsp;                }
&nbsp;
&nbsp;                public Builder&lt;U&gt; suffix(String suffix) {
&nbsp;                    return this.name(this.instrumentedType.getName() + &quot;$&quot; + suffix);
&nbsp;                }
&nbsp;
&nbsp;                public Builder&lt;U&gt; modifiers(int modifiers) {
&nbsp;                    return this.materialize(this.instrumentedType.withModifiers(modifiers), this.fieldRegistry, this.methodRegistry, this.recordComponentRegistry, this.typeAttributeAppender, this.asmVisitorWrapper, this.classFileVersion, this.auxiliaryTypeNamingStrategy, this.annotationValueFilterFactory, this.annotationRetention, this.implementationContextFactory, this.methodGraphCompiler, this.typeValidation, this.visibilityBridgeStrategy, this.classWriterStrategy, this.ignoredMethods, this.auxiliaryTypes);
&nbsp;                }
&nbsp;
&nbsp;                public Builder&lt;U&gt; merge(Collection&lt;? extends ModifierContributor.ForType&gt; modifierContributors) {
&nbsp;                    return this.materialize(this.instrumentedType.withModifiers(Resolver.of(modifierContributors).resolve(this.instrumentedType.getModifiers())), this.fieldRegistry, this.methodRegistry, this.recordComponentRegistry, this.typeAttributeAppender, this.asmVisitorWrapper, this.classFileVersion, this.auxiliaryTypeNamingStrategy, this.annotationValueFilterFactory, this.annotationRetention, this.implementationContextFactory, this.methodGraphCompiler, this.typeValidation, this.visibilityBridgeStrategy, this.classWriterStrategy, this.ignoredMethods, this.auxiliaryTypes);
&nbsp;                }
&nbsp;
&nbsp;                public Builder&lt;U&gt; topLevelType() {
&nbsp;                    return this.materialize(this.instrumentedType.withDeclaringType(TypeDescription.UNDEFINED).withEnclosingType(TypeDescription.UNDEFINED).withLocalClass(false), this.fieldRegistry, this.methodRegistry, this.recordComponentRegistry, this.typeAttributeAppender, this.asmVisitorWrapper, this.classFileVersion, this.auxiliaryTypeNamingStrategy, this.annotationValueFilterFactory, this.annotationRetention, this.implementationContextFactory, this.methodGraphCompiler, this.typeValidation, this.visibilityBridgeStrategy, this.classWriterStrategy, this.ignoredMethods, this.auxiliaryTypes);
&nbsp;                }
&nbsp;
&nbsp;                public InnerTypeDefinition.ForType&lt;U&gt; innerTypeOf(TypeDescription type) {
&nbsp;                    return new InnerTypeDefinitionForTypeAdapter(type);
&nbsp;                }
&nbsp;
&nbsp;                public InnerTypeDefinition&lt;U&gt; innerTypeOf(MethodDescription.InDefinedShape methodDescription) {
&nbsp;                    return (InnerTypeDefinition)(methodDescription.isTypeInitializer() ? new InnerTypeDefinitionForTypeAdapter(methodDescription.getDeclaringType()) : new InnerTypeDefinitionForMethodAdapter(methodDescription));
&nbsp;                }
&nbsp;
&nbsp;                public Builder&lt;U&gt; declaredTypes(Collection&lt;? extends TypeDescription&gt; types) {
&nbsp;                    return this.materialize(this.instrumentedType.withDeclaredTypes(new TypeList.Explicit(new ArrayList(types))), this.fieldRegistry, this.methodRegistry, this.recordComponentRegistry, this.typeAttributeAppender, this.asmVisitorWrapper, this.classFileVersion, this.auxiliaryTypeNamingStrategy, this.annotationValueFilterFactory, this.annotationRetention, this.implementationContextFactory, this.methodGraphCompiler, this.typeValidation, this.visibilityBridgeStrategy, this.classWriterStrategy, this.ignoredMethods, this.auxiliaryTypes);
&nbsp;                }
&nbsp;
&nbsp;                public Builder&lt;U&gt; nestHost(TypeDescription type) {
&nbsp;                    return this.materialize(this.instrumentedType.withNestHost(type), this.fieldRegistry, this.methodRegistry, this.recordComponentRegistry, this.typeAttributeAppender, this.asmVisitorWrapper, this.classFileVersion, this.auxiliaryTypeNamingStrategy, this.annotationValueFilterFactory, this.annotationRetention, this.implementationContextFactory, this.methodGraphCompiler, this.typeValidation, this.visibilityBridgeStrategy, this.classWriterStrategy, this.ignoredMethods, this.auxiliaryTypes);
&nbsp;                }
&nbsp;
&nbsp;                public Builder&lt;U&gt; nestMembers(Collection&lt;? extends TypeDescription&gt; types) {
&nbsp;                    return this.materialize(this.instrumentedType.withNestMembers(new TypeList.Explicit(new ArrayList(types))), this.fieldRegistry, this.methodRegistry, this.recordComponentRegistry, this.typeAttributeAppender, this.asmVisitorWrapper, this.classFileVersion, this.auxiliaryTypeNamingStrategy, this.annotationValueFilterFactory, this.annotationRetention, this.implementationContextFactory, this.methodGraphCompiler, this.typeValidation, this.visibilityBridgeStrategy, this.classWriterStrategy, this.ignoredMethods, this.auxiliaryTypes);
&nbsp;                }
&nbsp;
&nbsp;                public Builder&lt;U&gt; permittedSubclass(Collection&lt;? extends TypeDescription&gt; types) {
&nbsp;                    return this.materialize(this.instrumentedType.withPermittedSubclasses(new TypeList.Explicit(new ArrayList(types))), this.fieldRegistry, this.methodRegistry, this.recordComponentRegistry, this.typeAttributeAppender, this.asmVisitorWrapper, this.classFileVersion, this.auxiliaryTypeNamingStrategy, this.annotationValueFilterFactory, this.annotationRetention, this.implementationContextFactory, this.methodGraphCompiler, this.typeValidation, this.visibilityBridgeStrategy, this.classWriterStrategy, this.ignoredMethods, this.auxiliaryTypes);
&nbsp;                }
&nbsp;
&nbsp;                public Builder&lt;U&gt; unsealed() {
&nbsp;                    return this.materialize(this.instrumentedType.withPermittedSubclasses(TypeList.UNDEFINED), this.fieldRegistry, this.methodRegistry, this.recordComponentRegistry, this.typeAttributeAppender, this.asmVisitorWrapper, this.classFileVersion, this.auxiliaryTypeNamingStrategy, this.annotationValueFilterFactory, this.annotationRetention, this.implementationContextFactory, this.methodGraphCompiler, this.typeValidation, this.visibilityBridgeStrategy, this.classWriterStrategy, this.ignoredMethods, this.auxiliaryTypes);
&nbsp;                }
&nbsp;
&nbsp;                public TypeVariableDefinition&lt;U&gt; typeVariable(String symbol, Collection&lt;? extends TypeDefinition&gt; bounds) {
&nbsp;                    return new TypeVariableDefinitionAdapter(new TypeVariableToken(symbol, new TypeList.Generic.Explicit(new ArrayList(bounds))));
&nbsp;                }
&nbsp;
&nbsp;                public Builder&lt;U&gt; transform(ElementMatcher&lt;? super TypeDescription.Generic&gt; matcher, Transformer&lt;TypeVariableToken&gt; transformer) {
&nbsp;                    return this.materialize(this.instrumentedType.withTypeVariables(matcher, transformer), this.fieldRegistry, this.methodRegistry, this.recordComponentRegistry, this.typeAttributeAppender, this.asmVisitorWrapper, this.classFileVersion, this.auxiliaryTypeNamingStrategy, this.annotationValueFilterFactory, this.annotationRetention, this.implementationContextFactory, this.methodGraphCompiler, this.typeValidation, this.visibilityBridgeStrategy, this.classWriterStrategy, this.ignoredMethods, this.auxiliaryTypes);
&nbsp;                }
&nbsp;
&nbsp;                public Builder&lt;U&gt; attribute(TypeAttributeAppender typeAttributeAppender) {
&nbsp;                    return this.materialize(this.instrumentedType, this.fieldRegistry, this.methodRegistry, this.recordComponentRegistry, new TypeAttributeAppender.Compound(new TypeAttributeAppender[]{this.typeAttributeAppender, typeAttributeAppender}), this.asmVisitorWrapper, this.classFileVersion, this.auxiliaryTypeNamingStrategy, this.annotationValueFilterFactory, this.annotationRetention, this.implementationContextFactory, this.methodGraphCompiler, this.typeValidation, this.visibilityBridgeStrategy, this.classWriterStrategy, this.ignoredMethods, this.auxiliaryTypes);
&nbsp;                }
&nbsp;
&nbsp;                public Builder&lt;U&gt; annotateType(Collection&lt;? extends AnnotationDescription&gt; annotations) {
&nbsp;                    return this.materialize(this.instrumentedType.withAnnotations(new ArrayList(annotations)), this.fieldRegistry, this.methodRegistry, this.recordComponentRegistry, this.typeAttributeAppender, this.asmVisitorWrapper, this.classFileVersion, this.auxiliaryTypeNamingStrategy, this.annotationValueFilterFactory, this.annotationRetention, this.implementationContextFactory, this.methodGraphCompiler, this.typeValidation, this.visibilityBridgeStrategy, this.classWriterStrategy, this.ignoredMethods, this.auxiliaryTypes);
&nbsp;                }
&nbsp;
&nbsp;                public Builder&lt;U&gt; visit(AsmVisitorWrapper asmVisitorWrapper) {
&nbsp;                    return this.materialize(this.instrumentedType, this.fieldRegistry, this.methodRegistry, this.recordComponentRegistry, this.typeAttributeAppender, new AsmVisitorWrapper.Compound(new AsmVisitorWrapper[]{this.asmVisitorWrapper, asmVisitorWrapper}), this.classFileVersion, this.auxiliaryTypeNamingStrategy, this.annotationValueFilterFactory, this.annotationRetention, this.implementationContextFactory, this.methodGraphCompiler, this.typeValidation, this.visibilityBridgeStrategy, this.classWriterStrategy, this.ignoredMethods, this.auxiliaryTypes);
&nbsp;                }
&nbsp;
&nbsp;                public Builder&lt;U&gt; require(Collection&lt;DynamicType&gt; auxiliaryTypes) {
&nbsp;                    return this.materialize(this.instrumentedType, this.fieldRegistry, this.methodRegistry, this.recordComponentRegistry, this.typeAttributeAppender, this.asmVisitorWrapper, this.classFileVersion, this.auxiliaryTypeNamingStrategy, this.annotationValueFilterFactory, this.annotationRetention, this.implementationContextFactory, this.methodGraphCompiler, this.typeValidation, this.visibilityBridgeStrategy, this.classWriterStrategy, this.ignoredMethods, CompoundList.of(this.auxiliaryTypes, new ArrayList(auxiliaryTypes)));
&nbsp;                }
&nbsp;
&nbsp;                public TypeDescription toTypeDescription() {
&nbsp;                    return this.instrumentedType;
&nbsp;                }
&nbsp;
&nbsp;                protected abstract Builder&lt;U&gt; materialize(InstrumentedType.WithFlexibleName var1, FieldRegistry var2, MethodRegistry var3, RecordComponentRegistry var4, TypeAttributeAppender var5, AsmVisitorWrapper var6, ClassFileVersion var7, AuxiliaryType.NamingStrategy var8, AnnotationValueFilter.Factory var9, AnnotationRetention var10, Implementation.Context.Factory var11, MethodGraph.Compiler var12, TypeValidation var13, VisibilityBridgeStrategy var14, ClassWriterStrategy var15, LatentMatcher&lt;? super MethodDescription&gt; var16, List&lt;? extends DynamicType&gt; var17);
&nbsp;
&nbsp;                public boolean equals(Object var1) {
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.annotationRetention.equals(((Adapter)var1).annotationRetention)) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.typeValidation.equals(((Adapter)var1).typeValidation)) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.instrumentedType.equals(((Adapter)var1).instrumentedType)) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.fieldRegistry.equals(((Adapter)var1).fieldRegistry)) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.methodRegistry.equals(((Adapter)var1).methodRegistry)) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.recordComponentRegistry.equals(((Adapter)var1).recordComponentRegistry)) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.typeAttributeAppender.equals(((Adapter)var1).typeAttributeAppender)) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.asmVisitorWrapper.equals(((Adapter)var1).asmVisitorWrapper)) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.classFileVersion.equals(((Adapter)var1).classFileVersion)) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.auxiliaryTypeNamingStrategy.equals(((Adapter)var1).auxiliaryTypeNamingStrategy)) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.annotationValueFilterFactory.equals(((Adapter)var1).annotationValueFilterFactory)) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.implementationContextFactory.equals(((Adapter)var1).implementationContextFactory)) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.methodGraphCompiler.equals(((Adapter)var1).methodGraphCompiler)) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.visibilityBridgeStrategy.equals(((Adapter)var1).visibilityBridgeStrategy)) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.classWriterStrategy.equals(((Adapter)var1).classWriterStrategy)) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.ignoredMethods.equals(((Adapter)var1).ignoredMethods)) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.auxiliaryTypes.equals(((Adapter)var1).auxiliaryTypes);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return ((((((((((((((((this.getClass().hashCode() * 31 + this.instrumentedType.hashCode()) * 31 + this.fieldRegistry.hashCode()) * 31 + this.methodRegistry.hashCode()) * 31 + this.recordComponentRegistry.hashCode()) * 31 + this.typeAttributeAppender.hashCode()) * 31 + this.asmVisitorWrapper.hashCode()) * 31 + this.classFileVersion.hashCode()) * 31 + this.auxiliaryTypeNamingStrategy.hashCode()) * 31 + this.annotationValueFilterFactory.hashCode()) * 31 + this.annotationRetention.hashCode()) * 31 + this.implementationContextFactory.hashCode()) * 31 + this.methodGraphCompiler.hashCode()) * 31 + this.typeValidation.hashCode()) * 31 + this.visibilityBridgeStrategy.hashCode()) * 31 + this.classWriterStrategy.hashCode()) * 31 + this.ignoredMethods.hashCode()) * 31 + this.auxiliaryTypes.hashCode();
&nbsp;                }
&nbsp;
&nbsp;                protected class RecordComponentMatchAdapter extends RecordComponentDefinition.Optional.AbstractBase&lt;U&gt; {
&nbsp;                    private final LatentMatcher&lt;? super RecordComponentDescription&gt; matcher;
&nbsp;                    private final RecordComponentAttributeAppender.Factory recordComponentAttributeAppenderFactory;
&nbsp;                    private final Transformer&lt;RecordComponentDescription&gt; transformer;
&nbsp;
&nbsp;                    protected RecordComponentMatchAdapter(LatentMatcher&lt;? super RecordComponentDescription&gt; matcher) {
&nbsp;                        this(matcher, net.bytebuddy.implementation.attribute.RecordComponentAttributeAppender.NoOp.INSTANCE, net.bytebuddy.dynamic.Transformer.NoOp.make());
&nbsp;                    }
&nbsp;
&nbsp;                    protected RecordComponentMatchAdapter(LatentMatcher&lt;? super RecordComponentDescription&gt; matcher, RecordComponentAttributeAppender.Factory recordComponentAttributeAppenderFactory, Transformer&lt;RecordComponentDescription&gt; transformer) {
&nbsp;                        this.matcher = matcher;
&nbsp;                        this.recordComponentAttributeAppenderFactory = recordComponentAttributeAppenderFactory;
&nbsp;                        this.transformer = transformer;
&nbsp;                    }
&nbsp;
&nbsp;                    public RecordComponentDefinition.Optional&lt;U&gt; annotateRecordComponent(Collection&lt;? extends AnnotationDescription&gt; annotations) {
&nbsp;                        return this.attribute(new RecordComponentAttributeAppender.Explicit(new ArrayList(annotations)));
&nbsp;                    }
&nbsp;
&nbsp;                    public RecordComponentDefinition.Optional&lt;U&gt; attribute(RecordComponentAttributeAppender.Factory recordComponentAttributeAppenderFactory) {
&nbsp;                        return Adapter.this.new RecordComponentMatchAdapter(this.matcher, new RecordComponentAttributeAppender.Factory.Compound(new RecordComponentAttributeAppender.Factory[]{this.recordComponentAttributeAppenderFactory, recordComponentAttributeAppenderFactory}), this.transformer);
&nbsp;                    }
&nbsp;
&nbsp;                    public RecordComponentDefinition.Optional&lt;U&gt; transform(Transformer&lt;RecordComponentDescription&gt; transformer) {
&nbsp;                        return Adapter.this.new RecordComponentMatchAdapter(this.matcher, this.recordComponentAttributeAppenderFactory, new Transformer.Compound(new Transformer[]{this.transformer, transformer}));
&nbsp;                    }
&nbsp;
&nbsp;                    protected Builder&lt;U&gt; materialize() {
&nbsp;                        return Adapter.this.materialize(Adapter.this.instrumentedType, Adapter.this.fieldRegistry, Adapter.this.methodRegistry, Adapter.this.recordComponentRegistry.prepend(this.matcher, this.recordComponentAttributeAppenderFactory, this.transformer), Adapter.this.typeAttributeAppender, Adapter.this.asmVisitorWrapper, Adapter.this.classFileVersion, Adapter.this.auxiliaryTypeNamingStrategy, Adapter.this.annotationValueFilterFactory, Adapter.this.annotationRetention, Adapter.this.implementationContextFactory, Adapter.this.methodGraphCompiler, Adapter.this.typeValidation, Adapter.this.visibilityBridgeStrategy, Adapter.this.classWriterStrategy, Adapter.this.ignoredMethods, Adapter.this.auxiliaryTypes);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Enhance(
&nbsp;                    includeSyntheticFields = true
&nbsp;                )
&nbsp;                protected class RecordComponentDefinitionAdapter extends RecordComponentDefinition.Optional.AbstractBase&lt;U&gt; {
&nbsp;                    private final RecordComponentAttributeAppender.Factory recordComponentAttributeAppenderFactory;
&nbsp;                    private final RecordComponentDescription.Token token;
&nbsp;                    private final Transformer&lt;RecordComponentDescription&gt; transformer;
&nbsp;
&nbsp;                    protected RecordComponentDefinitionAdapter(RecordComponentDescription.Token token) {
&nbsp;                        this(ForInstrumentedRecordComponent.INSTANCE, net.bytebuddy.dynamic.Transformer.NoOp.make(), token);
&nbsp;                    }
&nbsp;
&nbsp;                    protected RecordComponentDefinitionAdapter(RecordComponentAttributeAppender.Factory recordComponentAttributeAppenderFactory, Transformer&lt;RecordComponentDescription&gt; transformer, RecordComponentDescription.Token token) {
&nbsp;                        this.recordComponentAttributeAppenderFactory = recordComponentAttributeAppenderFactory;
&nbsp;                        this.transformer = transformer;
&nbsp;                        this.token = token;
&nbsp;                    }
&nbsp;
&nbsp;                    public RecordComponentDefinition.Optional&lt;U&gt; annotateRecordComponent(Collection&lt;? extends AnnotationDescription&gt; annotations) {
&nbsp;                        return Adapter.this.new RecordComponentDefinitionAdapter(this.recordComponentAttributeAppenderFactory, this.transformer, new RecordComponentDescription.Token(this.token.getName(), this.token.getType(), CompoundList.of(this.token.getAnnotations(), new ArrayList(annotations))));
&nbsp;                    }
&nbsp;
&nbsp;                    public RecordComponentDefinition.Optional&lt;U&gt; attribute(RecordComponentAttributeAppender.Factory recordComponentAttributeAppenderFactory) {
&nbsp;                        return Adapter.this.new RecordComponentDefinitionAdapter(new RecordComponentAttributeAppender.Factory.Compound(new RecordComponentAttributeAppender.Factory[]{this.recordComponentAttributeAppenderFactory, recordComponentAttributeAppenderFactory}), this.transformer, this.token);
&nbsp;                    }
&nbsp;
&nbsp;                    public RecordComponentDefinition.Optional&lt;U&gt; transform(Transformer&lt;RecordComponentDescription&gt; transformer) {
&nbsp;                        return Adapter.this.new RecordComponentDefinitionAdapter(this.recordComponentAttributeAppenderFactory, new Transformer.Compound(new Transformer[]{this.transformer, transformer}), this.token);
&nbsp;                    }
&nbsp;
&nbsp;                    protected Builder&lt;U&gt; materialize() {
&nbsp;                        return Adapter.this.materialize(Adapter.this.instrumentedType.withRecordComponent(this.token), Adapter.this.fieldRegistry, Adapter.this.methodRegistry, Adapter.this.recordComponentRegistry.prepend(new LatentMatcher.ForRecordComponentToken(this.token), this.recordComponentAttributeAppenderFactory, this.transformer), Adapter.this.typeAttributeAppender, Adapter.this.asmVisitorWrapper, Adapter.this.classFileVersion, Adapter.this.auxiliaryTypeNamingStrategy, Adapter.this.annotationValueFilterFactory, Adapter.this.annotationRetention, Adapter.this.implementationContextFactory, Adapter.this.methodGraphCompiler, Adapter.this.typeValidation, Adapter.this.visibilityBridgeStrategy, Adapter.this.classWriterStrategy, Adapter.this.ignoredMethods, Adapter.this.auxiliaryTypes);
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(Object var1) {
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else if (!this.recordComponentAttributeAppenderFactory.equals(((RecordComponentDefinitionAdapter)var1).recordComponentAttributeAppenderFactory)) {
&nbsp;                            return false;
&nbsp;                        } else if (!this.token.equals(((RecordComponentDefinitionAdapter)var1).token)) {
&nbsp;                            return false;
&nbsp;                        } else if (!this.transformer.equals(((RecordComponentDefinitionAdapter)var1).transformer)) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return Adapter.this.equals(Adapter.this);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return (((this.getClass().hashCode() * 31 + this.recordComponentAttributeAppenderFactory.hashCode()) * 31 + this.token.hashCode()) * 31 + this.transformer.hashCode()) * 31 + Adapter.this.hashCode();
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Enhance(
&nbsp;                    includeSyntheticFields = true
&nbsp;                )
&nbsp;                protected class OptionalMethodMatchAdapter extends Delegator&lt;U&gt; implements MethodDefinition.ImplementationDefinition.Optional&lt;U&gt; {
&nbsp;                    private final TypeList.Generic interfaces;
&nbsp;
&nbsp;                    protected OptionalMethodMatchAdapter(TypeList.Generic interfaces) {
&nbsp;                        this.interfaces = interfaces;
&nbsp;                    }
&nbsp;
&nbsp;                    protected Builder&lt;U&gt; materialize() {
&nbsp;                        return Adapter.this.materialize(Adapter.this.instrumentedType.withInterfaces(this.interfaces), Adapter.this.fieldRegistry, Adapter.this.methodRegistry, Adapter.this.recordComponentRegistry, Adapter.this.typeAttributeAppender, Adapter.this.asmVisitorWrapper, Adapter.this.classFileVersion, Adapter.this.auxiliaryTypeNamingStrategy, Adapter.this.annotationValueFilterFactory, Adapter.this.annotationRetention, Adapter.this.implementationContextFactory, Adapter.this.methodGraphCompiler, Adapter.this.typeValidation, Adapter.this.visibilityBridgeStrategy, Adapter.this.classWriterStrategy, Adapter.this.ignoredMethods, Adapter.this.auxiliaryTypes);
&nbsp;                    }
&nbsp;
&nbsp;                    public MethodDefinition.ReceiverTypeDefinition&lt;U&gt; intercept(Implementation implementation) {
&nbsp;                        return this.interfaceType().intercept(implementation);
&nbsp;                    }
&nbsp;
&nbsp;                    public MethodDefinition.ReceiverTypeDefinition&lt;U&gt; withoutCode() {
&nbsp;                        return this.interfaceType().withoutCode();
&nbsp;                    }
&nbsp;
&nbsp;                    public MethodDefinition.ReceiverTypeDefinition&lt;U&gt; defaultValue(AnnotationValue&lt;?, ?&gt; annotationValue) {
&nbsp;                        return this.interfaceType().defaultValue(annotationValue);
&nbsp;                    }
&nbsp;
&nbsp;                    public &lt;V&gt; MethodDefinition.ReceiverTypeDefinition&lt;U&gt; defaultValue(V value, Class&lt;? extends V&gt; type) {
&nbsp;                        return this.interfaceType().defaultValue(value, type);
&nbsp;                    }
&nbsp;
&nbsp;                    private MethodDefinition.ImplementationDefinition&lt;U&gt; interfaceType() {
&nbsp;                        ElementMatcher.Junction&lt;TypeDescription&gt; elementMatcher = ElementMatchers.none();
&nbsp;
&nbsp;                        TypeDescription typeDescription;
&nbsp;                        for(Iterator var2 = this.interfaces.asErasures().iterator(); var2.hasNext(); elementMatcher = elementMatcher.or(ElementMatchers.isSuperTypeOf(typeDescription))) {
&nbsp;                            typeDescription = (TypeDescription)var2.next();
&nbsp;                        }
&nbsp;
&nbsp;                        return this.materialize().invokable((ElementMatcher)ElementMatchers.isDeclaredBy(ElementMatchers.isInterface().and(elementMatcher)));
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(Object var1) {
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else if (!this.interfaces.equals(((OptionalMethodMatchAdapter)var1).interfaces)) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return Adapter.this.equals(Adapter.this);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return (this.getClass().hashCode() * 31 + this.interfaces.hashCode()) * 31 + Adapter.this.hashCode();
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Enhance(
&nbsp;                    includeSyntheticFields = true
&nbsp;                )
&nbsp;                protected class MethodMatchAdapter extends MethodDefinition.ImplementationDefinition.AbstractBase&lt;U&gt; {
&nbsp;                    private final LatentMatcher&lt;? super MethodDescription&gt; matcher;
&nbsp;
&nbsp;                    protected MethodMatchAdapter(LatentMatcher&lt;? super MethodDescription&gt; matcher) {
&nbsp;                        this.matcher = matcher;
&nbsp;                    }
&nbsp;
&nbsp;                    public MethodDefinition.ReceiverTypeDefinition&lt;U&gt; intercept(Implementation implementation) {
&nbsp;                        return this.materialize(new MethodRegistry.Handler.ForImplementation(implementation));
&nbsp;                    }
&nbsp;
&nbsp;                    public MethodDefinition.ReceiverTypeDefinition&lt;U&gt; withoutCode() {
&nbsp;                        return this.materialize(ForAbstractMethod.INSTANCE);
&nbsp;                    }
&nbsp;
&nbsp;                    public MethodDefinition.ReceiverTypeDefinition&lt;U&gt; defaultValue(AnnotationValue&lt;?, ?&gt; annotationValue) {
&nbsp;                        return this.materialize(new MethodRegistry.Handler.ForAnnotationValue(annotationValue));
&nbsp;                    }
&nbsp;
&nbsp;                    private MethodDefinition.ReceiverTypeDefinition&lt;U&gt; materialize(MethodRegistry.Handler handler) {
&nbsp;                        return new AnnotationAdapter(handler);
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(Object var1) {
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else if (!this.matcher.equals(((MethodMatchAdapter)var1).matcher)) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return Adapter.this.equals(Adapter.this);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return (this.getClass().hashCode() * 31 + this.matcher.hashCode()) * 31 + Adapter.this.hashCode();
&nbsp;                    }
&nbsp;
&nbsp;                    @Enhance(
&nbsp;                        includeSyntheticFields = true
&nbsp;                    )
&nbsp;                    protected class AnnotationAdapter extends MethodDefinition.AbstractBase.Adapter&lt;U&gt; {
&nbsp;                        protected AnnotationAdapter(MethodRegistry.Handler handler) {
&nbsp;                            this(handler, net.bytebuddy.implementation.attribute.MethodAttributeAppender.NoOp.INSTANCE, net.bytebuddy.dynamic.Transformer.NoOp.make());
&nbsp;                        }
&nbsp;
&nbsp;                        protected AnnotationAdapter(MethodRegistry.Handler handler, MethodAttributeAppender.Factory methodAttributeAppenderFactory, Transformer&lt;MethodDescription&gt; transformer) {
&nbsp;                            super(handler, methodAttributeAppenderFactory, transformer);
&nbsp;                        }
&nbsp;
&nbsp;                        public MethodDefinition&lt;U&gt; receiverType(TypeDescription.Generic receiverType) {
&nbsp;                            return MethodMatchAdapter.this.new AnnotationAdapter(this.handler, new MethodAttributeAppender.Factory.Compound(new MethodAttributeAppender.Factory[]{this.methodAttributeAppenderFactory, new MethodAttributeAppender.ForReceiverType(receiverType)}), this.transformer);
&nbsp;                        }
&nbsp;
&nbsp;                        public MethodDefinition&lt;U&gt; annotateMethod(Collection&lt;? extends AnnotationDescription&gt; annotations) {
&nbsp;                            return MethodMatchAdapter.this.new AnnotationAdapter(this.handler, new MethodAttributeAppender.Factory.Compound(new MethodAttributeAppender.Factory[]{this.methodAttributeAppenderFactory, new MethodAttributeAppender.Explicit(new ArrayList(annotations))}), this.transformer);
&nbsp;                        }
&nbsp;
&nbsp;                        public MethodDefinition&lt;U&gt; annotateParameter(int index, Collection&lt;? extends AnnotationDescription&gt; annotations) {
&nbsp;                            return MethodMatchAdapter.this.new AnnotationAdapter(this.handler, new MethodAttributeAppender.Factory.Compound(new MethodAttributeAppender.Factory[]{this.methodAttributeAppenderFactory, new MethodAttributeAppender.Explicit(index, new ArrayList(annotations))}), this.transformer);
&nbsp;                        }
&nbsp;
&nbsp;                        protected MethodDefinition&lt;U&gt; materialize(MethodRegistry.Handler handler, MethodAttributeAppender.Factory methodAttributeAppenderFactory, Transformer&lt;MethodDescription&gt; transformer) {
&nbsp;                            return MethodMatchAdapter.this.new AnnotationAdapter(handler, methodAttributeAppenderFactory, transformer);
&nbsp;                        }
&nbsp;
&nbsp;                        protected Builder&lt;U&gt; materialize() {
&nbsp;                            return Adapter.this.materialize(Adapter.this.instrumentedType, Adapter.this.fieldRegistry, Adapter.this.methodRegistry.prepend(MethodMatchAdapter.this.matcher, this.handler, this.methodAttributeAppenderFactory, this.transformer), Adapter.this.recordComponentRegistry, Adapter.this.typeAttributeAppender, Adapter.this.asmVisitorWrapper, Adapter.this.classFileVersion, Adapter.this.auxiliaryTypeNamingStrategy, Adapter.this.annotationValueFilterFactory, Adapter.this.annotationRetention, Adapter.this.implementationContextFactory, Adapter.this.methodGraphCompiler, Adapter.this.typeValidation, Adapter.this.visibilityBridgeStrategy, Adapter.this.classWriterStrategy, Adapter.this.ignoredMethods, Adapter.this.auxiliaryTypes);
&nbsp;                        }
&nbsp;
&nbsp;                        public boolean equals(Object var1) {
&nbsp;                            if (!super.equals(var1)) {
&nbsp;                                return false;
&nbsp;                            } else if (this == var1) {
&nbsp;                                return true;
&nbsp;                            } else if (var1 == null) {
&nbsp;                                return false;
&nbsp;                            } else if (this.getClass() != var1.getClass()) {
&nbsp;                                return false;
&nbsp;                            } else {
&nbsp;                                return MethodMatchAdapter.this.equals(MethodMatchAdapter.this);
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        public int hashCode() {
&nbsp;                            return super.hashCode() * 31 + MethodMatchAdapter.this.hashCode();
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Enhance(
&nbsp;                    includeSyntheticFields = true
&nbsp;                )
&nbsp;                protected class MethodDefinitionAdapter extends MethodDefinition.ParameterDefinition.Initial.AbstractBase&lt;U&gt; {
&nbsp;                    private final MethodDescription.Token token;
&nbsp;
&nbsp;                    protected MethodDefinitionAdapter(MethodDescription.Token token) {
&nbsp;                        this.token = token;
&nbsp;                    }
&nbsp;
&nbsp;                    public MethodDefinition.ParameterDefinition.Annotatable&lt;U&gt; withParameter(TypeDefinition type, String name, int modifiers) {
&nbsp;                        return new ParameterAnnotationAdapter(new ParameterDescription.Token(type.asGenericType(), name, modifiers));
&nbsp;                    }
&nbsp;
&nbsp;                    public MethodDefinition.ParameterDefinition.Simple.Annotatable&lt;U&gt; withParameter(TypeDefinition type) {
&nbsp;                        return new SimpleParameterAnnotationAdapter(new ParameterDescription.Token(type.asGenericType()));
&nbsp;                    }
&nbsp;
&nbsp;                    public MethodDefinition.ExceptionDefinition&lt;U&gt; throwing(Collection&lt;? extends TypeDefinition&gt; types) {
&nbsp;                        return Adapter.this.new MethodDefinitionAdapter(new MethodDescription.Token(this.token.getName(), this.token.getModifiers(), this.token.getTypeVariableTokens(), this.token.getReturnType(), this.token.getParameterTokens(), CompoundList.of(this.token.getExceptionTypes(), new TypeList.Generic.Explicit(new ArrayList(types))), this.token.getAnnotations(), this.token.getDefaultValue(), this.token.getReceiverType()));
&nbsp;                    }
&nbsp;
&nbsp;                    public MethodDefinition.TypeVariableDefinition.Annotatable&lt;U&gt; typeVariable(String symbol, Collection&lt;? extends TypeDefinition&gt; bounds) {
&nbsp;                        return new TypeVariableAnnotationAdapter(new TypeVariableToken(symbol, new TypeList.Generic.Explicit(new ArrayList(bounds))));
&nbsp;                    }
&nbsp;
&nbsp;                    public MethodDefinition.ReceiverTypeDefinition&lt;U&gt; intercept(Implementation implementation) {
&nbsp;                        return this.materialize(new MethodRegistry.Handler.ForImplementation(implementation));
&nbsp;                    }
&nbsp;
&nbsp;                    public MethodDefinition.ReceiverTypeDefinition&lt;U&gt; withoutCode() {
&nbsp;                        return (Adapter.this.new MethodDefinitionAdapter(new MethodDescription.Token(this.token.getName(), (this.token.getModifiers() &amp; 256) == 0 ? Resolver.of(new ModifierContributor.ForMethod[]{MethodManifestation.ABSTRACT}).resolve(this.token.getModifiers()) : this.token.getModifiers(), this.token.getTypeVariableTokens(), this.token.getReturnType(), this.token.getParameterTokens(), this.token.getExceptionTypes(), this.token.getAnnotations(), this.token.getDefaultValue(), this.token.getReceiverType()))).materialize(ForAbstractMethod.INSTANCE);
&nbsp;                    }
&nbsp;
&nbsp;                    public MethodDefinition.ReceiverTypeDefinition&lt;U&gt; defaultValue(AnnotationValue&lt;?, ?&gt; annotationValue) {
&nbsp;                        return (Adapter.this.new MethodDefinitionAdapter(new MethodDescription.Token(this.token.getName(), Resolver.of(new ModifierContributor.ForMethod[]{MethodManifestation.ABSTRACT}).resolve(this.token.getModifiers()), this.token.getTypeVariableTokens(), this.token.getReturnType(), this.token.getParameterTokens(), this.token.getExceptionTypes(), this.token.getAnnotations(), annotationValue, this.token.getReceiverType()))).materialize(new MethodRegistry.Handler.ForAnnotationValue(annotationValue));
&nbsp;                    }
&nbsp;
&nbsp;                    private MethodDefinition.ReceiverTypeDefinition&lt;U&gt; materialize(MethodRegistry.Handler handler) {
&nbsp;                        return new AnnotationAdapter(handler);
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(Object var1) {
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else if (!this.token.equals(((MethodDefinitionAdapter)var1).token)) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return Adapter.this.equals(Adapter.this);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return (this.getClass().hashCode() * 31 + this.token.hashCode()) * 31 + Adapter.this.hashCode();
&nbsp;                    }
&nbsp;
&nbsp;                    @Enhance(
&nbsp;                        includeSyntheticFields = true
&nbsp;                    )
&nbsp;                    protected class AnnotationAdapter extends MethodDefinition.AbstractBase.Adapter&lt;U&gt; {
&nbsp;                        protected AnnotationAdapter(MethodRegistry.Handler handler) {
&nbsp;                            this(handler, ForInstrumentedMethod.INCLUDING_RECEIVER, net.bytebuddy.dynamic.Transformer.NoOp.make());
&nbsp;                        }
&nbsp;
&nbsp;                        protected AnnotationAdapter(MethodRegistry.Handler handler, MethodAttributeAppender.Factory methodAttributeAppenderFactory, Transformer&lt;MethodDescription&gt; transformer) {
&nbsp;                            super(handler, methodAttributeAppenderFactory, transformer);
&nbsp;                        }
&nbsp;
&nbsp;                        public MethodDefinition&lt;U&gt; receiverType(TypeDescription.Generic receiverType) {
&nbsp;                            return Adapter.this.new MethodDefinitionAdapter(new MethodDescription.Token(MethodDefinitionAdapter.this.token.getName(), MethodDefinitionAdapter.this.token.getModifiers(), MethodDefinitionAdapter.this.token.getTypeVariableTokens(), MethodDefinitionAdapter.this.token.getReturnType(), MethodDefinitionAdapter.this.token.getParameterTokens(), MethodDefinitionAdapter.this.token.getExceptionTypes(), MethodDefinitionAdapter.this.token.getAnnotations(), MethodDefinitionAdapter.this.token.getDefaultValue(), receiverType)).new AnnotationAdapter(this.handler, this.methodAttributeAppenderFactory, this.transformer);
&nbsp;                        }
&nbsp;
&nbsp;                        public MethodDefinition&lt;U&gt; annotateMethod(Collection&lt;? extends AnnotationDescription&gt; annotations) {
&nbsp;                            return Adapter.this.new MethodDefinitionAdapter(new MethodDescription.Token(MethodDefinitionAdapter.this.token.getName(), MethodDefinitionAdapter.this.token.getModifiers(), MethodDefinitionAdapter.this.token.getTypeVariableTokens(), MethodDefinitionAdapter.this.token.getReturnType(), MethodDefinitionAdapter.this.token.getParameterTokens(), MethodDefinitionAdapter.this.token.getExceptionTypes(), CompoundList.of(MethodDefinitionAdapter.this.token.getAnnotations(), new ArrayList(annotations)), MethodDefinitionAdapter.this.token.getDefaultValue(), MethodDefinitionAdapter.this.token.getReceiverType())).new AnnotationAdapter(this.handler, this.methodAttributeAppenderFactory, this.transformer);
&nbsp;                        }
&nbsp;
&nbsp;                        public MethodDefinition&lt;U&gt; annotateParameter(int index, Collection&lt;? extends AnnotationDescription&gt; annotations) {
&nbsp;                            List&lt;ParameterDescription.Token&gt; parameterTokens = new ArrayList(MethodDefinitionAdapter.this.token.getParameterTokens());
&nbsp;                            parameterTokens.set(index, new ParameterDescription.Token(((ParameterDescription.Token)MethodDefinitionAdapter.this.token.getParameterTokens().get(index)).getType(), CompoundList.of(((ParameterDescription.Token)MethodDefinitionAdapter.this.token.getParameterTokens().get(index)).getAnnotations(), new ArrayList(annotations)), ((ParameterDescription.Token)MethodDefinitionAdapter.this.token.getParameterTokens().get(index)).getName(), ((ParameterDescription.Token)MethodDefinitionAdapter.this.token.getParameterTokens().get(index)).getModifiers()));
&nbsp;                            return Adapter.this.new MethodDefinitionAdapter(new MethodDescription.Token(MethodDefinitionAdapter.this.token.getName(), MethodDefinitionAdapter.this.token.getModifiers(), MethodDefinitionAdapter.this.token.getTypeVariableTokens(), MethodDefinitionAdapter.this.token.getReturnType(), parameterTokens, MethodDefinitionAdapter.this.token.getExceptionTypes(), MethodDefinitionAdapter.this.token.getAnnotations(), MethodDefinitionAdapter.this.token.getDefaultValue(), MethodDefinitionAdapter.this.token.getReceiverType())).new AnnotationAdapter(this.handler, this.methodAttributeAppenderFactory, this.transformer);
&nbsp;                        }
&nbsp;
&nbsp;                        protected MethodDefinition&lt;U&gt; materialize(MethodRegistry.Handler handler, MethodAttributeAppender.Factory methodAttributeAppenderFactory, Transformer&lt;MethodDescription&gt; transformer) {
&nbsp;                            return MethodDefinitionAdapter.this.new AnnotationAdapter(handler, methodAttributeAppenderFactory, transformer);
&nbsp;                        }
&nbsp;
&nbsp;                        protected Builder&lt;U&gt; materialize() {
&nbsp;                            return Adapter.this.materialize(Adapter.this.instrumentedType.withMethod(MethodDefinitionAdapter.this.token), Adapter.this.fieldRegistry, Adapter.this.methodRegistry.prepend(new LatentMatcher.ForMethodToken(MethodDefinitionAdapter.this.token), this.handler, this.methodAttributeAppenderFactory, this.transformer), Adapter.this.recordComponentRegistry, Adapter.this.typeAttributeAppender, Adapter.this.asmVisitorWrapper, Adapter.this.classFileVersion, Adapter.this.auxiliaryTypeNamingStrategy, Adapter.this.annotationValueFilterFactory, Adapter.this.annotationRetention, Adapter.this.implementationContextFactory, Adapter.this.methodGraphCompiler, Adapter.this.typeValidation, Adapter.this.visibilityBridgeStrategy, Adapter.this.classWriterStrategy, Adapter.this.ignoredMethods, Adapter.this.auxiliaryTypes);
&nbsp;                        }
&nbsp;
&nbsp;                        public boolean equals(Object var1) {
&nbsp;                            if (!super.equals(var1)) {
&nbsp;                                return false;
&nbsp;                            } else if (this == var1) {
&nbsp;                                return true;
&nbsp;                            } else if (var1 == null) {
&nbsp;                                return false;
&nbsp;                            } else if (this.getClass() != var1.getClass()) {
&nbsp;                                return false;
&nbsp;                            } else {
&nbsp;                                return MethodDefinitionAdapter.this.equals(MethodDefinitionAdapter.this);
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        public int hashCode() {
&nbsp;                            return super.hashCode() * 31 + MethodDefinitionAdapter.this.hashCode();
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    @Enhance(
&nbsp;                        includeSyntheticFields = true
&nbsp;                    )
&nbsp;                    protected class SimpleParameterAnnotationAdapter extends MethodDefinition.ParameterDefinition.Simple.Annotatable.AbstractBase.Adapter&lt;U&gt; {
&nbsp;                        private final ParameterDescription.Token token;
&nbsp;
&nbsp;                        protected SimpleParameterAnnotationAdapter(ParameterDescription.Token token) {
&nbsp;                            this.token = token;
&nbsp;                        }
&nbsp;
&nbsp;                        public MethodDefinition.ParameterDefinition.Simple.Annotatable&lt;U&gt; annotateParameter(Collection&lt;? extends AnnotationDescription&gt; annotations) {
&nbsp;                            return MethodDefinitionAdapter.this.new SimpleParameterAnnotationAdapter(new ParameterDescription.Token(this.token.getType(), CompoundList.of(this.token.getAnnotations(), new ArrayList(annotations)), this.token.getName(), this.token.getModifiers()));
&nbsp;                        }
&nbsp;
&nbsp;                        protected MethodDefinition.ParameterDefinition.Simple&lt;U&gt; materialize() {
&nbsp;                            return Adapter.this.new MethodDefinitionAdapter(new MethodDescription.Token(MethodDefinitionAdapter.this.token.getName(), MethodDefinitionAdapter.this.token.getModifiers(), MethodDefinitionAdapter.this.token.getTypeVariableTokens(), MethodDefinitionAdapter.this.token.getReturnType(), CompoundList.of(MethodDefinitionAdapter.this.token.getParameterTokens(), this.token), MethodDefinitionAdapter.this.token.getExceptionTypes(), MethodDefinitionAdapter.this.token.getAnnotations(), MethodDefinitionAdapter.this.token.getDefaultValue(), MethodDefinitionAdapter.this.token.getReceiverType()));
&nbsp;                        }
&nbsp;
&nbsp;                        public boolean equals(Object var1) {
&nbsp;                            if (this == var1) {
&nbsp;                                return true;
&nbsp;                            } else if (var1 == null) {
&nbsp;                                return false;
&nbsp;                            } else if (this.getClass() != var1.getClass()) {
&nbsp;                                return false;
&nbsp;                            } else if (!this.token.equals(((SimpleParameterAnnotationAdapter)var1).token)) {
&nbsp;                                return false;
&nbsp;                            } else {
&nbsp;                                return MethodDefinitionAdapter.this.equals(MethodDefinitionAdapter.this);
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        public int hashCode() {
&nbsp;                            return (this.getClass().hashCode() * 31 + this.token.hashCode()) * 31 + MethodDefinitionAdapter.this.hashCode();
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    @Enhance(
&nbsp;                        includeSyntheticFields = true
&nbsp;                    )
&nbsp;                    protected class ParameterAnnotationAdapter extends MethodDefinition.ParameterDefinition.Annotatable.AbstractBase.Adapter&lt;U&gt; {
&nbsp;                        private final ParameterDescription.Token token;
&nbsp;
&nbsp;                        protected ParameterAnnotationAdapter(ParameterDescription.Token token) {
&nbsp;                            this.token = token;
&nbsp;                        }
&nbsp;
&nbsp;                        public MethodDefinition.ParameterDefinition.Annotatable&lt;U&gt; annotateParameter(Collection&lt;? extends AnnotationDescription&gt; annotations) {
&nbsp;                            return MethodDefinitionAdapter.this.new ParameterAnnotationAdapter(new ParameterDescription.Token(this.token.getType(), CompoundList.of(this.token.getAnnotations(), new ArrayList(annotations)), this.token.getName(), this.token.getModifiers()));
&nbsp;                        }
&nbsp;
&nbsp;                        protected MethodDefinition.ParameterDefinition&lt;U&gt; materialize() {
&nbsp;                            return Adapter.this.new MethodDefinitionAdapter(new MethodDescription.Token(MethodDefinitionAdapter.this.token.getName(), MethodDefinitionAdapter.this.token.getModifiers(), MethodDefinitionAdapter.this.token.getTypeVariableTokens(), MethodDefinitionAdapter.this.token.getReturnType(), CompoundList.of(MethodDefinitionAdapter.this.token.getParameterTokens(), this.token), MethodDefinitionAdapter.this.token.getExceptionTypes(), MethodDefinitionAdapter.this.token.getAnnotations(), MethodDefinitionAdapter.this.token.getDefaultValue(), MethodDefinitionAdapter.this.token.getReceiverType()));
&nbsp;                        }
&nbsp;
&nbsp;                        public boolean equals(Object var1) {
&nbsp;                            if (this == var1) {
&nbsp;                                return true;
&nbsp;                            } else if (var1 == null) {
&nbsp;                                return false;
&nbsp;                            } else if (this.getClass() != var1.getClass()) {
&nbsp;                                return false;
&nbsp;                            } else if (!this.token.equals(((ParameterAnnotationAdapter)var1).token)) {
&nbsp;                                return false;
&nbsp;                            } else {
&nbsp;                                return MethodDefinitionAdapter.this.equals(MethodDefinitionAdapter.this);
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        public int hashCode() {
&nbsp;                            return (this.getClass().hashCode() * 31 + this.token.hashCode()) * 31 + MethodDefinitionAdapter.this.hashCode();
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    @Enhance(
&nbsp;                        includeSyntheticFields = true
&nbsp;                    )
&nbsp;                    protected class TypeVariableAnnotationAdapter extends MethodDefinition.TypeVariableDefinition.Annotatable.AbstractBase.Adapter&lt;U&gt; {
&nbsp;                        private final TypeVariableToken token;
&nbsp;
&nbsp;                        protected TypeVariableAnnotationAdapter(TypeVariableToken token) {
&nbsp;                            this.token = token;
&nbsp;                        }
&nbsp;
&nbsp;                        protected MethodDefinition.ParameterDefinition&lt;U&gt; materialize() {
&nbsp;                            return Adapter.this.new MethodDefinitionAdapter(new MethodDescription.Token(MethodDefinitionAdapter.this.token.getName(), MethodDefinitionAdapter.this.token.getModifiers(), CompoundList.of(MethodDefinitionAdapter.this.token.getTypeVariableTokens(), this.token), MethodDefinitionAdapter.this.token.getReturnType(), MethodDefinitionAdapter.this.token.getParameterTokens(), MethodDefinitionAdapter.this.token.getExceptionTypes(), MethodDefinitionAdapter.this.token.getAnnotations(), MethodDefinitionAdapter.this.token.getDefaultValue(), MethodDefinitionAdapter.this.token.getReceiverType()));
&nbsp;                        }
&nbsp;
&nbsp;                        public MethodDefinition.TypeVariableDefinition.Annotatable&lt;U&gt; annotateTypeVariable(Collection&lt;? extends AnnotationDescription&gt; annotations) {
&nbsp;                            return MethodDefinitionAdapter.this.new TypeVariableAnnotationAdapter(new TypeVariableToken(this.token.getSymbol(), this.token.getBounds(), CompoundList.of(this.token.getAnnotations(), new ArrayList(annotations))));
&nbsp;                        }
&nbsp;
&nbsp;                        public boolean equals(Object var1) {
&nbsp;                            if (this == var1) {
&nbsp;                                return true;
&nbsp;                            } else if (var1 == null) {
&nbsp;                                return false;
&nbsp;                            } else if (this.getClass() != var1.getClass()) {
&nbsp;                                return false;
&nbsp;                            } else if (!this.token.equals(((TypeVariableAnnotationAdapter)var1).token)) {
&nbsp;                                return false;
&nbsp;                            } else {
&nbsp;                                return MethodDefinitionAdapter.this.equals(MethodDefinitionAdapter.this);
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        public int hashCode() {
&nbsp;                            return (this.getClass().hashCode() * 31 + this.token.hashCode()) * 31 + MethodDefinitionAdapter.this.hashCode();
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Enhance(
&nbsp;                    includeSyntheticFields = true
&nbsp;                )
&nbsp;                protected class FieldMatchAdapter extends FieldDefinition.Optional.Valuable.AbstractBase.Adapter&lt;U&gt; {
&nbsp;                    private final LatentMatcher&lt;? super FieldDescription&gt; matcher;
&nbsp;
&nbsp;                    protected FieldMatchAdapter(LatentMatcher&lt;? super FieldDescription&gt; matcher) {
&nbsp;                        this(net.bytebuddy.implementation.attribute.FieldAttributeAppender.NoOp.INSTANCE, net.bytebuddy.dynamic.Transformer.NoOp.make(), FieldDescription.NO_DEFAULT_VALUE, matcher);
&nbsp;                    }
&nbsp;
&nbsp;                    protected FieldMatchAdapter(FieldAttributeAppender.Factory fieldAttributeAppenderFactory, Transformer&lt;FieldDescription&gt; transformer, @Nonnull(when = When.MAYBE) Object defaultValue, LatentMatcher&lt;? super FieldDescription&gt; matcher) {
&nbsp;                        super(fieldAttributeAppenderFactory, transformer, defaultValue);
&nbsp;                        this.matcher = matcher;
&nbsp;                    }
&nbsp;
&nbsp;                    public FieldDefinition.Optional&lt;U&gt; annotateField(Collection&lt;? extends AnnotationDescription&gt; annotations) {
&nbsp;                        return this.attribute(new FieldAttributeAppender.Explicit(new ArrayList(annotations)));
&nbsp;                    }
&nbsp;
&nbsp;                    protected Builder&lt;U&gt; materialize() {
&nbsp;                        return Adapter.this.materialize(Adapter.this.instrumentedType, Adapter.this.fieldRegistry.prepend(this.matcher, this.fieldAttributeAppenderFactory, this.defaultValue, this.transformer), Adapter.this.methodRegistry, Adapter.this.recordComponentRegistry, Adapter.this.typeAttributeAppender, Adapter.this.asmVisitorWrapper, Adapter.this.classFileVersion, Adapter.this.auxiliaryTypeNamingStrategy, Adapter.this.annotationValueFilterFactory, Adapter.this.annotationRetention, Adapter.this.implementationContextFactory, Adapter.this.methodGraphCompiler, Adapter.this.typeValidation, Adapter.this.visibilityBridgeStrategy, Adapter.this.classWriterStrategy, Adapter.this.ignoredMethods, Adapter.this.auxiliaryTypes);
&nbsp;                    }
&nbsp;
&nbsp;                    protected FieldDefinition.Optional&lt;U&gt; materialize(FieldAttributeAppender.Factory fieldAttributeAppenderFactory, Transformer&lt;FieldDescription&gt; transformer, @Nonnull(when = When.MAYBE) Object defaultValue) {
&nbsp;                        return Adapter.this.new FieldMatchAdapter(fieldAttributeAppenderFactory, transformer, defaultValue, this.matcher);
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(Object var1) {
&nbsp;                        if (!super.equals(var1)) {
&nbsp;                            return false;
&nbsp;                        } else if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else if (!this.matcher.equals(((FieldMatchAdapter)var1).matcher)) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return Adapter.this.equals(Adapter.this);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return (super.hashCode() * 31 + this.matcher.hashCode()) * 31 + Adapter.this.hashCode();
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Enhance(
&nbsp;                    includeSyntheticFields = true
&nbsp;                )
&nbsp;                protected class FieldDefinitionAdapter extends FieldDefinition.Optional.Valuable.AbstractBase.Adapter&lt;U&gt; {
&nbsp;                    private final FieldDescription.Token token;
&nbsp;
&nbsp;                    protected FieldDefinitionAdapter(FieldDescription.Token token) {
&nbsp;                        this(ForInstrumentedField.INSTANCE, net.bytebuddy.dynamic.Transformer.NoOp.make(), FieldDescription.NO_DEFAULT_VALUE, token);
&nbsp;                    }
&nbsp;
&nbsp;                    protected FieldDefinitionAdapter(FieldAttributeAppender.Factory fieldAttributeAppenderFactory, Transformer&lt;FieldDescription&gt; transformer, @Nonnull(when = When.MAYBE) Object defaultValue, FieldDescription.Token token) {
&nbsp;                        super(fieldAttributeAppenderFactory, transformer, defaultValue);
&nbsp;                        this.token = token;
&nbsp;                    }
&nbsp;
&nbsp;                    public FieldDefinition.Optional&lt;U&gt; annotateField(Collection&lt;? extends AnnotationDescription&gt; annotations) {
&nbsp;                        return Adapter.this.new FieldDefinitionAdapter(this.fieldAttributeAppenderFactory, this.transformer, this.defaultValue, new FieldDescription.Token(this.token.getName(), this.token.getModifiers(), this.token.getType(), CompoundList.of(this.token.getAnnotations(), new ArrayList(annotations))));
&nbsp;                    }
&nbsp;
&nbsp;                    protected Builder&lt;U&gt; materialize() {
&nbsp;                        return Adapter.this.materialize(Adapter.this.instrumentedType.withField(this.token), Adapter.this.fieldRegistry.prepend(new LatentMatcher.ForFieldToken(this.token), this.fieldAttributeAppenderFactory, this.defaultValue, this.transformer), Adapter.this.methodRegistry, Adapter.this.recordComponentRegistry, Adapter.this.typeAttributeAppender, Adapter.this.asmVisitorWrapper, Adapter.this.classFileVersion, Adapter.this.auxiliaryTypeNamingStrategy, Adapter.this.annotationValueFilterFactory, Adapter.this.annotationRetention, Adapter.this.implementationContextFactory, Adapter.this.methodGraphCompiler, Adapter.this.typeValidation, Adapter.this.visibilityBridgeStrategy, Adapter.this.classWriterStrategy, Adapter.this.ignoredMethods, Adapter.this.auxiliaryTypes);
&nbsp;                    }
&nbsp;
&nbsp;                    protected FieldDefinition.Optional&lt;U&gt; materialize(FieldAttributeAppender.Factory fieldAttributeAppenderFactory, Transformer&lt;FieldDescription&gt; transformer, @Nonnull(when = When.MAYBE) Object defaultValue) {
&nbsp;                        return Adapter.this.new FieldDefinitionAdapter(fieldAttributeAppenderFactory, transformer, defaultValue, this.token);
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(Object var1) {
&nbsp;                        if (!super.equals(var1)) {
&nbsp;                            return false;
&nbsp;                        } else if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else if (!this.token.equals(((FieldDefinitionAdapter)var1).token)) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return Adapter.this.equals(Adapter.this);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return (super.hashCode() * 31 + this.token.hashCode()) * 31 + Adapter.this.hashCode();
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Enhance(
&nbsp;                    includeSyntheticFields = true
&nbsp;                )
&nbsp;                protected class TypeVariableDefinitionAdapter extends TypeVariableDefinition.AbstractBase&lt;U&gt; {
&nbsp;                    private final TypeVariableToken token;
&nbsp;
&nbsp;                    protected TypeVariableDefinitionAdapter(TypeVariableToken token) {
&nbsp;                        this.token = token;
&nbsp;                    }
&nbsp;
&nbsp;                    public TypeVariableDefinition&lt;U&gt; annotateTypeVariable(Collection&lt;? extends AnnotationDescription&gt; annotations) {
&nbsp;                        return Adapter.this.new TypeVariableDefinitionAdapter(new TypeVariableToken(this.token.getSymbol(), this.token.getBounds(), CompoundList.of(this.token.getAnnotations(), new ArrayList(annotations))));
&nbsp;                    }
&nbsp;
<b class="fc">&nbsp;                    protected Builder&lt;U&gt; materialize() {</b>
&nbsp;                        return Adapter.this.materialize(Adapter.this.instrumentedType.withTypeVariable(this.token), Adapter.this.fieldRegistry, Adapter.this.methodRegistry, Adapter.this.recordComponentRegistry, Adapter.this.typeAttributeAppender, Adapter.this.asmVisitorWrapper, Adapter.this.classFileVersion, Adapter.this.auxiliaryTypeNamingStrategy, Adapter.this.annotationValueFilterFactory, Adapter.this.annotationRetention, Adapter.this.implementationContextFactory, Adapter.this.methodGraphCompiler, Adapter.this.typeValidation, Adapter.this.visibilityBridgeStrategy, Adapter.this.classWriterStrategy, Adapter.this.ignoredMethods, Adapter.this.auxiliaryTypes);
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(Object var1) {
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else if (!this.token.equals(((TypeVariableDefinitionAdapter)var1).token)) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return Adapter.this.equals(Adapter.this);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return (this.getClass().hashCode() * 31 + this.token.hashCode()) * 31 + Adapter.this.hashCode();
<b class="fc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                @Enhance(
&nbsp;                    includeSyntheticFields = true
&nbsp;                )
&nbsp;                protected class InnerTypeDefinitionForMethodAdapter extends Delegator&lt;U&gt; implements InnerTypeDefinition&lt;U&gt; {
&nbsp;                    private final MethodDescription.InDefinedShape methodDescription;
&nbsp;
&nbsp;                    protected InnerTypeDefinitionForMethodAdapter(MethodDescription.InDefinedShape methodDescription) {
&nbsp;                        this.methodDescription = methodDescription;
&nbsp;                    }
&nbsp;
&nbsp;                    public Builder&lt;U&gt; asAnonymousType() {
&nbsp;                        return Adapter.this.materialize(Adapter.this.instrumentedType.withDeclaringType(TypeDescription.UNDEFINED).withEnclosingMethod(this.methodDescription).withAnonymousClass(true), Adapter.this.fieldRegistry, Adapter.this.methodRegistry, Adapter.this.recordComponentRegistry, Adapter.this.typeAttributeAppender, Adapter.this.asmVisitorWrapper, Adapter.this.classFileVersion, Adapter.this.auxiliaryTypeNamingStrategy, Adapter.this.annotationValueFilterFactory, Adapter.this.annotationRetention, Adapter.this.implementationContextFactory, Adapter.this.methodGraphCompiler, Adapter.this.typeValidation, Adapter.this.visibilityBridgeStrategy, Adapter.this.classWriterStrategy, Adapter.this.ignoredMethods, Adapter.this.auxiliaryTypes);
&nbsp;                    }
&nbsp;
&nbsp;                    protected Builder&lt;U&gt; materialize() {
&nbsp;                        return Adapter.this.materialize(Adapter.this.instrumentedType.withDeclaringType(TypeDescription.UNDEFINED).withEnclosingMethod(this.methodDescription).withLocalClass(true), Adapter.this.fieldRegistry, Adapter.this.methodRegistry, Adapter.this.recordComponentRegistry, Adapter.this.typeAttributeAppender, Adapter.this.asmVisitorWrapper, Adapter.this.classFileVersion, Adapter.this.auxiliaryTypeNamingStrategy, Adapter.this.annotationValueFilterFactory, Adapter.this.annotationRetention, Adapter.this.implementationContextFactory, Adapter.this.methodGraphCompiler, Adapter.this.typeValidation, Adapter.this.visibilityBridgeStrategy, Adapter.this.classWriterStrategy, Adapter.this.ignoredMethods, Adapter.this.auxiliaryTypes);
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(Object var1) {
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else if (!this.methodDescription.equals(((InnerTypeDefinitionForMethodAdapter)var1).methodDescription)) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return Adapter.this.equals(Adapter.this);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return (this.getClass().hashCode() * 31 + this.methodDescription.hashCode()) * 31 + Adapter.this.hashCode();
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Enhance(
&nbsp;                    includeSyntheticFields = true
&nbsp;                )
&nbsp;                protected class InnerTypeDefinitionForTypeAdapter extends Delegator&lt;U&gt; implements InnerTypeDefinition.ForType&lt;U&gt; {
&nbsp;                    private final TypeDescription typeDescription;
&nbsp;
&nbsp;                    protected InnerTypeDefinitionForTypeAdapter(TypeDescription typeDescription) {
&nbsp;                        this.typeDescription = typeDescription;
&nbsp;                    }
&nbsp;
&nbsp;                    public Builder&lt;U&gt; asAnonymousType() {
&nbsp;                        return Adapter.this.materialize(Adapter.this.instrumentedType.withDeclaringType(TypeDescription.UNDEFINED).withEnclosingType(this.typeDescription).withAnonymousClass(true), Adapter.this.fieldRegistry, Adapter.this.methodRegistry, Adapter.this.recordComponentRegistry, Adapter.this.typeAttributeAppender, Adapter.this.asmVisitorWrapper, Adapter.this.classFileVersion, Adapter.this.auxiliaryTypeNamingStrategy, Adapter.this.annotationValueFilterFactory, Adapter.this.annotationRetention, Adapter.this.implementationContextFactory, Adapter.this.methodGraphCompiler, Adapter.this.typeValidation, Adapter.this.visibilityBridgeStrategy, Adapter.this.classWriterStrategy, Adapter.this.ignoredMethods, Adapter.this.auxiliaryTypes);
&nbsp;                    }
&nbsp;
&nbsp;                    public Builder&lt;U&gt; asMemberType() {
&nbsp;                        return Adapter.this.materialize(Adapter.this.instrumentedType.withDeclaringType(this.typeDescription).withEnclosingType(this.typeDescription).withAnonymousClass(false).withLocalClass(false), Adapter.this.fieldRegistry, Adapter.this.methodRegistry, Adapter.this.recordComponentRegistry, Adapter.this.typeAttributeAppender, Adapter.this.asmVisitorWrapper, Adapter.this.classFileVersion, Adapter.this.auxiliaryTypeNamingStrategy, Adapter.this.annotationValueFilterFactory, Adapter.this.annotationRetention, Adapter.this.implementationContextFactory, Adapter.this.methodGraphCompiler, Adapter.this.typeValidation, Adapter.this.visibilityBridgeStrategy, Adapter.this.classWriterStrategy, Adapter.this.ignoredMethods, Adapter.this.auxiliaryTypes);
&nbsp;                    }
&nbsp;
&nbsp;                    protected Builder&lt;U&gt; materialize() {
&nbsp;                        return Adapter.this.materialize(Adapter.this.instrumentedType.withDeclaringType(TypeDescription.UNDEFINED).withEnclosingType(this.typeDescription).withLocalClass(true), Adapter.this.fieldRegistry, Adapter.this.methodRegistry, Adapter.this.recordComponentRegistry, Adapter.this.typeAttributeAppender, Adapter.this.asmVisitorWrapper, Adapter.this.classFileVersion, Adapter.this.auxiliaryTypeNamingStrategy, Adapter.this.annotationValueFilterFactory, Adapter.this.annotationRetention, Adapter.this.implementationContextFactory, Adapter.this.methodGraphCompiler, Adapter.this.typeValidation, Adapter.this.visibilityBridgeStrategy, Adapter.this.classWriterStrategy, Adapter.this.ignoredMethods, Adapter.this.auxiliaryTypes);
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(Object var1) {
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else if (!this.typeDescription.equals(((InnerTypeDefinitionForTypeAdapter)var1).typeDescription)) {
<b class="fc">&nbsp;                            return false;</b>
<b class="fc">&nbsp;                        } else {</b>
<b class="fc">&nbsp;                            return Adapter.this.equals(Adapter.this);</b>
<b class="fc">&nbsp;                        }</b>
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return (this.getClass().hashCode() * 31 + this.typeDescription.hashCode()) * 31 + Adapter.this.hashCode();
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public abstract static class Delegator&lt;U&gt; extends AbstractBase&lt;U&gt; {
&nbsp;                public Delegator() {
&nbsp;                }
&nbsp;
&nbsp;                public Builder&lt;U&gt; visit(AsmVisitorWrapper asmVisitorWrapper) {
&nbsp;                    return this.materialize().visit(asmVisitorWrapper);
&nbsp;                }
&nbsp;
&nbsp;                public Builder&lt;U&gt; initializer(LoadedTypeInitializer loadedTypeInitializer) {
&nbsp;                    return this.materialize().initializer(loadedTypeInitializer);
&nbsp;                }
<b class="fc">&nbsp;</b>
&nbsp;                public Builder&lt;U&gt; annotateType(Collection&lt;? extends AnnotationDescription&gt; annotations) {
&nbsp;                    return this.materialize().annotateType(annotations);
&nbsp;                }
&nbsp;
&nbsp;                public Builder&lt;U&gt; attribute(TypeAttributeAppender typeAttributeAppender) {
&nbsp;                    return this.materialize().attribute(typeAttributeAppender);
&nbsp;                }
&nbsp;
&nbsp;                public Builder&lt;U&gt; modifiers(int modifiers) {
&nbsp;                    return this.materialize().modifiers(modifiers);
&nbsp;                }
&nbsp;
&nbsp;                public Builder&lt;U&gt; merge(Collection&lt;? extends ModifierContributor.ForType&gt; modifierContributors) {
&nbsp;                    return this.materialize().merge(modifierContributors);
&nbsp;                }
&nbsp;
&nbsp;                public Builder&lt;U&gt; suffix(String suffix) {
&nbsp;                    return this.materialize().suffix(suffix);
&nbsp;                }
&nbsp;
&nbsp;                public Builder&lt;U&gt; name(String name) {
&nbsp;                    return this.materialize().name(name);
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                public Builder&lt;U&gt; topLevelType() {
&nbsp;                    return this.materialize().topLevelType();
&nbsp;                }
&nbsp;
&nbsp;                public InnerTypeDefinition.ForType&lt;U&gt; innerTypeOf(TypeDescription type) {
&nbsp;                    return this.materialize().innerTypeOf(type);
&nbsp;                }
&nbsp;
&nbsp;                public InnerTypeDefinition&lt;U&gt; innerTypeOf(MethodDescription.InDefinedShape methodDescription) {
&nbsp;                    return this.materialize().innerTypeOf(methodDescription);
&nbsp;                }
&nbsp;
&nbsp;                public Builder&lt;U&gt; declaredTypes(Collection&lt;? extends TypeDescription&gt; types) {
&nbsp;                    return this.materialize().declaredTypes(types);
&nbsp;                }
&nbsp;
&nbsp;                public Builder&lt;U&gt; nestHost(TypeDescription type) {
&nbsp;                    return this.materialize().nestHost(type);
&nbsp;                }
&nbsp;
&nbsp;                public Builder&lt;U&gt; nestMembers(Collection&lt;? extends TypeDescription&gt; types) {
&nbsp;                    return this.materialize().nestMembers(types);
&nbsp;                }
&nbsp;
&nbsp;                public Builder&lt;U&gt; permittedSubclass(Collection&lt;? extends TypeDescription&gt; types) {
&nbsp;                    return this.materialize().permittedSubclass(types);
&nbsp;                }
&nbsp;
&nbsp;                public Builder&lt;U&gt; unsealed() {
&nbsp;                    return this.materialize().unsealed();
&nbsp;                }
&nbsp;
&nbsp;                public MethodDefinition.ImplementationDefinition.Optional&lt;U&gt; implement(Collection&lt;? extends TypeDefinition&gt; interfaceTypes) {
&nbsp;                    return this.materialize().implement(interfaceTypes);
&nbsp;                }
&nbsp;
&nbsp;                public Builder&lt;U&gt; initializer(ByteCodeAppender byteCodeAppender) {
&nbsp;                    return this.materialize().initializer(byteCodeAppender);
&nbsp;                }
&nbsp;
&nbsp;                public Builder&lt;U&gt; ignoreAlso(ElementMatcher&lt;? super MethodDescription&gt; ignoredMethods) {
&nbsp;                    return this.materialize().ignoreAlso(ignoredMethods);
&nbsp;                }
&nbsp;
&nbsp;                public Builder&lt;U&gt; ignoreAlso(LatentMatcher&lt;? super MethodDescription&gt; ignoredMethods) {
&nbsp;                    return this.materialize().ignoreAlso(ignoredMethods);
&nbsp;                }
&nbsp;
&nbsp;                public TypeVariableDefinition&lt;U&gt; typeVariable(String symbol, Collection&lt;? extends TypeDefinition&gt; bounds) {
&nbsp;                    return this.materialize().typeVariable(symbol, bounds);
&nbsp;                }
&nbsp;
&nbsp;                public Builder&lt;U&gt; transform(ElementMatcher&lt;? super TypeDescription.Generic&gt; matcher, Transformer&lt;TypeVariableToken&gt; transformer) {
&nbsp;                    return this.materialize().transform(matcher, transformer);
&nbsp;                }
&nbsp;
&nbsp;                public FieldDefinition.Optional.Valuable&lt;U&gt; defineField(String name, TypeDefinition type, int modifiers) {
&nbsp;                    return this.materialize().defineField(name, type, modifiers);
&nbsp;                }
&nbsp;
&nbsp;                public FieldDefinition.Valuable&lt;U&gt; field(LatentMatcher&lt;? super FieldDescription&gt; matcher) {
&nbsp;                    return this.materialize().field(matcher);
&nbsp;                }
&nbsp;
&nbsp;                public MethodDefinition.ParameterDefinition.Initial&lt;U&gt; defineMethod(String name, TypeDefinition returnType, int modifiers) {
&nbsp;                    return this.materialize().defineMethod(name, returnType, modifiers);
&nbsp;                }
&nbsp;
&nbsp;                public MethodDefinition.ParameterDefinition.Initial&lt;U&gt; defineConstructor(int modifiers) {
&nbsp;                    return this.materialize().defineConstructor(modifiers);
&nbsp;                }
&nbsp;
&nbsp;                public MethodDefinition.ImplementationDefinition&lt;U&gt; invokable(LatentMatcher&lt;? super MethodDescription&gt; matcher) {
&nbsp;                    return this.materialize().invokable(matcher);
&nbsp;                }
&nbsp;
&nbsp;                public Builder&lt;U&gt; require(Collection&lt;DynamicType&gt; auxiliaryTypes) {
&nbsp;                    return this.materialize().require(auxiliaryTypes);
&nbsp;                }
&nbsp;
&nbsp;                public RecordComponentDefinition.Optional&lt;U&gt; defineRecordComponent(String name, TypeDefinition type) {
&nbsp;                    return this.materialize().defineRecordComponent(name, type);
&nbsp;                }
&nbsp;
&nbsp;                public RecordComponentDefinition.Optional&lt;U&gt; define(RecordComponentDescription recordComponentDescription) {
&nbsp;                    return this.materialize().define(recordComponentDescription);
&nbsp;                }
&nbsp;
&nbsp;                public RecordComponentDefinition&lt;U&gt; recordComponent(ElementMatcher&lt;? super RecordComponentDescription&gt; matcher) {
&nbsp;                    return this.materialize().recordComponent(matcher);
&nbsp;                }
&nbsp;
&nbsp;                public RecordComponentDefinition&lt;U&gt; recordComponent(LatentMatcher&lt;? super RecordComponentDescription&gt; matcher) {
&nbsp;                    return this.materialize().recordComponent(matcher);
&nbsp;                }
&nbsp;
&nbsp;                public Unloaded&lt;U&gt; make() {
&nbsp;                    return this.materialize().make();
&nbsp;                }
&nbsp;
&nbsp;                public Unloaded&lt;U&gt; make(TypeResolutionStrategy typeResolutionStrategy) {
&nbsp;                    return this.materialize().make(typeResolutionStrategy);
&nbsp;                }
&nbsp;
&nbsp;                public Unloaded&lt;U&gt; make(TypePool typePool) {
&nbsp;                    return this.materialize().make(typePool);
&nbsp;                }
&nbsp;
&nbsp;                public Unloaded&lt;U&gt; make(TypeResolutionStrategy typeResolutionStrategy, TypePool typePool) {
&nbsp;                    return this.materialize().make(typeResolutionStrategy, typePool);
&nbsp;                }
&nbsp;
&nbsp;                public TypeDescription toTypeDescription() {
&nbsp;                    return this.materialize().toTypeDescription();
&nbsp;                }
&nbsp;
&nbsp;                protected abstract Builder&lt;U&gt; materialize();
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public interface RecordComponentDefinition&lt;S&gt; {
&nbsp;            Optional&lt;S&gt; annotateRecordComponent(Annotation... var1);
&nbsp;
&nbsp;            Optional&lt;S&gt; annotateRecordComponent(List&lt;? extends Annotation&gt; var1);
&nbsp;
&nbsp;            Optional&lt;S&gt; annotateRecordComponent(AnnotationDescription... var1);
&nbsp;
&nbsp;            Optional&lt;S&gt; annotateRecordComponent(Collection&lt;? extends AnnotationDescription&gt; var1);
&nbsp;
&nbsp;            Optional&lt;S&gt; attribute(RecordComponentAttributeAppender.Factory var1);
&nbsp;
&nbsp;            Optional&lt;S&gt; transform(Transformer&lt;RecordComponentDescription&gt; var1);
&nbsp;
&nbsp;            public interface Optional&lt;U&gt; extends RecordComponentDefinition&lt;U&gt;, Builder&lt;U&gt; {
&nbsp;                public abstract static class AbstractBase&lt;U&gt; extends AbstractBase.Delegator&lt;U&gt; implements Optional&lt;U&gt; {
&nbsp;                    public AbstractBase() {
&nbsp;                    }
&nbsp;
&nbsp;                    public Optional&lt;U&gt; annotateRecordComponent(Annotation... annotation) {
&nbsp;                        return this.annotateRecordComponent(Arrays.asList(annotation));
&nbsp;                    }
&nbsp;
&nbsp;                    public Optional&lt;U&gt; annotateRecordComponent(List&lt;? extends Annotation&gt; annotations) {
&nbsp;                        return this.annotateRecordComponent((Collection)(new AnnotationList.ForLoadedAnnotations(annotations)));
&nbsp;                    }
&nbsp;
&nbsp;                    public Optional&lt;U&gt; annotateRecordComponent(AnnotationDescription... annotation) {
&nbsp;                        return this.annotateRecordComponent((Collection)Arrays.asList(annotation));
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public interface MethodDefinition&lt;S&gt; extends Builder&lt;S&gt; {
&nbsp;            MethodDefinition&lt;S&gt; annotateMethod(Annotation... var1);
&nbsp;
&nbsp;            MethodDefinition&lt;S&gt; annotateMethod(List&lt;? extends Annotation&gt; var1);
<b class="fc">&nbsp;</b>
&nbsp;            MethodDefinition&lt;S&gt; annotateMethod(AnnotationDescription... var1);
&nbsp;
&nbsp;            MethodDefinition&lt;S&gt; annotateMethod(Collection&lt;? extends AnnotationDescription&gt; var1);
&nbsp;
&nbsp;            MethodDefinition&lt;S&gt; annotateParameter(int var1, Annotation... var2);
&nbsp;
&nbsp;            MethodDefinition&lt;S&gt; annotateParameter(int var1, List&lt;? extends Annotation&gt; var2);
&nbsp;
&nbsp;            MethodDefinition&lt;S&gt; annotateParameter(int var1, AnnotationDescription... var2);
&nbsp;
&nbsp;            MethodDefinition&lt;S&gt; annotateParameter(int var1, Collection&lt;? extends AnnotationDescription&gt; var2);
&nbsp;
&nbsp;            MethodDefinition&lt;S&gt; attribute(MethodAttributeAppender.Factory var1);
&nbsp;
&nbsp;            MethodDefinition&lt;S&gt; transform(Transformer&lt;MethodDescription&gt; var1);
&nbsp;
&nbsp;            public abstract static class AbstractBase&lt;U&gt; extends AbstractBase.Delegator&lt;U&gt; implements MethodDefinition&lt;U&gt; {
&nbsp;                public AbstractBase() {
&nbsp;                }
&nbsp;
&nbsp;                public MethodDefinition&lt;U&gt; annotateMethod(Annotation... annotation) {
&nbsp;                    return this.annotateMethod(Arrays.asList(annotation));
&nbsp;                }
&nbsp;
&nbsp;                public MethodDefinition&lt;U&gt; annotateMethod(List&lt;? extends Annotation&gt; annotations) {
&nbsp;                    return this.annotateMethod((Collection)(new AnnotationList.ForLoadedAnnotations(annotations)));
&nbsp;                }
&nbsp;
&nbsp;                public MethodDefinition&lt;U&gt; annotateMethod(AnnotationDescription... annotation) {
&nbsp;                    return this.annotateMethod((Collection)Arrays.asList(annotation));
&nbsp;                }
&nbsp;
&nbsp;                public MethodDefinition&lt;U&gt; annotateParameter(int index, Annotation... annotation) {
&nbsp;                    return this.annotateParameter(index, Arrays.asList(annotation));
&nbsp;                }
&nbsp;
&nbsp;                public MethodDefinition&lt;U&gt; annotateParameter(int index, List&lt;? extends Annotation&gt; annotations) {
&nbsp;                    return this.annotateParameter(index, (Collection)(new AnnotationList.ForLoadedAnnotations(annotations)));
&nbsp;                }
&nbsp;
&nbsp;                public MethodDefinition&lt;U&gt; annotateParameter(int index, AnnotationDescription... annotation) {
&nbsp;                    return this.annotateParameter(index, (Collection)Arrays.asList(annotation));
&nbsp;                }
&nbsp;
&nbsp;                @Enhance
&nbsp;                protected abstract static class Adapter&lt;V&gt; extends ReceiverTypeDefinition.AbstractBase&lt;V&gt; {
&nbsp;                    protected final MethodRegistry.Handler handler;
&nbsp;                    protected final MethodAttributeAppender.Factory methodAttributeAppenderFactory;
&nbsp;                    protected final Transformer&lt;MethodDescription&gt; transformer;
&nbsp;
&nbsp;                    protected Adapter(MethodRegistry.Handler handler, MethodAttributeAppender.Factory methodAttributeAppenderFactory, Transformer&lt;MethodDescription&gt; transformer) {
&nbsp;                        this.handler = handler;
&nbsp;                        this.methodAttributeAppenderFactory = methodAttributeAppenderFactory;
&nbsp;                        this.transformer = transformer;
&nbsp;                    }
&nbsp;
&nbsp;                    public MethodDefinition&lt;V&gt; attribute(MethodAttributeAppender.Factory methodAttributeAppenderFactory) {
&nbsp;                        return this.materialize(this.handler, new MethodAttributeAppender.Factory.Compound(new MethodAttributeAppender.Factory[]{this.methodAttributeAppenderFactory, methodAttributeAppenderFactory}), this.transformer);
&nbsp;                    }
&nbsp;
&nbsp;                    public MethodDefinition&lt;V&gt; transform(Transformer&lt;MethodDescription&gt; transformer) {
&nbsp;                        return this.materialize(this.handler, this.methodAttributeAppenderFactory, new Transformer.Compound(new Transformer[]{this.transformer, transformer}));
&nbsp;                    }
&nbsp;
&nbsp;                    protected abstract MethodDefinition&lt;V&gt; materialize(MethodRegistry.Handler var1, MethodAttributeAppender.Factory var2, Transformer&lt;MethodDescription&gt; var3);
&nbsp;
&nbsp;                    public boolean equals(Object var1) {
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else if (!this.handler.equals(((Adapter)var1).handler)) {
&nbsp;                            return false;
&nbsp;                        } else if (!this.methodAttributeAppenderFactory.equals(((Adapter)var1).methodAttributeAppenderFactory)) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return this.transformer.equals(((Adapter)var1).transformer);
&nbsp;                        }
&nbsp;                    }
&nbsp;
<b class="fc">&nbsp;                    public int hashCode() {</b>
&nbsp;                        return ((this.getClass().hashCode() * 31 + this.handler.hashCode()) * 31 + this.methodAttributeAppenderFactory.hashCode()) * 31 + this.transformer.hashCode();
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public interface ParameterDefinition&lt;U&gt; extends ExceptionDefinition&lt;U&gt; {
&nbsp;                Annotatable&lt;U&gt; withParameter(Type var1, String var2, ModifierContributor.ForParameter... var3);
&nbsp;
&nbsp;                Annotatable&lt;U&gt; withParameter(Type var1, String var2, Collection&lt;? extends ModifierContributor.ForParameter&gt; var3);
&nbsp;
&nbsp;                Annotatable&lt;U&gt; withParameter(Type var1, String var2, int var3);
&nbsp;
&nbsp;                Annotatable&lt;U&gt; withParameter(TypeDefinition var1, String var2, ModifierContributor.ForParameter... var3);
&nbsp;
&nbsp;                Annotatable&lt;U&gt; withParameter(TypeDefinition var1, String var2, Collection&lt;? extends ModifierContributor.ForParameter&gt; var3);
&nbsp;
&nbsp;                Annotatable&lt;U&gt; withParameter(TypeDefinition var1, String var2, int var3);
&nbsp;
&nbsp;                public abstract static class AbstractBase&lt;V&gt; extends ExceptionDefinition.AbstractBase&lt;V&gt; implements ParameterDefinition&lt;V&gt; {
&nbsp;                    public AbstractBase() {
&nbsp;                    }
&nbsp;
&nbsp;                    public Annotatable&lt;V&gt; withParameter(Type type, String name, ModifierContributor.ForParameter... modifierContributor) {
&nbsp;                        return this.withParameter((Type)type, name, (Collection)Arrays.asList(modifierContributor));
&nbsp;                    }
&nbsp;
&nbsp;                    public Annotatable&lt;V&gt; withParameter(Type type, String name, Collection&lt;? extends ModifierContributor.ForParameter&gt; modifierContributors) {
&nbsp;                        return this.withParameter(type, name, Resolver.of(modifierContributors).resolve());
&nbsp;                    }
&nbsp;
&nbsp;                    public Annotatable&lt;V&gt; withParameter(Type type, String name, int modifiers) {
&nbsp;                        return this.withParameter(Sort.describe(type), name, modifiers);
&nbsp;                    }
&nbsp;
&nbsp;                    public Annotatable&lt;V&gt; withParameter(TypeDefinition type, String name, ModifierContributor.ForParameter... modifierContributor) {
&nbsp;                        return this.withParameter((TypeDefinition)type, name, (Collection)Arrays.asList(modifierContributor));
&nbsp;                    }
&nbsp;
&nbsp;                    public Annotatable&lt;V&gt; withParameter(TypeDefinition type, String name, Collection&lt;? extends ModifierContributor.ForParameter&gt; modifierContributors) {
&nbsp;                        return this.withParameter(type, name, Resolver.of(modifierContributors).resolve());
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public interface Initial&lt;V&gt; extends ParameterDefinition&lt;V&gt;, Simple&lt;V&gt; {
&nbsp;                    ExceptionDefinition&lt;V&gt; withParameters(Type... var1);
&nbsp;
&nbsp;                    ExceptionDefinition&lt;V&gt; withParameters(List&lt;? extends Type&gt; var1);
&nbsp;
&nbsp;                    ExceptionDefinition&lt;V&gt; withParameters(TypeDefinition... var1);
&nbsp;
&nbsp;                    ExceptionDefinition&lt;V&gt; withParameters(Collection&lt;? extends TypeDefinition&gt; var1);
&nbsp;
&nbsp;                    public abstract static class AbstractBase&lt;W&gt; extends AbstractBase&lt;W&gt; implements Initial&lt;W&gt; {
&nbsp;                        public AbstractBase() {
&nbsp;                        }
&nbsp;
&nbsp;                        public Simple.Annotatable&lt;W&gt; withParameter(Type type) {
&nbsp;                            return this.withParameter(Sort.describe(type));
&nbsp;                        }
&nbsp;
&nbsp;                        public ExceptionDefinition&lt;W&gt; withParameters(Type... type) {
&nbsp;                            return this.withParameters(Arrays.asList(type));
&nbsp;                        }
&nbsp;
&nbsp;                        public ExceptionDefinition&lt;W&gt; withParameters(List&lt;? extends Type&gt; types) {
&nbsp;                            return this.withParameters((Collection)(new TypeList.Generic.ForLoadedTypes(types)));
&nbsp;                        }
&nbsp;
&nbsp;                        public ExceptionDefinition&lt;W&gt; withParameters(TypeDefinition... type) {
&nbsp;                            return this.withParameters((Collection)Arrays.asList(type));
&nbsp;                        }
&nbsp;
&nbsp;                        public ExceptionDefinition&lt;W&gt; withParameters(Collection&lt;? extends TypeDefinition&gt; types) {
&nbsp;                            Simple&lt;W&gt; parameterDefinition = this;
&nbsp;
&nbsp;                            TypeDefinition type;
&nbsp;                            for(Iterator var3 = types.iterator(); var3.hasNext(); parameterDefinition = ((Simple)parameterDefinition).withParameter(type)) {
&nbsp;                                type = (TypeDefinition)var3.next();
&nbsp;                            }
&nbsp;
&nbsp;                            return (ExceptionDefinition)parameterDefinition;
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public interface Simple&lt;V&gt; extends ExceptionDefinition&lt;V&gt; {
&nbsp;                    Annotatable&lt;V&gt; withParameter(Type var1);
&nbsp;
&nbsp;                    Annotatable&lt;V&gt; withParameter(TypeDefinition var1);
&nbsp;
&nbsp;                    public abstract static class AbstractBase&lt;W&gt; extends ExceptionDefinition.AbstractBase&lt;W&gt; implements Simple&lt;W&gt; {
&nbsp;                        public AbstractBase() {
&nbsp;                        }
&nbsp;
&nbsp;                        public Annotatable&lt;W&gt; withParameter(Type type) {
&nbsp;                            return this.withParameter(Sort.describe(type));
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public interface Annotatable&lt;V&gt; extends Simple&lt;V&gt; {
&nbsp;                        Annotatable&lt;V&gt; annotateParameter(Annotation... var1);
&nbsp;
&nbsp;                        Annotatable&lt;V&gt; annotateParameter(List&lt;? extends Annotation&gt; var1);
&nbsp;
&nbsp;                        Annotatable&lt;V&gt; annotateParameter(AnnotationDescription... var1);
&nbsp;
&nbsp;                        Annotatable&lt;V&gt; annotateParameter(Collection&lt;? extends AnnotationDescription&gt; var1);
&nbsp;
&nbsp;                        public abstract static class AbstractBase&lt;W&gt; extends AbstractBase&lt;W&gt; implements Annotatable&lt;W&gt; {
&nbsp;                            public AbstractBase() {
&nbsp;                            }
&nbsp;
&nbsp;                            public Annotatable&lt;W&gt; annotateParameter(Annotation... annotation) {
&nbsp;                                return this.annotateParameter(Arrays.asList(annotation));
&nbsp;                            }
&nbsp;
&nbsp;                            public Annotatable&lt;W&gt; annotateParameter(List&lt;? extends Annotation&gt; annotations) {
&nbsp;                                return this.annotateParameter((Collection)(new AnnotationList.ForLoadedAnnotations(annotations)));
&nbsp;                            }
&nbsp;
&nbsp;                            public Annotatable&lt;W&gt; annotateParameter(AnnotationDescription... annotation) {
&nbsp;                                return this.annotateParameter((Collection)Arrays.asList(annotation));
&nbsp;                            }
&nbsp;
&nbsp;                            protected abstract static class Adapter&lt;X&gt; extends AbstractBase&lt;X&gt; {
&nbsp;                                protected Adapter() {
&nbsp;                                }
&nbsp;
&nbsp;                                public Annotatable&lt;X&gt; withParameter(TypeDefinition type) {
&nbsp;                                    return this.materialize().withParameter(type);
&nbsp;                                }
&nbsp;
&nbsp;                                public ExceptionDefinition&lt;X&gt; throwing(Collection&lt;? extends TypeDefinition&gt; types) {
&nbsp;                                    return this.materialize().throwing(types);
&nbsp;                                }
&nbsp;
&nbsp;                                public TypeVariableDefinition.Annotatable&lt;X&gt; typeVariable(String symbol, Collection&lt;? extends TypeDefinition&gt; bounds) {
&nbsp;                                    return this.materialize().typeVariable(symbol, bounds);
&nbsp;                                }
&nbsp;
&nbsp;                                public ReceiverTypeDefinition&lt;X&gt; intercept(Implementation implementation) {
&nbsp;                                    return this.materialize().intercept(implementation);
&nbsp;                                }
&nbsp;
&nbsp;                                public ReceiverTypeDefinition&lt;X&gt; withoutCode() {
&nbsp;                                    return this.materialize().withoutCode();
&nbsp;                                }
&nbsp;
&nbsp;                                public ReceiverTypeDefinition&lt;X&gt; defaultValue(AnnotationValue&lt;?, ?&gt; annotationValue) {
&nbsp;                                    return this.materialize().defaultValue(annotationValue);
&nbsp;                                }
&nbsp;
&nbsp;                                public &lt;V&gt; ReceiverTypeDefinition&lt;X&gt; defaultValue(V value, Class&lt;? extends V&gt; type) {
&nbsp;                                    return this.materialize().defaultValue(value, type);
&nbsp;                                }
&nbsp;
&nbsp;                                protected abstract Simple&lt;X&gt; materialize();
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public interface Annotatable&lt;V&gt; extends ParameterDefinition&lt;V&gt; {
&nbsp;                    Annotatable&lt;V&gt; annotateParameter(Annotation... var1);
&nbsp;
&nbsp;                    Annotatable&lt;V&gt; annotateParameter(List&lt;? extends Annotation&gt; var1);
&nbsp;
&nbsp;                    Annotatable&lt;V&gt; annotateParameter(AnnotationDescription... var1);
&nbsp;
&nbsp;                    Annotatable&lt;V&gt; annotateParameter(Collection&lt;? extends AnnotationDescription&gt; var1);
&nbsp;
&nbsp;                    public abstract static class AbstractBase&lt;W&gt; extends AbstractBase&lt;W&gt; implements Annotatable&lt;W&gt; {
&nbsp;                        public AbstractBase() {
&nbsp;                        }
&nbsp;
&nbsp;                        public Annotatable&lt;W&gt; annotateParameter(Annotation... annotation) {
&nbsp;                            return this.annotateParameter(Arrays.asList(annotation));
&nbsp;                        }
&nbsp;
&nbsp;                        public Annotatable&lt;W&gt; annotateParameter(List&lt;? extends Annotation&gt; annotations) {
&nbsp;                            return this.annotateParameter((Collection)(new AnnotationList.ForLoadedAnnotations(annotations)));
&nbsp;                        }
&nbsp;
&nbsp;                        public Annotatable&lt;W&gt; annotateParameter(AnnotationDescription... annotation) {
&nbsp;                            return this.annotateParameter((Collection)Arrays.asList(annotation));
&nbsp;                        }
&nbsp;
&nbsp;                        protected abstract static class Adapter&lt;X&gt; extends AbstractBase&lt;X&gt; {
&nbsp;                            protected Adapter() {
&nbsp;                            }
&nbsp;
&nbsp;                            public Annotatable&lt;X&gt; withParameter(TypeDefinition type, String name, int modifiers) {
&nbsp;                                return this.materialize().withParameter(type, name, modifiers);
<b class="fc">&nbsp;                            }</b>
&nbsp;
&nbsp;                            public ExceptionDefinition&lt;X&gt; throwing(Collection&lt;? extends TypeDefinition&gt; types) {
&nbsp;                                return this.materialize().throwing(types);
&nbsp;                            }
&nbsp;
&nbsp;                            public TypeVariableDefinition.Annotatable&lt;X&gt; typeVariable(String symbol, Collection&lt;? extends TypeDefinition&gt; bounds) {
&nbsp;                                return this.materialize().typeVariable(symbol, bounds);
&nbsp;                            }
&nbsp;
&nbsp;                            public ReceiverTypeDefinition&lt;X&gt; intercept(Implementation implementation) {
&nbsp;                                return this.materialize().intercept(implementation);
&nbsp;                            }
&nbsp;
&nbsp;                            public ReceiverTypeDefinition&lt;X&gt; withoutCode() {
&nbsp;                                return this.materialize().withoutCode();
&nbsp;                            }
&nbsp;
&nbsp;                            public ReceiverTypeDefinition&lt;X&gt; defaultValue(AnnotationValue&lt;?, ?&gt; annotationValue) {
&nbsp;                                return this.materialize().defaultValue(annotationValue);
&nbsp;                            }
&nbsp;
&nbsp;                            public &lt;V&gt; ReceiverTypeDefinition&lt;X&gt; defaultValue(V value, Class&lt;? extends V&gt; type) {
&nbsp;                                return this.materialize().defaultValue(value, type);
&nbsp;                            }
&nbsp;
&nbsp;                            protected abstract ParameterDefinition&lt;X&gt; materialize();
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public interface ExceptionDefinition&lt;U&gt; extends TypeVariableDefinition&lt;U&gt; {
&nbsp;                ExceptionDefinition&lt;U&gt; throwing(Type... var1);
&nbsp;
&nbsp;                ExceptionDefinition&lt;U&gt; throwing(List&lt;? extends Type&gt; var1);
&nbsp;
&nbsp;                ExceptionDefinition&lt;U&gt; throwing(TypeDefinition... var1);
&nbsp;
&nbsp;                ExceptionDefinition&lt;U&gt; throwing(Collection&lt;? extends TypeDefinition&gt; var1);
&nbsp;
&nbsp;                public abstract static class AbstractBase&lt;V&gt; extends TypeVariableDefinition.AbstractBase&lt;V&gt; implements ExceptionDefinition&lt;V&gt; {
&nbsp;                    public AbstractBase() {
&nbsp;                    }
&nbsp;
&nbsp;                    public ExceptionDefinition&lt;V&gt; throwing(Type... type) {
&nbsp;                        return this.throwing(Arrays.asList(type));
&nbsp;                    }
&nbsp;
&nbsp;                    public ExceptionDefinition&lt;V&gt; throwing(List&lt;? extends Type&gt; types) {
&nbsp;                        return this.throwing((Collection)(new TypeList.Generic.ForLoadedTypes(types)));
&nbsp;                    }
&nbsp;
&nbsp;                    public ExceptionDefinition&lt;V&gt; throwing(TypeDefinition... type) {
&nbsp;                        return this.throwing((Collection)Arrays.asList(type));
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public interface TypeVariableDefinition&lt;U&gt; extends ImplementationDefinition&lt;U&gt; {
&nbsp;                Annotatable&lt;U&gt; typeVariable(String var1);
&nbsp;
&nbsp;                Annotatable&lt;U&gt; typeVariable(String var1, Type... var2);
&nbsp;
&nbsp;                Annotatable&lt;U&gt; typeVariable(String var1, List&lt;? extends Type&gt; var2);
&nbsp;
&nbsp;                Annotatable&lt;U&gt; typeVariable(String var1, TypeDefinition... var2);
&nbsp;
&nbsp;                Annotatable&lt;U&gt; typeVariable(String var1, Collection&lt;? extends TypeDefinition&gt; var2);
&nbsp;
&nbsp;                public abstract static class AbstractBase&lt;V&gt; extends ImplementationDefinition.AbstractBase&lt;V&gt; implements TypeVariableDefinition&lt;V&gt; {
&nbsp;                    public AbstractBase() {
&nbsp;                    }
&nbsp;
&nbsp;                    public Annotatable&lt;V&gt; typeVariable(String symbol) {
&nbsp;                        return this.typeVariable(symbol, Collections.singletonList(Object.class));
<b class="fc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    public Annotatable&lt;V&gt; typeVariable(String symbol, Type... bound) {
&nbsp;                        return this.typeVariable(symbol, Arrays.asList(bound));
&nbsp;                    }
&nbsp;
&nbsp;                    public Annotatable&lt;V&gt; typeVariable(String symbol, List&lt;? extends Type&gt; bounds) {
&nbsp;                        return this.typeVariable(symbol, (Collection)(new TypeList.Generic.ForLoadedTypes(bounds)));
&nbsp;                    }
&nbsp;
&nbsp;                    public Annotatable&lt;V&gt; typeVariable(String symbol, TypeDefinition... bound) {
&nbsp;                        return this.typeVariable(symbol, (Collection)Arrays.asList(bound));
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public interface Annotatable&lt;V&gt; extends TypeVariableDefinition&lt;V&gt; {
&nbsp;                    Annotatable&lt;V&gt; annotateTypeVariable(Annotation... var1);
&nbsp;
&nbsp;                    Annotatable&lt;V&gt; annotateTypeVariable(List&lt;? extends Annotation&gt; var1);
&nbsp;
&nbsp;                    Annotatable&lt;V&gt; annotateTypeVariable(AnnotationDescription... var1);
&nbsp;
&nbsp;                    Annotatable&lt;V&gt; annotateTypeVariable(Collection&lt;? extends AnnotationDescription&gt; var1);
&nbsp;
&nbsp;                    public abstract static class AbstractBase&lt;W&gt; extends AbstractBase&lt;W&gt; implements Annotatable&lt;W&gt; {
&nbsp;                        public AbstractBase() {
&nbsp;                        }
&nbsp;
&nbsp;                        public Annotatable&lt;W&gt; annotateTypeVariable(Annotation... annotation) {
&nbsp;                            return this.annotateTypeVariable(Arrays.asList(annotation));
&nbsp;                        }
&nbsp;
&nbsp;                        public Annotatable&lt;W&gt; annotateTypeVariable(List&lt;? extends Annotation&gt; annotations) {
&nbsp;                            return this.annotateTypeVariable((Collection)(new AnnotationList.ForLoadedAnnotations(annotations)));
&nbsp;                        }
&nbsp;
&nbsp;                        public Annotatable&lt;W&gt; annotateTypeVariable(AnnotationDescription... annotation) {
&nbsp;                            return this.annotateTypeVariable((Collection)Arrays.asList(annotation));
&nbsp;                        }
&nbsp;
&nbsp;                        protected abstract static class Adapter&lt;X&gt; extends AbstractBase&lt;X&gt; {
&nbsp;                            protected Adapter() {
&nbsp;                            }
&nbsp;
&nbsp;                            public Annotatable&lt;X&gt; typeVariable(String symbol, Collection&lt;? extends TypeDefinition&gt; bounds) {
&nbsp;                                return this.materialize().typeVariable(symbol, bounds);
&nbsp;                            }
&nbsp;
&nbsp;                            public ReceiverTypeDefinition&lt;X&gt; intercept(Implementation implementation) {
&nbsp;                                return this.materialize().intercept(implementation);
&nbsp;                            }
&nbsp;
&nbsp;                            public ReceiverTypeDefinition&lt;X&gt; withoutCode() {
&nbsp;                                return this.materialize().withoutCode();
&nbsp;                            }
&nbsp;
&nbsp;                            public ReceiverTypeDefinition&lt;X&gt; defaultValue(AnnotationValue&lt;?, ?&gt; annotationValue) {
&nbsp;                                return this.materialize().defaultValue(annotationValue);
&nbsp;                            }
&nbsp;
&nbsp;                            public &lt;V&gt; ReceiverTypeDefinition&lt;X&gt; defaultValue(V value, Class&lt;? extends V&gt; type) {
&nbsp;                                return this.materialize().defaultValue(value, type);
&nbsp;                            }
&nbsp;
&nbsp;                            protected abstract ParameterDefinition&lt;X&gt; materialize();
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public interface ImplementationDefinition&lt;U&gt; {
&nbsp;                ReceiverTypeDefinition&lt;U&gt; intercept(Implementation var1);
&nbsp;
&nbsp;                ReceiverTypeDefinition&lt;U&gt; withoutCode();
&nbsp;
&nbsp;                ReceiverTypeDefinition&lt;U&gt; defaultValue(AnnotationValue&lt;?, ?&gt; var1);
&nbsp;
&nbsp;                &lt;W&gt; ReceiverTypeDefinition&lt;U&gt; defaultValue(W var1, Class&lt;? extends W&gt; var2);
&nbsp;
&nbsp;                public abstract static class AbstractBase&lt;V&gt; implements ImplementationDefinition&lt;V&gt; {
&nbsp;                    public AbstractBase() {
&nbsp;                    }
&nbsp;
&nbsp;                    public &lt;W&gt; ReceiverTypeDefinition&lt;V&gt; defaultValue(W value, Class&lt;? extends W&gt; type) {
&nbsp;                        return this.defaultValue(ForLoadedAnnotation.asValue(value, type));
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public interface Optional&lt;V&gt; extends ImplementationDefinition&lt;V&gt;, Builder&lt;V&gt; {
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public interface ReceiverTypeDefinition&lt;U&gt; extends MethodDefinition&lt;U&gt; {
&nbsp;                MethodDefinition&lt;U&gt; receiverType(AnnotatedElement var1);
&nbsp;
&nbsp;                MethodDefinition&lt;U&gt; receiverType(TypeDescription.Generic var1);
&nbsp;
&nbsp;                public abstract static class AbstractBase&lt;V&gt; extends AbstractBase&lt;V&gt; implements ReceiverTypeDefinition&lt;V&gt; {
&nbsp;                    public AbstractBase() {
&nbsp;                    }
&nbsp;
&nbsp;                    public MethodDefinition&lt;V&gt; receiverType(AnnotatedElement receiverType) {
&nbsp;                        return this.receiverType(Sort.describeAnnotated(receiverType));
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public interface FieldDefinition&lt;S&gt; {
&nbsp;            Optional&lt;S&gt; annotateField(Annotation... var1);
&nbsp;
&nbsp;            Optional&lt;S&gt; annotateField(List&lt;? extends Annotation&gt; var1);
&nbsp;
&nbsp;            Optional&lt;S&gt; annotateField(AnnotationDescription... var1);
&nbsp;
&nbsp;            Optional&lt;S&gt; annotateField(Collection&lt;? extends AnnotationDescription&gt; var1);
&nbsp;
&nbsp;            Optional&lt;S&gt; attribute(FieldAttributeAppender.Factory var1);
&nbsp;
&nbsp;            Optional&lt;S&gt; transform(Transformer&lt;FieldDescription&gt; var1);
&nbsp;
&nbsp;            public interface Optional&lt;U&gt; extends FieldDefinition&lt;U&gt;, Builder&lt;U&gt; {
&nbsp;                public abstract static class AbstractBase&lt;U&gt; extends AbstractBase.Delegator&lt;U&gt; implements Optional&lt;U&gt; {
&nbsp;                    public AbstractBase() {
&nbsp;                    }
&nbsp;
&nbsp;                    public Optional&lt;U&gt; annotateField(Annotation... annotation) {
&nbsp;                        return this.annotateField(Arrays.asList(annotation));
&nbsp;                    }
&nbsp;
&nbsp;                    public Optional&lt;U&gt; annotateField(List&lt;? extends Annotation&gt; annotations) {
&nbsp;                        return this.annotateField((Collection)(new AnnotationList.ForLoadedAnnotations(annotations)));
&nbsp;                    }
&nbsp;
&nbsp;                    public Optional&lt;U&gt; annotateField(AnnotationDescription... annotation) {
&nbsp;                        return this.annotateField((Collection)Arrays.asList(annotation));
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public interface Valuable&lt;V&gt; extends Valuable&lt;V&gt;, Optional&lt;V&gt; {
&nbsp;                    public abstract static class AbstractBase&lt;U&gt; extends AbstractBase&lt;U&gt; implements Valuable&lt;U&gt; {
&nbsp;                        public AbstractBase() {
&nbsp;                        }
&nbsp;
&nbsp;                        public Optional&lt;U&gt; value(boolean value) {
&nbsp;                            return this.defaultValue(value ? 1 : 0);
&nbsp;                        }
&nbsp;
&nbsp;                        public Optional&lt;U&gt; value(int value) {
&nbsp;                            return this.defaultValue(value);
&nbsp;                        }
&nbsp;
&nbsp;                        public Optional&lt;U&gt; value(long value) {
&nbsp;                            return this.defaultValue(value);
&nbsp;                        }
&nbsp;
&nbsp;                        public Optional&lt;U&gt; value(float value) {
&nbsp;                            return this.defaultValue(value);
&nbsp;                        }
&nbsp;
&nbsp;                        public Optional&lt;U&gt; value(double value) {
&nbsp;                            return this.defaultValue(value);
&nbsp;                        }
&nbsp;
&nbsp;                        public Optional&lt;U&gt; value(String value) {
&nbsp;                            if (value == null) {
&nbsp;                                throw new IllegalArgumentException(&quot;Cannot define &#39;null&#39; as constant value&quot;);
&nbsp;                            } else {
&nbsp;                                return this.defaultValue(value);
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        protected abstract Optional&lt;U&gt; defaultValue(Object var1);
&nbsp;
&nbsp;                        @Enhance
&nbsp;                        private abstract static class Adapter&lt;V&gt; extends AbstractBase&lt;V&gt; {
&nbsp;                            protected final FieldAttributeAppender.Factory fieldAttributeAppenderFactory;
&nbsp;                            protected final Transformer&lt;FieldDescription&gt; transformer;
&nbsp;                            @Nonnull(
&nbsp;                                when = When.MAYBE
&nbsp;                            )
&nbsp;                            @ValueHandling(net.bytebuddy.build.HashCodeAndEqualsPlugin.ValueHandling.Sort.REVERSE_NULLABILITY)
&nbsp;                            protected final Object defaultValue;
&nbsp;
&nbsp;                            protected Adapter(FieldAttributeAppender.Factory fieldAttributeAppenderFactory, Transformer&lt;FieldDescription&gt; transformer, @Nonnull(when = When.MAYBE) Object defaultValue) {
&nbsp;                                this.fieldAttributeAppenderFactory = fieldAttributeAppenderFactory;
&nbsp;                                this.transformer = transformer;
&nbsp;                                this.defaultValue = defaultValue;
&nbsp;                            }
&nbsp;
&nbsp;                            public Optional&lt;V&gt; attribute(FieldAttributeAppender.Factory fieldAttributeAppenderFactory) {
&nbsp;                                return this.materialize(new FieldAttributeAppender.Factory.Compound(new FieldAttributeAppender.Factory[]{this.fieldAttributeAppenderFactory, fieldAttributeAppenderFactory}), this.transformer, this.defaultValue);
&nbsp;                            }
&nbsp;
&nbsp;                            public Optional&lt;V&gt; transform(Transformer&lt;FieldDescription&gt; transformer) {
&nbsp;                                return this.materialize(this.fieldAttributeAppenderFactory, new Transformer.Compound(new Transformer[]{this.transformer, transformer}), this.defaultValue);
&nbsp;                            }
&nbsp;
&nbsp;                            protected Optional&lt;V&gt; defaultValue(Object defaultValue) {
&nbsp;                                return this.materialize(this.fieldAttributeAppenderFactory, this.transformer, defaultValue);
&nbsp;                            }
&nbsp;
&nbsp;                            protected abstract Optional&lt;V&gt; materialize(FieldAttributeAppender.Factory var1, Transformer&lt;FieldDescription&gt; var2, @Nonnull(when = When.MAYBE) Object var3);
&nbsp;
&nbsp;                            public boolean equals(Object var1) {
&nbsp;                                if (this == var1) {
&nbsp;                                    return true;
&nbsp;                                } else if (var1 == null) {
&nbsp;                                    return false;
&nbsp;                                } else if (this.getClass() != var1.getClass()) {
&nbsp;                                    return false;
&nbsp;                                } else if (!this.fieldAttributeAppenderFactory.equals(((Adapter)var1).fieldAttributeAppenderFactory)) {
&nbsp;                                    return false;
&nbsp;                                } else if (!this.transformer.equals(((Adapter)var1).transformer)) {
&nbsp;                                    return false;
&nbsp;                                } else {
&nbsp;                                    Object var2 = ((Adapter)var1).defaultValue;
&nbsp;                                    Object var3 = this.defaultValue;
&nbsp;                                    if (var2 != null) {
&nbsp;                                        if (var3 == null) {
&nbsp;                                            return false;
&nbsp;                                        }
&nbsp;
&nbsp;                                        if (!var3.equals(var2)) {
&nbsp;                                            return false;
&nbsp;                                        }
&nbsp;                                    } else if (var3 != null) {
&nbsp;                                        return false;
&nbsp;                                    }
&nbsp;
&nbsp;                                    return true;
&nbsp;                                }
&nbsp;                            }
&nbsp;
&nbsp;                            public int hashCode() {
&nbsp;                                int var10000 = ((this.getClass().hashCode() * 31 + this.fieldAttributeAppenderFactory.hashCode()) * 31 + this.transformer.hashCode()) * 31;
&nbsp;                                Object var1 = this.defaultValue;
&nbsp;                                if (var1 != null) {
&nbsp;                                    var10000 += var1.hashCode();
&nbsp;                                }
&nbsp;
&nbsp;                                return var10000;
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public interface Valuable&lt;U&gt; extends FieldDefinition&lt;U&gt; {
&nbsp;                Optional&lt;U&gt; value(boolean var1);
&nbsp;
&nbsp;                Optional&lt;U&gt; value(int var1);
&nbsp;
&nbsp;                Optional&lt;U&gt; value(long var1);
&nbsp;
&nbsp;                Optional&lt;U&gt; value(float var1);
&nbsp;
&nbsp;                Optional&lt;U&gt; value(double var1);
&nbsp;
&nbsp;                Optional&lt;U&gt; value(String var1);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public interface TypeVariableDefinition&lt;S&gt; extends Builder&lt;S&gt; {
&nbsp;            TypeVariableDefinition&lt;S&gt; annotateTypeVariable(Annotation... var1);
&nbsp;
&nbsp;            TypeVariableDefinition&lt;S&gt; annotateTypeVariable(List&lt;? extends Annotation&gt; var1);
&nbsp;
&nbsp;            TypeVariableDefinition&lt;S&gt; annotateTypeVariable(AnnotationDescription... var1);
&nbsp;
&nbsp;            TypeVariableDefinition&lt;S&gt; annotateTypeVariable(Collection&lt;? extends AnnotationDescription&gt; var1);
&nbsp;
&nbsp;            public abstract static class AbstractBase&lt;U&gt; extends AbstractBase.Delegator&lt;U&gt; implements TypeVariableDefinition&lt;U&gt; {
&nbsp;                public AbstractBase() {
&nbsp;                }
&nbsp;
&nbsp;                public TypeVariableDefinition&lt;U&gt; annotateTypeVariable(Annotation... annotation) {
&nbsp;                    return this.annotateTypeVariable(Arrays.asList(annotation));
&nbsp;                }
&nbsp;
&nbsp;                public TypeVariableDefinition&lt;U&gt; annotateTypeVariable(List&lt;? extends Annotation&gt; annotations) {
&nbsp;                    return this.annotateTypeVariable((Collection)(new AnnotationList.ForLoadedAnnotations(annotations)));
&nbsp;                }
&nbsp;
&nbsp;                public TypeVariableDefinition&lt;U&gt; annotateTypeVariable(AnnotationDescription... annotation) {
&nbsp;                    return this.annotateTypeVariable((Collection)Arrays.asList(annotation));
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public interface InnerTypeDefinition&lt;S&gt; extends Builder&lt;S&gt; {
&nbsp;            Builder&lt;S&gt; asAnonymousType();
&nbsp;
&nbsp;            public interface ForType&lt;U&gt; extends InnerTypeDefinition&lt;U&gt; {
&nbsp;                Builder&lt;U&gt; asMemberType();
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-22 12:48</div>
</div>
</body>
</html>
