


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=GBK"> 
  <title>Coverage Report > TypePool</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.pool</a>
</div>

<h1>Coverage Summary for Class: TypePool (net.bytebuddy.pool)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
  <tr>
    <td class="name">TypePool$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$AbstractBase$Hierarchical</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$CacheProvider$Simple</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$ClassLoading</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Empty</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (21/21)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;//
&nbsp;// Source code recreated from a .class file by IntelliJ IDEA
&nbsp;// (powered by FernFlower decompiler)
&nbsp;//
&nbsp;
&nbsp;package net.bytebuddy.pool;
&nbsp;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import java.io.IOException;
&nbsp;import java.lang.annotation.Annotation;
&nbsp;import java.lang.ref.SoftReference;
&nbsp;import java.lang.reflect.GenericSignatureFormatError;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Collections;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.Iterator;
&nbsp;import java.util.List;
&nbsp;import java.util.ListIterator;
&nbsp;import java.util.Map;
&nbsp;import java.util.concurrent.ConcurrentHashMap;
&nbsp;import java.util.concurrent.ConcurrentMap;
&nbsp;import java.util.concurrent.atomic.AtomicReference;
&nbsp;import javax.annotation.CheckForNull;
&nbsp;import javax.annotation.Nonnull;
&nbsp;import javax.annotation.meta.When;
&nbsp;import net.bytebuddy.ClassFileVersion;
&nbsp;import net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance;
&nbsp;import net.bytebuddy.build.HashCodeAndEqualsPlugin.ValueHandling;
&nbsp;import net.bytebuddy.build.HashCodeAndEqualsPlugin.ValueHandling.Sort;
&nbsp;import net.bytebuddy.description.TypeVariableSource;
&nbsp;import net.bytebuddy.description.annotation.AnnotationDescription;
&nbsp;import net.bytebuddy.description.annotation.AnnotationList;
&nbsp;import net.bytebuddy.description.annotation.AnnotationValue;
&nbsp;import net.bytebuddy.description.annotation.AnnotationDescription.AnnotationInvocationHandler;
&nbsp;import net.bytebuddy.description.annotation.AnnotationValue.ForConstant;
&nbsp;import net.bytebuddy.description.annotation.AnnotationValue.RenderingDispatcher;
&nbsp;import net.bytebuddy.description.annotation.AnnotationValue.State;
&nbsp;import net.bytebuddy.description.enumeration.EnumerationDescription;
&nbsp;import net.bytebuddy.description.field.FieldDescription;
&nbsp;import net.bytebuddy.description.field.FieldList;
&nbsp;import net.bytebuddy.description.method.MethodDescription;
&nbsp;import net.bytebuddy.description.method.MethodList;
&nbsp;import net.bytebuddy.description.method.ParameterDescription;
&nbsp;import net.bytebuddy.description.method.ParameterList;
&nbsp;import net.bytebuddy.description.type.PackageDescription;
&nbsp;import net.bytebuddy.description.type.RecordComponentDescription;
&nbsp;import net.bytebuddy.description.type.RecordComponentList;
&nbsp;import net.bytebuddy.description.type.TypeDefinition;
&nbsp;import net.bytebuddy.description.type.TypeDescription;
&nbsp;import net.bytebuddy.description.type.TypeList;
&nbsp;import net.bytebuddy.description.type.TypeDescription.ArrayProjection;
&nbsp;import net.bytebuddy.description.type.TypeDescription.ForLoadedType;
&nbsp;import net.bytebuddy.description.type.TypeDescription.Generic;
&nbsp;import net.bytebuddy.dynamic.ClassFileLocator;
&nbsp;import net.bytebuddy.dynamic.ClassFileLocator.ForClassLoader;
&nbsp;import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;
&nbsp;import net.bytebuddy.implementation.bytecode.StackSize;
&nbsp;import net.bytebuddy.jar.asm.AnnotationVisitor;
&nbsp;import net.bytebuddy.jar.asm.ClassReader;
&nbsp;import net.bytebuddy.jar.asm.ClassVisitor;
&nbsp;import net.bytebuddy.jar.asm.FieldVisitor;
&nbsp;import net.bytebuddy.jar.asm.Label;
&nbsp;import net.bytebuddy.jar.asm.MethodVisitor;
&nbsp;import net.bytebuddy.jar.asm.RecordComponentVisitor;
&nbsp;import net.bytebuddy.jar.asm.Type;
&nbsp;import net.bytebuddy.jar.asm.TypePath;
&nbsp;import net.bytebuddy.jar.asm.TypeReference;
&nbsp;import net.bytebuddy.jar.asm.signature.SignatureReader;
&nbsp;import net.bytebuddy.jar.asm.signature.SignatureVisitor;
&nbsp;import net.bytebuddy.matcher.ElementMatcher;
&nbsp;import net.bytebuddy.matcher.ElementMatchers;
&nbsp;import net.bytebuddy.utility.JavaType;
&nbsp;import net.bytebuddy.utility.OpenedClassReader;
&nbsp;
&nbsp;public interface TypePool {
&nbsp;    Resolution describe(String var1);
&nbsp;
&nbsp;    void clear();
&nbsp;
&nbsp;    @Enhance
&nbsp;    public static class Explicit extends AbstractBase.Hierarchical {
&nbsp;        private final Map&lt;String, TypeDescription&gt; types;
&nbsp;
&nbsp;        public Explicit(Map&lt;String, TypeDescription&gt; types) {
&nbsp;            this(TypePool.Empty.INSTANCE, types);
&nbsp;        }
&nbsp;
&nbsp;        public Explicit(TypePool parent, Map&lt;String, TypeDescription&gt; types) {
&nbsp;            super(TypePool.CacheProvider.NoOp.INSTANCE, parent);
&nbsp;            this.types = types;
&nbsp;        }
&nbsp;
&nbsp;        protected Resolution doDescribe(String name) {
&nbsp;            TypeDescription typeDescription = (TypeDescription)this.types.get(name);
&nbsp;            return (Resolution)(typeDescription == null ? new Resolution.Illegal(name) : new Resolution.Simple(typeDescription));
&nbsp;        }
&nbsp;
&nbsp;        public boolean equals(Object var1) {
&nbsp;            if (!super.equals(var1)) {
&nbsp;                return false;
&nbsp;            } else if (this == var1) {
&nbsp;                return true;
&nbsp;            } else if (var1 == null) {
&nbsp;                return false;
&nbsp;            } else if (this.getClass() != var1.getClass()) {
&nbsp;                return false;
&nbsp;            } else {
&nbsp;                return this.types.equals(((Explicit)var1).types);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public int hashCode() {
&nbsp;            return super.hashCode() * 31 + this.types.hashCode();
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Enhance
&nbsp;    public static class ClassLoading extends AbstractBase.Hierarchical {
&nbsp;        @Nonnull(
&nbsp;            when = When.MAYBE
&nbsp;        )
&nbsp;        @ValueHandling(Sort.REVERSE_NULLABILITY)
&nbsp;        private final ClassLoader classLoader;
&nbsp;
&nbsp;        public ClassLoading(CacheProvider cacheProvider, TypePool parent, @Nonnull(when = When.MAYBE) ClassLoader classLoader) {
&nbsp;            super(cacheProvider, parent);
&nbsp;            this.classLoader = classLoader;
&nbsp;        }
&nbsp;
&nbsp;        public static TypePool of(@Nonnull(when = When.MAYBE) ClassLoader classLoader) {
&nbsp;            return of(classLoader, TypePool.Empty.INSTANCE);
&nbsp;        }
&nbsp;
&nbsp;        public static TypePool of(@Nonnull(when = When.MAYBE) ClassLoader classLoader, TypePool parent) {
&nbsp;            return new ClassLoading(new CacheProvider.Simple(), parent, classLoader);
&nbsp;        }
&nbsp;
&nbsp;        public static TypePool ofSystemLoader() {
&nbsp;            return of(ClassLoader.getSystemClassLoader());
&nbsp;        }
&nbsp;
&nbsp;        public static TypePool ofPlatformLoader() {
&nbsp;            return of(ClassLoader.getSystemClassLoader().getParent());
&nbsp;        }
&nbsp;
&nbsp;        public static TypePool ofBootLoader() {
&nbsp;            return of(ClassLoadingStrategy.BOOTSTRAP_LOADER);
&nbsp;        }
&nbsp;
&nbsp;        protected Resolution doDescribe(String name) {
&nbsp;            try {
&nbsp;                return new Resolution.Simple(ForLoadedType.of(Class.forName(name, false, this.classLoader)));
&nbsp;            } catch (ClassNotFoundException var3) {
&nbsp;                return new Resolution.Illegal(name);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public boolean equals(Object var1) {
&nbsp;            if (!super.equals(var1)) {
&nbsp;                return false;
&nbsp;            } else if (this == var1) {
&nbsp;                return true;
&nbsp;            } else if (var1 == null) {
&nbsp;                return false;
&nbsp;            } else if (this.getClass() != var1.getClass()) {
&nbsp;                return false;
&nbsp;            } else {
&nbsp;                ClassLoader var2 = ((ClassLoading)var1).classLoader;
&nbsp;                ClassLoader var3 = this.classLoader;
&nbsp;                if (var2 != null) {
&nbsp;                    if (var3 != null) {
&nbsp;                        if (!var3.equals(var2)) {
&nbsp;                            return false;
&nbsp;                        }
&nbsp;
&nbsp;                        return true;
&nbsp;                    }
&nbsp;                } else if (var3 == null) {
&nbsp;                    return true;
&nbsp;                }
&nbsp;
&nbsp;                return false;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public int hashCode() {
&nbsp;            int var10000 = super.hashCode() * 31;
&nbsp;            ClassLoader var1 = this.classLoader;
&nbsp;            if (var1 != null) {
&nbsp;                var10000 += var1.hashCode();
&nbsp;            }
&nbsp;
&nbsp;            return var10000;
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Enhance
&nbsp;    public static class LazyFacade extends AbstractBase {
&nbsp;        private final TypePool typePool;
&nbsp;
&nbsp;        public LazyFacade(TypePool typePool) {
&nbsp;            super(TypePool.CacheProvider.NoOp.INSTANCE);
&nbsp;            this.typePool = typePool;
&nbsp;        }
&nbsp;
&nbsp;        protected Resolution doDescribe(String name) {
&nbsp;            return new LazyResolution(this.typePool, name);
&nbsp;        }
&nbsp;
&nbsp;        public void clear() {
&nbsp;            this.typePool.clear();
&nbsp;        }
&nbsp;
&nbsp;        public boolean equals(Object var1) {
&nbsp;            if (!super.equals(var1)) {
&nbsp;                return false;
&nbsp;            } else if (this == var1) {
&nbsp;                return true;
&nbsp;            } else if (var1 == null) {
&nbsp;                return false;
&nbsp;            } else if (this.getClass() != var1.getClass()) {
&nbsp;                return false;
&nbsp;            } else {
&nbsp;                return this.typePool.equals(((LazyFacade)var1).typePool);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public int hashCode() {
&nbsp;            return super.hashCode() * 31 + this.typePool.hashCode();
&nbsp;        }
&nbsp;
&nbsp;        protected static class LazyTypeDescription extends TypeDescription.AbstractBase.OfSimpleType.WithDelegation {
&nbsp;            private final TypePool typePool;
&nbsp;            private final String name;
&nbsp;
&nbsp;            protected LazyTypeDescription(TypePool typePool, String name) {
&nbsp;                this.typePool = typePool;
&nbsp;                this.name = name;
&nbsp;            }
&nbsp;
&nbsp;            public String getName() {
&nbsp;                return this.name;
&nbsp;            }
&nbsp;
&nbsp;            @net.bytebuddy.build.CachedReturnPlugin.Enhance(&quot;delegate&quot;)
&nbsp;            protected TypeDescription delegate() {
&nbsp;                TypeDescription var1 = this.delegate;
&nbsp;                TypeDescription var2 = var1 != null ? null : this.typePool.describe(this.name).resolve();
&nbsp;                if (var2 == null) {
&nbsp;                    var2 = (TypeDescription)this.delegate;
&nbsp;                } else {
&nbsp;                    this.delegate = var2;
&nbsp;                }
&nbsp;
&nbsp;                return var2;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Enhance
&nbsp;        protected static class LazyResolution implements Resolution {
&nbsp;            private final TypePool typePool;
&nbsp;            private final String name;
&nbsp;
&nbsp;            protected LazyResolution(TypePool typePool, String name) {
&nbsp;                this.typePool = typePool;
&nbsp;                this.name = name;
&nbsp;            }
&nbsp;
&nbsp;            public boolean isResolved() {
&nbsp;                return this.typePool.describe(this.name).isResolved();
&nbsp;            }
&nbsp;
&nbsp;            public TypeDescription resolve() {
&nbsp;                return new LazyTypeDescription(this.typePool, this.name);
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(Object var1) {
&nbsp;                if (this == var1) {
&nbsp;                    return true;
&nbsp;                } else if (var1 == null) {
&nbsp;                    return false;
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
&nbsp;                } else if (!this.name.equals(((LazyResolution)var1).name)) {
&nbsp;                    return false;
&nbsp;                } else {
<b class="fc">&nbsp;                    return this.typePool.equals(((LazyResolution)var1).typePool);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public int hashCode() {
&nbsp;                return (this.getClass().hashCode() * 31 + this.typePool.hashCode()) * 31 + this.name.hashCode();
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;    }</b>
<b class="fc">&nbsp;</b>
&nbsp;    @Enhance
&nbsp;    public static class Default extends AbstractBase.Hierarchical {
&nbsp;        @Nonnull(
&nbsp;            when = When.NEVER
&nbsp;        )
&nbsp;        private static final MethodVisitor IGNORE_METHOD = null;
&nbsp;        protected final ClassFileLocator classFileLocator;
&nbsp;        protected final ReaderMode readerMode;
&nbsp;
&nbsp;        public Default(CacheProvider cacheProvider, ClassFileLocator classFileLocator, ReaderMode readerMode) {
&nbsp;            this(cacheProvider, classFileLocator, readerMode, TypePool.Empty.INSTANCE);
&nbsp;        }
&nbsp;
&nbsp;        public Default(CacheProvider cacheProvider, ClassFileLocator classFileLocator, ReaderMode readerMode, TypePool parentPool) {
&nbsp;            super(cacheProvider, parentPool);
&nbsp;            this.classFileLocator = classFileLocator;
&nbsp;            this.readerMode = readerMode;
&nbsp;        }
&nbsp;
&nbsp;        public static TypePool ofSystemLoader() {
&nbsp;            return of(ForClassLoader.ofSystemLoader());
&nbsp;        }
&nbsp;
&nbsp;        public static TypePool ofPlatformLoader() {
&nbsp;            return of(ForClassLoader.ofPlatformLoader());
&nbsp;        }
&nbsp;
&nbsp;        public static TypePool ofBootLoader() {
&nbsp;            return of(ForClassLoader.ofBootLoader());
&nbsp;        }
&nbsp;
&nbsp;        public static TypePool of(@Nonnull(when = When.MAYBE) ClassLoader classLoader) {
&nbsp;            return of(ForClassLoader.of(classLoader));
&nbsp;        }
&nbsp;
&nbsp;        public static TypePool of(ClassFileLocator classFileLocator) {
&nbsp;            return new Default(new CacheProvider.Simple(), classFileLocator, TypePool.Default.ReaderMode.FAST);
&nbsp;        }
&nbsp;
&nbsp;        protected Resolution doDescribe(String name) {
&nbsp;            try {
&nbsp;                ClassFileLocator.Resolution resolution = this.classFileLocator.locate(name);
&nbsp;                return (Resolution)(resolution.isResolved() ? new Resolution.Simple(this.parse(resolution.resolve())) : new Resolution.Illegal(name));
&nbsp;            } catch (IOException var3) {
&nbsp;                throw new IllegalStateException(&quot;Error while reading class file&quot;, var3);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        private TypeDescription parse(byte[] binaryRepresentation) {
&nbsp;            ClassReader classReader = OpenedClassReader.of(binaryRepresentation);
&nbsp;            TypeExtractor typeExtractor = new TypeExtractor();
&nbsp;            classReader.accept(typeExtractor, this.readerMode.getFlags());
&nbsp;            return typeExtractor.toTypeDescription();
&nbsp;        }
&nbsp;
&nbsp;        public boolean equals(Object var1) {
&nbsp;            if (!super.equals(var1)) {
&nbsp;                return false;
&nbsp;            } else if (this == var1) {
&nbsp;                return true;
&nbsp;            } else if (var1 == null) {
&nbsp;                return false;
&nbsp;            } else if (this.getClass() != var1.getClass()) {
&nbsp;                return false;
&nbsp;            } else if (!this.readerMode.equals(((Default)var1).readerMode)) {
&nbsp;                return false;
&nbsp;            } else {
&nbsp;                return this.classFileLocator.equals(((Default)var1).classFileLocator);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public int hashCode() {
&nbsp;            return (super.hashCode() * 31 + this.classFileLocator.hashCode()) * 31 + this.readerMode.hashCode();
&nbsp;        }
&nbsp;
&nbsp;        protected class TypeExtractor extends ClassVisitor {
&nbsp;            private static final int SUPER_CLASS_INDEX = -1;
&nbsp;            private static final int REAL_MODIFIER_MASK = 65535;
&nbsp;            private final Map&lt;Integer, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;&gt; superTypeAnnotationTokens = new HashMap();
&nbsp;            private final Map&lt;Integer, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;&gt; typeVariableAnnotationTokens = new HashMap();
&nbsp;            private final Map&lt;Integer, Map&lt;Integer, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;&gt;&gt; typeVariableBoundsAnnotationTokens = new HashMap();
&nbsp;            private final List&lt;LazyTypeDescription.AnnotationToken&gt; annotationTokens = new ArrayList();
&nbsp;            private final List&lt;LazyTypeDescription.FieldToken&gt; fieldTokens = new ArrayList();
&nbsp;            private final List&lt;LazyTypeDescription.MethodToken&gt; methodTokens = new ArrayList();
&nbsp;            private final List&lt;LazyTypeDescription.RecordComponentToken&gt; recordComponentTokens = new ArrayList();
&nbsp;            private int actualModifiers;
&nbsp;            private int modifiers;
&nbsp;            @Nonnull(
&nbsp;                when = When.MAYBE
&nbsp;            )
&nbsp;            private String internalName;
&nbsp;            @Nonnull(
&nbsp;                when = When.MAYBE
&nbsp;            )
&nbsp;            private String superClassName;
&nbsp;            @Nonnull(
&nbsp;                when = When.MAYBE
&nbsp;            )
&nbsp;            private String genericSignature;
&nbsp;            @Nonnull(
&nbsp;                when = When.MAYBE
&nbsp;            )
&nbsp;            private String[] interfaceName;
&nbsp;            private boolean anonymousType = false;
&nbsp;            @Nonnull(
&nbsp;                when = When.MAYBE
&nbsp;            )
&nbsp;            private String nestHost;
&nbsp;            private final List&lt;String&gt; nestMembers;
&nbsp;            private LazyTypeDescription.TypeContainment typeContainment;
&nbsp;            @Nonnull(
&nbsp;                when = When.MAYBE
&nbsp;            )
&nbsp;            private String declaringTypeName;
&nbsp;            private final List&lt;String&gt; declaredTypes;
&nbsp;            private final List&lt;String&gt; permittedSubclasses;
&nbsp;            @Nonnull(
&nbsp;                when = When.MAYBE
&nbsp;            )
&nbsp;            private ClassFileVersion classFileVersion;
&nbsp;
&nbsp;            protected TypeExtractor() {
&nbsp;                super(OpenedClassReader.ASM_API);
&nbsp;                this.typeContainment = TypePool.Default.LazyTypeDescription.TypeContainment.SelfContained.INSTANCE;
&nbsp;                this.nestMembers = new ArrayList();
&nbsp;                this.declaredTypes = new ArrayList();
&nbsp;                this.permittedSubclasses = new ArrayList();
&nbsp;            }
&nbsp;
&nbsp;            @SuppressFBWarnings(
&nbsp;                value = {&quot;EI_EXPOSE_REP2&quot;},
&nbsp;                justification = &quot;The array is not modified by class contract.&quot;
&nbsp;            )
&nbsp;            public void visit(int classFileVersion, int modifiers, String internalName, @Nonnull(when = When.MAYBE) String genericSignature, @Nonnull(when = When.MAYBE) String superClassName, @Nonnull(when = When.MAYBE) String[] interfaceName) {
&nbsp;                this.modifiers = modifiers &amp; &#39;\uffff&#39;;
&nbsp;                this.actualModifiers = modifiers;
&nbsp;                this.internalName = internalName;
&nbsp;                this.genericSignature = genericSignature;
&nbsp;                this.superClassName = superClassName;
&nbsp;                this.interfaceName = interfaceName;
&nbsp;                this.classFileVersion = ClassFileVersion.ofMinorMajor(classFileVersion);
&nbsp;            }
&nbsp;
&nbsp;            public void visitOuterClass(@Nonnull(when = When.MAYBE) String typeName, @Nonnull(when = When.MAYBE) String methodName, String methodDescriptor) {
&nbsp;                if (methodName != null &amp;&amp; !methodName.equals(&quot;&lt;clinit&gt;&quot;)) {
&nbsp;                    this.typeContainment = new LazyTypeDescription.TypeContainment.WithinMethod(typeName, methodName, methodDescriptor);
&nbsp;                } else if (typeName != null) {
&nbsp;                    this.typeContainment = new LazyTypeDescription.TypeContainment.WithinType(typeName, true);
&nbsp;                }
&nbsp;
&nbsp;            }
&nbsp;
&nbsp;            public void visitInnerClass(String internalName, @Nonnull(when = When.MAYBE) String outerName, @Nonnull(when = When.MAYBE) String innerName, int modifiers) {
&nbsp;                if (internalName.equals(this.internalName)) {
&nbsp;                    if (outerName != null) {
&nbsp;                        this.declaringTypeName = outerName;
&nbsp;                        if (this.typeContainment.isSelfContained()) {
&nbsp;                            this.typeContainment = new LazyTypeDescription.TypeContainment.WithinType(outerName, false);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    if (innerName == null &amp;&amp; !this.typeContainment.isSelfContained()) {
&nbsp;                        this.anonymousType = true;
&nbsp;                    }
&nbsp;
&nbsp;                    this.modifiers = modifiers &amp; &#39;\uffff&#39;;
&nbsp;                } else if (outerName != null &amp;&amp; innerName != null &amp;&amp; outerName.equals(this.internalName)) {
&nbsp;                    this.declaredTypes.add(&quot;L&quot; + internalName + &quot;;&quot;);
&nbsp;                }
&nbsp;
&nbsp;            }
<b class="fc">&nbsp;</b>
&nbsp;            public AnnotationVisitor visitTypeAnnotation(int rawTypeReference, @Nonnull(when = When.MAYBE) TypePath typePath, String descriptor, boolean visible) {
&nbsp;                TypeReference typeReference = new TypeReference(rawTypeReference);
&nbsp;                Object annotationRegistrant;
&nbsp;                switch (typeReference.getSort()) {
<b class="fc">&nbsp;                    case 0:</b>
&nbsp;                        annotationRegistrant = new AnnotationRegistrant.ForTypeVariable.WithIndex(descriptor, typePath, typeReference.getTypeParameterIndex(), this.typeVariableAnnotationTokens);
&nbsp;                        break;
&nbsp;                    case 16:
&nbsp;                        annotationRegistrant = new AnnotationRegistrant.ForTypeVariable.WithIndex(descriptor, typePath, typeReference.getSuperTypeIndex(), this.superTypeAnnotationTokens);
&nbsp;                        break;
&nbsp;                    case 17:
&nbsp;                        annotationRegistrant = new AnnotationRegistrant.ForTypeVariable.WithIndex.DoubleIndexed(descriptor, typePath, typeReference.getTypeParameterBoundIndex(), typeReference.getTypeParameterIndex(), this.typeVariableBoundsAnnotationTokens);
&nbsp;                        break;
&nbsp;                    default:
&nbsp;                        throw new IllegalArgumentException(&quot;Unexpected type reference: &quot; + typeReference.getSort());
&nbsp;                }
&nbsp;
&nbsp;                return new AnnotationExtractor((AnnotationRegistrant)annotationRegistrant, new ComponentTypeLocator.ForAnnotationProperty(Default.this, descriptor));
&nbsp;            }
&nbsp;
&nbsp;            public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {
&nbsp;                return new AnnotationExtractor(descriptor, this.annotationTokens, new ComponentTypeLocator.ForAnnotationProperty(Default.this, descriptor));
&nbsp;            }
&nbsp;
&nbsp;            public FieldVisitor visitField(int modifiers, String internalName, String descriptor, @Nonnull(when = When.MAYBE) String genericSignature, @Nonnull(when = When.MAYBE) Object value) {
&nbsp;                return new FieldExtractor(modifiers &amp; &#39;\uffff&#39;, internalName, descriptor, genericSignature);
&nbsp;            }
&nbsp;
&nbsp;            @Nonnull(
&nbsp;                when = When.MAYBE
&nbsp;            )
&nbsp;            public MethodVisitor visitMethod(int modifiers, String internalName, String descriptor, @Nonnull(when = When.MAYBE) String genericSignature, @Nonnull(when = When.MAYBE) String[] exceptionName) {
&nbsp;                return (MethodVisitor)(internalName.equals(&quot;&lt;clinit&gt;&quot;) ? TypePool.Default.IGNORE_METHOD : new MethodExtractor(modifiers &amp; &#39;\uffff&#39;, internalName, descriptor, genericSignature, exceptionName));
&nbsp;            }
&nbsp;
&nbsp;            public void visitNestHost(String nestHost) {
&nbsp;                this.nestHost = nestHost;
&nbsp;            }
&nbsp;
&nbsp;            public void visitNestMember(String nestMember) {
&nbsp;                this.nestMembers.add(nestMember);
&nbsp;            }
&nbsp;
&nbsp;            public RecordComponentVisitor visitRecordComponent(String name, String descriptor, @Nonnull(when = When.MAYBE) String signature) {
&nbsp;                return new RecordComponentExtractor(name, descriptor, signature);
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            public void visitPermittedSubclass(String permittedSubclass) {</b>
<b class="fc">&nbsp;                this.permittedSubclasses.add(permittedSubclass);</b>
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            protected TypeDescription toTypeDescription() {
&nbsp;                if (this.internalName != null &amp;&amp; this.classFileVersion != null) {
&nbsp;                    Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt; superClassAnnotationTokens = (Map)this.superTypeAnnotationTokens.remove(-1);
&nbsp;                    return new LazyTypeDescription(Default.this, this.actualModifiers, this.modifiers, this.internalName, this.superClassName, this.interfaceName, this.genericSignature, this.typeContainment, this.declaringTypeName, this.declaredTypes, this.anonymousType, this.nestHost, this.nestMembers, superClassAnnotationTokens == null ? Collections.emptyMap() : superClassAnnotationTokens, this.superTypeAnnotationTokens, this.typeVariableAnnotationTokens, this.typeVariableBoundsAnnotationTokens, this.annotationTokens, this.fieldTokens, this.methodTokens, this.recordComponentTokens, this.permittedSubclasses, this.classFileVersion);
&nbsp;                } else {
&nbsp;                    throw new IllegalStateException(&quot;Internal name or class file version were not set&quot;);
&nbsp;                }
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;</b>
&nbsp;            protected class RecordComponentExtractor extends RecordComponentVisitor {
<b class="fc">&nbsp;                private final String name;</b>
<b class="fc">&nbsp;                private final String descriptor;</b>
&nbsp;                @Nonnull(
&nbsp;                    when = When.MAYBE
&nbsp;                )
&nbsp;                private final String genericSignature;
&nbsp;                private final Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt; typeAnnotationTokens;
&nbsp;                private final List&lt;LazyTypeDescription.AnnotationToken&gt; annotationTokens;
&nbsp;
&nbsp;                protected RecordComponentExtractor(String name, String descriptor, @Nonnull(when = When.MAYBE) String genericSignature) {
&nbsp;                    super(OpenedClassReader.ASM_API);
&nbsp;                    this.name = name;
&nbsp;                    this.descriptor = descriptor;
&nbsp;                    this.genericSignature = genericSignature;
<b class="fc">&nbsp;                    this.typeAnnotationTokens = new HashMap();</b>
<b class="fc">&nbsp;                    this.annotationTokens = new ArrayList();</b>
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationVisitor visitTypeAnnotation(int rawTypeReference, TypePath typePath, String descriptor, boolean visible) {
&nbsp;                    TypeReference typeReference = new TypeReference(rawTypeReference);
&nbsp;                    switch (typeReference.getSort()) {
&nbsp;                        case 19:
&nbsp;                            AnnotationRegistrant annotationRegistrant = new AnnotationRegistrant.ForTypeVariable(descriptor, typePath, this.typeAnnotationTokens);
&nbsp;                            return TypeExtractor.this.new AnnotationExtractor(annotationRegistrant, new ComponentTypeLocator.ForAnnotationProperty(Default.this, descriptor));
&nbsp;                        default:
&nbsp;                            throw new IllegalStateException(&quot;Unexpected type reference on record component: &quot; + typeReference.getSort());
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {
&nbsp;                    return TypeExtractor.this.new AnnotationExtractor(descriptor, this.annotationTokens, new ComponentTypeLocator.ForAnnotationProperty(Default.this, descriptor));
&nbsp;                }
&nbsp;
&nbsp;                public void visitEnd() {
&nbsp;                    TypeExtractor.this.recordComponentTokens.add(new LazyTypeDescription.RecordComponentToken(this.name, this.descriptor, this.genericSignature, this.typeAnnotationTokens, this.annotationTokens));
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            protected class MethodExtractor extends MethodVisitor implements AnnotationRegistrant {
&nbsp;                private final int modifiers;
&nbsp;                private final String internalName;
&nbsp;                private final String descriptor;
&nbsp;                @Nonnull(
&nbsp;                    when = When.MAYBE
&nbsp;                )
&nbsp;                private final String genericSignature;
&nbsp;                @Nonnull(
&nbsp;                    when = When.MAYBE
&nbsp;                )
&nbsp;                private final String[] exceptionName;
&nbsp;                private final Map&lt;Integer, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;&gt; typeVariableAnnotationTokens;
&nbsp;                private final Map&lt;Integer, Map&lt;Integer, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;&gt;&gt; typeVariableBoundAnnotationTokens;
&nbsp;                private final Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt; returnTypeAnnotationTokens;
&nbsp;                private final Map&lt;Integer, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;&gt; parameterTypeAnnotationTokens;
&nbsp;                private final Map&lt;Integer, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;&gt; exceptionTypeAnnotationTokens;
&nbsp;                private final Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt; receiverTypeAnnotationTokens;
&nbsp;                private final List&lt;LazyTypeDescription.AnnotationToken&gt; annotationTokens;
&nbsp;                private final Map&lt;Integer, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt; parameterAnnotationTokens;
&nbsp;                private final List&lt;LazyTypeDescription.MethodToken.ParameterToken&gt; parameterTokens;
&nbsp;                private final ParameterBag legacyParameterBag;
&nbsp;                @Nonnull(
&nbsp;                    when = When.MAYBE
&nbsp;                )
&nbsp;                private Label firstLabel;
&nbsp;                private int visibleParameterShift;
&nbsp;                private int invisibleParameterShift;
&nbsp;                @Nonnull(
&nbsp;                    when = When.MAYBE
&nbsp;                )
&nbsp;                private AnnotationValue&lt;?, ?&gt; defaultValue;
&nbsp;
&nbsp;                protected MethodExtractor(int modifiers, String internalName, String descriptor, @Nonnull(when = When.MAYBE) String genericSignature, @Nonnull(when = When.MAYBE) String[] exceptionName) {
&nbsp;                    super(OpenedClassReader.ASM_API);
&nbsp;                    this.modifiers = modifiers;
&nbsp;                    this.internalName = internalName;
&nbsp;                    this.descriptor = descriptor;
&nbsp;                    this.genericSignature = genericSignature;
&nbsp;                    this.exceptionName = exceptionName;
&nbsp;                    this.typeVariableAnnotationTokens = new HashMap();
&nbsp;                    this.typeVariableBoundAnnotationTokens = new HashMap();
&nbsp;                    this.returnTypeAnnotationTokens = new HashMap();
&nbsp;                    this.parameterTypeAnnotationTokens = new HashMap();
&nbsp;                    this.exceptionTypeAnnotationTokens = new HashMap();
&nbsp;                    this.receiverTypeAnnotationTokens = new HashMap();
&nbsp;                    this.annotationTokens = new ArrayList();
&nbsp;                    this.parameterAnnotationTokens = new HashMap();
&nbsp;                    this.parameterTokens = new ArrayList();
&nbsp;                    this.legacyParameterBag = new ParameterBag(Type.getMethodType(descriptor).getArgumentTypes());
&nbsp;                }
&nbsp;
&nbsp;                @Nonnull(
&nbsp;                    when = When.MAYBE
&nbsp;                )
&nbsp;                public AnnotationVisitor visitTypeAnnotation(int rawTypeReference, TypePath typePath, String descriptor, boolean visible) {
&nbsp;                    TypeReference typeReference = new TypeReference(rawTypeReference);
&nbsp;                    Object annotationRegistrant;
&nbsp;                    switch (typeReference.getSort()) {
&nbsp;                        case 1:
&nbsp;                            annotationRegistrant = new AnnotationRegistrant.ForTypeVariable.WithIndex(descriptor, typePath, typeReference.getTypeParameterIndex(), this.typeVariableAnnotationTokens);
&nbsp;                            break;
&nbsp;                        case 2:
&nbsp;                        case 3:
&nbsp;                        case 4:
&nbsp;                        case 5:
&nbsp;                        case 6:
&nbsp;                        case 7:
&nbsp;                        case 8:
&nbsp;                        case 9:
&nbsp;                        case 10:
&nbsp;                        case 11:
&nbsp;                        case 12:
&nbsp;                        case 13:
&nbsp;                        case 14:
<b class="fc">&nbsp;                        case 15:</b>
<b class="fc">&nbsp;                        case 16:</b>
&nbsp;                        case 17:
&nbsp;                        default:
&nbsp;                            throw new IllegalStateException(&quot;Unexpected type reference on method: &quot; + typeReference.getSort());
&nbsp;                        case 18:
&nbsp;                            annotationRegistrant = new AnnotationRegistrant.ForTypeVariable.WithIndex.DoubleIndexed(descriptor, typePath, typeReference.getTypeParameterBoundIndex(), typeReference.getTypeParameterIndex(), this.typeVariableBoundAnnotationTokens);
&nbsp;                            break;
&nbsp;                        case 19:
&nbsp;                            return null;
&nbsp;                        case 20:
&nbsp;                            annotationRegistrant = new AnnotationRegistrant.ForTypeVariable(descriptor, typePath, this.returnTypeAnnotationTokens);
&nbsp;                            break;
&nbsp;                        case 21:
&nbsp;                            annotationRegistrant = new AnnotationRegistrant.ForTypeVariable(descriptor, typePath, this.receiverTypeAnnotationTokens);
&nbsp;                            break;
&nbsp;                        case 22:
&nbsp;                            annotationRegistrant = new AnnotationRegistrant.ForTypeVariable.WithIndex(descriptor, typePath, typeReference.getFormalParameterIndex(), this.parameterTypeAnnotationTokens);
&nbsp;                            break;
&nbsp;                        case 23:
&nbsp;                            annotationRegistrant = new AnnotationRegistrant.ForTypeVariable.WithIndex(descriptor, typePath, typeReference.getExceptionIndex(), this.exceptionTypeAnnotationTokens);
&nbsp;                    }
&nbsp;
&nbsp;                    return TypeExtractor.this.new AnnotationExtractor((AnnotationRegistrant)annotationRegistrant, new ComponentTypeLocator.ForAnnotationProperty(Default.this, descriptor));
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {
&nbsp;                    return TypeExtractor.this.new AnnotationExtractor(descriptor, this.annotationTokens, new ComponentTypeLocator.ForAnnotationProperty(Default.this, descriptor));
&nbsp;                }
&nbsp;
&nbsp;                public void visitAnnotableParameterCount(int count, boolean visible) {
&nbsp;                    if (visible) {
&nbsp;                        this.visibleParameterShift = Type.getMethodType(this.descriptor).getArgumentTypes().length - count;
&nbsp;                    } else {
&nbsp;                        this.invisibleParameterShift = Type.getMethodType(this.descriptor).getArgumentTypes().length - count;
&nbsp;                    }
&nbsp;
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationVisitor visitParameterAnnotation(int index, String descriptor, boolean visible) {
&nbsp;                    return TypeExtractor.this.new AnnotationExtractor(descriptor, index + (visible ? this.visibleParameterShift : this.invisibleParameterShift), this.parameterAnnotationTokens, new ComponentTypeLocator.ForAnnotationProperty(Default.this, descriptor));
&nbsp;                }
&nbsp;
&nbsp;                public void visitLabel(Label label) {
&nbsp;                    if (Default.this.readerMode.isExtended() &amp;&amp; this.firstLabel == null) {
&nbsp;                        this.firstLabel = label;
&nbsp;                    }
&nbsp;
&nbsp;                }
&nbsp;
&nbsp;                public void visitLocalVariable(String name, String descriptor, String signature, Label start, Label end, int index) {
&nbsp;                    if (Default.this.readerMode.isExtended() &amp;&amp; start == this.firstLabel) {
&nbsp;                        this.legacyParameterBag.register(index, name);
&nbsp;                    }
&nbsp;
&nbsp;                }
&nbsp;
&nbsp;                public void visitParameter(String name, int modifiers) {
&nbsp;                    this.parameterTokens.add(new LazyTypeDescription.MethodToken.ParameterToken(name, modifiers));
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationVisitor visitAnnotationDefault() {
&nbsp;                    return TypeExtractor.this.new AnnotationExtractor(this, new ComponentTypeLocator.ForArrayType(this.descriptor));
&nbsp;                }
&nbsp;
&nbsp;                public void register(String ignored, AnnotationValue&lt;?, ?&gt; annotationValue) {
&nbsp;                    this.defaultValue = annotationValue;
&nbsp;                }
&nbsp;
&nbsp;                public void onComplete() {
&nbsp;                }
&nbsp;
&nbsp;                public void visitEnd() {
&nbsp;                    TypeExtractor.this.methodTokens.add(new LazyTypeDescription.MethodToken(this.internalName, this.modifiers, this.descriptor, this.genericSignature, this.exceptionName, this.typeVariableAnnotationTokens, this.typeVariableBoundAnnotationTokens, this.returnTypeAnnotationTokens, this.parameterTypeAnnotationTokens, this.exceptionTypeAnnotationTokens, this.receiverTypeAnnotationTokens, this.annotationTokens, this.parameterAnnotationTokens, this.parameterTokens.isEmpty() ? this.legacyParameterBag.resolve((this.modifiers &amp; 8) != 0) : this.parameterTokens, this.defaultValue));
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            protected class FieldExtractor extends FieldVisitor {
&nbsp;                private final int modifiers;
&nbsp;                private final String internalName;
&nbsp;                private final String descriptor;
&nbsp;                @Nonnull(
&nbsp;                    when = When.MAYBE
&nbsp;                )
&nbsp;                private final String genericSignature;
&nbsp;                private final Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt; typeAnnotationTokens;
&nbsp;                private final List&lt;LazyTypeDescription.AnnotationToken&gt; annotationTokens;
&nbsp;
&nbsp;                protected FieldExtractor(int modifiers, String internalName, String descriptor, @Nonnull(when = When.MAYBE) String genericSignature) {
&nbsp;                    super(OpenedClassReader.ASM_API);
&nbsp;                    this.modifiers = modifiers;
&nbsp;                    this.internalName = internalName;
&nbsp;                    this.descriptor = descriptor;
&nbsp;                    this.genericSignature = genericSignature;
&nbsp;                    this.typeAnnotationTokens = new HashMap();
&nbsp;                    this.annotationTokens = new ArrayList();
&nbsp;                }
&nbsp;
&nbsp;                @Nonnull(
&nbsp;                    when = When.MAYBE
&nbsp;                )
&nbsp;                public AnnotationVisitor visitTypeAnnotation(int rawTypeReference, @Nonnull(when = When.MAYBE) TypePath typePath, String descriptor, boolean visible) {
&nbsp;                    TypeReference typeReference = new TypeReference(rawTypeReference);
&nbsp;                    switch (typeReference.getSort()) {
&nbsp;                        case 19:
&nbsp;                            AnnotationRegistrant annotationRegistrant = new AnnotationRegistrant.ForTypeVariable(descriptor, typePath, this.typeAnnotationTokens);
&nbsp;                            return TypeExtractor.this.new AnnotationExtractor(annotationRegistrant, new ComponentTypeLocator.ForAnnotationProperty(Default.this, descriptor));
&nbsp;                        default:
&nbsp;                            throw new IllegalStateException(&quot;Unexpected type reference on field: &quot; + typeReference.getSort());
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {
&nbsp;                    return TypeExtractor.this.new AnnotationExtractor(descriptor, this.annotationTokens, new ComponentTypeLocator.ForAnnotationProperty(Default.this, descriptor));
&nbsp;                }
&nbsp;
&nbsp;                public void visitEnd() {
&nbsp;                    TypeExtractor.this.fieldTokens.add(new LazyTypeDescription.FieldToken(this.internalName, this.modifiers, this.descriptor, this.genericSignature, this.typeAnnotationTokens, this.annotationTokens));
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            protected class AnnotationExtractor extends AnnotationVisitor {
&nbsp;                private final AnnotationRegistrant annotationRegistrant;
&nbsp;                private final ComponentTypeLocator componentTypeLocator;
&nbsp;
&nbsp;                protected AnnotationExtractor(String descriptor, List&lt;LazyTypeDescription.AnnotationToken&gt; annotationTokens, ComponentTypeLocator componentTypeLocator) {
&nbsp;                    this(new AnnotationRegistrant.ForByteCodeElement(descriptor, annotationTokens), componentTypeLocator);
&nbsp;                }
&nbsp;
&nbsp;                protected AnnotationExtractor(String descriptor, int index, Map&lt;Integer, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt; annotationTokens, ComponentTypeLocator componentTypeLocator) {
&nbsp;                    this(new AnnotationRegistrant.ForByteCodeElement.WithIndex(descriptor, index, annotationTokens), componentTypeLocator);
&nbsp;                }
&nbsp;
&nbsp;                protected AnnotationExtractor(AnnotationRegistrant annotationRegistrant, ComponentTypeLocator componentTypeLocator) {
&nbsp;                    super(OpenedClassReader.ASM_API);
&nbsp;                    this.annotationRegistrant = annotationRegistrant;
&nbsp;                    this.componentTypeLocator = componentTypeLocator;
&nbsp;                }
&nbsp;
&nbsp;                public void visit(String name, Object value) {
&nbsp;                    if (value instanceof Type) {
&nbsp;                        Type type = (Type)value;
&nbsp;                        this.annotationRegistrant.register(name, new LazyTypeDescription.LazyAnnotationValue.ForTypeValue(Default.this, type.getSort() == 9 ? type.getInternalName().replace(&#39;/&#39;, &#39;.&#39;) : type.getClassName()));
&nbsp;                    } else {
&nbsp;                        this.annotationRegistrant.register(name, ForConstant.of(value));
&nbsp;                    }
&nbsp;
&nbsp;                }
&nbsp;
&nbsp;                public void visitEnum(String name, String descriptor, String value) {
&nbsp;                    this.annotationRegistrant.register(name, new LazyTypeDescription.LazyAnnotationValue.ForEnumerationValue(Default.this, descriptor.substring(1, descriptor.length() - 1).replace(&#39;/&#39;, &#39;.&#39;), value));
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationVisitor visitAnnotation(String name, String descriptor) {
&nbsp;                    return TypeExtractor.this.new AnnotationExtractor(new AnnotationLookup(descriptor, name), new ComponentTypeLocator.ForAnnotationProperty(Default.this, descriptor));
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationVisitor visitArray(String name) {
&nbsp;                    return TypeExtractor.this.new AnnotationExtractor(new ArrayLookup(name, this.componentTypeLocator.bind(name)), TypePool.Default.ComponentTypeLocator.Illegal.INSTANCE);
&nbsp;                }
&nbsp;
&nbsp;                public void visitEnd() {
&nbsp;                    this.annotationRegistrant.onComplete();
&nbsp;                }
&nbsp;
&nbsp;                protected class AnnotationLookup implements AnnotationRegistrant {
&nbsp;                    private final String descriptor;
&nbsp;                    private final String name;
&nbsp;                    private final Map&lt;String, AnnotationValue&lt;?, ?&gt;&gt; values;
&nbsp;
&nbsp;                    protected AnnotationLookup(String descriptor, String name) {
&nbsp;                        this.descriptor = descriptor;
&nbsp;                        this.name = name;
&nbsp;                        this.values = new HashMap();
&nbsp;                    }
&nbsp;
&nbsp;                    public void register(String name, AnnotationValue&lt;?, ?&gt; annotationValue) {
&nbsp;                        this.values.put(name, annotationValue);
&nbsp;                    }
&nbsp;
&nbsp;                    public void onComplete() {
&nbsp;                        AnnotationExtractor.this.annotationRegistrant.register(this.name, new LazyTypeDescription.LazyAnnotationValue.ForAnnotationValue(Default.this, new LazyTypeDescription.AnnotationToken(this.descriptor, this.values)));
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                protected class ArrayLookup implements AnnotationRegistrant {
&nbsp;                    private final String name;
&nbsp;                    private final AbstractBase.ComponentTypeReference componentTypeReference;
&nbsp;                    private final List&lt;AnnotationValue&lt;?, ?&gt;&gt; values;
&nbsp;
&nbsp;                    private ArrayLookup(String name, AbstractBase.ComponentTypeReference componentTypeReference) {
&nbsp;                        this.name = name;
&nbsp;                        this.componentTypeReference = componentTypeReference;
&nbsp;                        this.values = new ArrayList();
&nbsp;                    }
&nbsp;
&nbsp;                    public void register(String ignored, AnnotationValue&lt;?, ?&gt; annotationValue) {
&nbsp;                        this.values.add(annotationValue);
&nbsp;                    }
&nbsp;
&nbsp;                    public void onComplete() {
&nbsp;                        AnnotationExtractor.this.annotationRegistrant.register(this.name, new LazyTypeDescription.LazyAnnotationValue.ForArray(Default.this, this.componentTypeReference, this.values));
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        protected static class LazyTypeDescription extends TypeDescription.AbstractBase.OfSimpleType {
&nbsp;            @Nonnull(
&nbsp;                when = When.NEVER
&nbsp;            )
&nbsp;            private static final String NO_TYPE = null;
&nbsp;            private final TypePool typePool;
&nbsp;            private final int actualModifiers;
&nbsp;            private final int modifiers;
&nbsp;            private final String name;
&nbsp;            @Nonnull(
&nbsp;                when = When.MAYBE
&nbsp;            )
&nbsp;            private final String superClassDescriptor;
&nbsp;            @Nonnull(
&nbsp;                when = When.MAYBE
&nbsp;            )
&nbsp;            private final String genericSignature;
&nbsp;            private final GenericTypeToken.Resolution.ForType signatureResolution;
&nbsp;            private final List&lt;String&gt; interfaceTypeDescriptors;
&nbsp;            private final TypeContainment typeContainment;
&nbsp;            @Nonnull(
&nbsp;                when = When.MAYBE
&nbsp;            )
&nbsp;            private final String declaringTypeName;
&nbsp;            private final List&lt;String&gt; declaredTypes;
&nbsp;            private final boolean anonymousType;
&nbsp;            @Nonnull(
&nbsp;                when = When.MAYBE
&nbsp;            )
&nbsp;            private final String nestHost;
&nbsp;            private final List&lt;String&gt; nestMembers;
&nbsp;            private final Map&lt;String, List&lt;AnnotationToken&gt;&gt; superClassAnnotationTokens;
&nbsp;            private final Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; interfaceAnnotationTokens;
&nbsp;            private final Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; typeVariableAnnotationTokens;
&nbsp;            private final Map&lt;Integer, Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt;&gt; typeVariableBoundsAnnotationTokens;
&nbsp;            private final List&lt;AnnotationToken&gt; annotationTokens;
&nbsp;            private final List&lt;FieldToken&gt; fieldTokens;
&nbsp;            private final List&lt;MethodToken&gt; methodTokens;
&nbsp;            private final List&lt;RecordComponentToken&gt; recordComponentTokens;
&nbsp;            private final List&lt;String&gt; permittedSubclasses;
&nbsp;            private final ClassFileVersion classFileVersion;
&nbsp;
&nbsp;            protected LazyTypeDescription(TypePool typePool, int actualModifiers, int modifiers, String name, @Nonnull(when = When.MAYBE) String superClassInternalName, @Nonnull(when = When.MAYBE) String[] interfaceInternalName, @Nonnull(when = When.MAYBE) String genericSignature, TypeContainment typeContainment, @Nonnull(when = When.MAYBE) String declaringTypeInternalName, List&lt;String&gt; declaredTypes, boolean anonymousType, @Nonnull(when = When.MAYBE) String nestHostInternalName, List&lt;String&gt; nestMemberInternalNames, Map&lt;String, List&lt;AnnotationToken&gt;&gt; superClassAnnotationTokens, Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; interfaceAnnotationTokens, Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; typeVariableAnnotationTokens, Map&lt;Integer, Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt;&gt; typeVariableBoundsAnnotationTokens, List&lt;AnnotationToken&gt; annotationTokens, List&lt;FieldToken&gt; fieldTokens, List&lt;MethodToken&gt; methodTokens, List&lt;RecordComponentToken&gt; recordComponentTokens, List&lt;String&gt; permittedSubclasses, ClassFileVersion classFileVersion) {
&nbsp;                this.typePool = typePool;
&nbsp;                this.actualModifiers = actualModifiers &amp; -33;
&nbsp;                this.modifiers = modifiers &amp; -131105;
&nbsp;                this.name = Type.getObjectType(name).getClassName();
&nbsp;                this.superClassDescriptor = superClassInternalName == null ? NO_TYPE : Type.getObjectType(superClassInternalName).getDescriptor();
&nbsp;                this.genericSignature = genericSignature;
&nbsp;                this.signatureResolution = (GenericTypeToken.Resolution.ForType)(RAW_TYPES ? TypePool.Default.LazyTypeDescription.GenericTypeToken.Resolution.Raw.INSTANCE : TypePool.Default.GenericTypeExtractor.ForSignature.OfType.extract(genericSignature));
&nbsp;                if (interfaceInternalName == null) {
&nbsp;                    this.interfaceTypeDescriptors = Collections.emptyList();
&nbsp;                } else {
&nbsp;                    this.interfaceTypeDescriptors = new ArrayList(interfaceInternalName.length);
&nbsp;                    String[] var24 = interfaceInternalName;
&nbsp;                    int var25 = interfaceInternalName.length;
&nbsp;
&nbsp;                    for(int var26 = 0; var26 &lt; var25; ++var26) {
&nbsp;                        String internalName = var24[var26];
&nbsp;                        this.interfaceTypeDescriptors.add(Type.getObjectType(internalName).getDescriptor());
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                this.typeContainment = typeContainment;
&nbsp;                this.declaringTypeName = declaringTypeInternalName == null ? NO_TYPE : declaringTypeInternalName.replace(&#39;/&#39;, &#39;.&#39;);
&nbsp;                this.declaredTypes = declaredTypes;
&nbsp;                this.anonymousType = anonymousType;
&nbsp;                this.nestHost = nestHostInternalName == null ? NO_TYPE : Type.getObjectType(nestHostInternalName).getClassName();
&nbsp;                this.nestMembers = new ArrayList(nestMemberInternalNames.size());
&nbsp;                Iterator var28 = nestMemberInternalNames.iterator();
&nbsp;
&nbsp;                String internalName;
&nbsp;                while(var28.hasNext()) {
&nbsp;                    internalName = (String)var28.next();
&nbsp;                    this.nestMembers.add(Type.getObjectType(internalName).getClassName());
&nbsp;                }
&nbsp;
&nbsp;                this.superClassAnnotationTokens = superClassAnnotationTokens;
&nbsp;                this.interfaceAnnotationTokens = interfaceAnnotationTokens;
&nbsp;                this.typeVariableAnnotationTokens = typeVariableAnnotationTokens;
&nbsp;                this.typeVariableBoundsAnnotationTokens = typeVariableBoundsAnnotationTokens;
&nbsp;                this.annotationTokens = annotationTokens;
&nbsp;                this.fieldTokens = fieldTokens;
&nbsp;                this.methodTokens = methodTokens;
&nbsp;                this.recordComponentTokens = recordComponentTokens;
&nbsp;                this.permittedSubclasses = new ArrayList(permittedSubclasses.size());
&nbsp;                var28 = permittedSubclasses.iterator();
&nbsp;
&nbsp;                while(var28.hasNext()) {
&nbsp;                    internalName = (String)var28.next();
&nbsp;                    this.permittedSubclasses.add(Type.getObjectType(internalName).getDescriptor());
&nbsp;                }
&nbsp;
&nbsp;                this.classFileVersion = classFileVersion;
&nbsp;            }
&nbsp;
&nbsp;            @Nonnull(
&nbsp;                when = When.MAYBE
&nbsp;            )
&nbsp;            public TypeDescription.Generic getSuperClass() {
&nbsp;                return this.superClassDescriptor != null &amp;&amp; !this.isInterface() ? this.signatureResolution.resolveSuperClass(this.superClassDescriptor, this.typePool, this.superClassAnnotationTokens, this) : Generic.UNDEFINED;
&nbsp;            }
&nbsp;
&nbsp;            public TypeList.Generic getInterfaces() {
&nbsp;                return this.signatureResolution.resolveInterfaceTypes(this.interfaceTypeDescriptors, this.typePool, this.interfaceAnnotationTokens, this);
&nbsp;            }
&nbsp;
&nbsp;            @Nonnull(
&nbsp;                when = When.MAYBE
&nbsp;            )
&nbsp;            public MethodDescription.InDefinedShape getEnclosingMethod() {
&nbsp;                return this.typeContainment.getEnclosingMethod(this.typePool);
&nbsp;            }
&nbsp;
&nbsp;            @Nonnull(
&nbsp;                when = When.MAYBE
&nbsp;            )
&nbsp;            public TypeDescription getEnclosingType() {
&nbsp;                return this.typeContainment.getEnclosingType(this.typePool);
&nbsp;            }
&nbsp;
&nbsp;            public TypeList getDeclaredTypes() {
&nbsp;                return new LazyTypeList(this.typePool, this.declaredTypes);
&nbsp;            }
&nbsp;
&nbsp;            public boolean isAnonymousType() {
&nbsp;                return this.anonymousType;
&nbsp;            }
&nbsp;
&nbsp;            public boolean isLocalType() {
&nbsp;                return !this.anonymousType &amp;&amp; this.typeContainment.isLocalType();
&nbsp;            }
&nbsp;
&nbsp;            public FieldList&lt;FieldDescription.InDefinedShape&gt; getDeclaredFields() {
&nbsp;                return new FieldTokenList();
&nbsp;            }
&nbsp;
&nbsp;            public MethodList&lt;MethodDescription.InDefinedShape&gt; getDeclaredMethods() {
&nbsp;                return new MethodTokenList();
&nbsp;            }
&nbsp;
&nbsp;            @Nonnull(
&nbsp;                when = When.MAYBE
&nbsp;            )
&nbsp;            public PackageDescription getPackage() {
&nbsp;                String name = this.getName();
&nbsp;                int index = name.lastIndexOf(46);
&nbsp;                return new LazyPackageDescription(this.typePool, index == -1 ? &quot;&quot; : name.substring(0, index));
&nbsp;            }
&nbsp;
&nbsp;            public String getName() {
&nbsp;                return this.name;
&nbsp;            }
&nbsp;
&nbsp;            @Nonnull(
&nbsp;                when = When.MAYBE
&nbsp;            )
&nbsp;            public TypeDescription getDeclaringType() {
&nbsp;                return this.declaringTypeName == null ? TypeDescription.UNDEFINED : this.typePool.describe(this.declaringTypeName).resolve();
&nbsp;            }
&nbsp;
&nbsp;            public int getModifiers() {
&nbsp;                return this.modifiers;
&nbsp;            }
&nbsp;
&nbsp;            public int getActualModifiers(boolean superFlag) {
&nbsp;                return superFlag ? this.actualModifiers | 32 : this.actualModifiers;
&nbsp;            }
&nbsp;
&nbsp;            public TypeDescription getNestHost() {
&nbsp;                return (TypeDescription)(this.nestHost == null ? this : this.typePool.describe(this.nestHost).resolve());
&nbsp;            }
&nbsp;
&nbsp;            public TypeList getNestMembers() {
&nbsp;                return (TypeList)(this.nestHost == null ? new LazyNestMemberList(this, this.typePool, this.nestMembers) : this.typePool.describe(this.nestHost).resolve().getNestMembers());
&nbsp;            }
&nbsp;
&nbsp;            public AnnotationList getDeclaredAnnotations() {
&nbsp;                return TypePool.Default.LazyTypeDescription.LazyAnnotationDescription.asList(this.typePool, this.annotationTokens);
&nbsp;            }
&nbsp;
&nbsp;            public TypeList.Generic getTypeVariables() {
&nbsp;                return this.signatureResolution.resolveTypeVariables(this.typePool, this, this.typeVariableAnnotationTokens, this.typeVariableBoundsAnnotationTokens);
&nbsp;            }
&nbsp;
&nbsp;            @Nonnull(
&nbsp;                when = When.MAYBE
&nbsp;            )
&nbsp;            public String getGenericSignature() {
&nbsp;                return this.genericSignature;
&nbsp;            }
&nbsp;
&nbsp;            public RecordComponentList&lt;RecordComponentDescription.InDefinedShape&gt; getRecordComponents() {
&nbsp;                return new RecordComponentTokenList();
&nbsp;            }
&nbsp;
&nbsp;            public boolean isRecord() {
&nbsp;                return (this.actualModifiers &amp; 65536) != 0 &amp;&amp; JavaType.RECORD.getTypeStub().getDescriptor().equals(this.superClassDescriptor);
&nbsp;            }
&nbsp;
&nbsp;            public boolean isSealed() {
&nbsp;                return !this.permittedSubclasses.isEmpty();
&nbsp;            }
&nbsp;
&nbsp;            public TypeList getPermittedSubtypes() {
&nbsp;                return new LazyTypeList(this.typePool, this.permittedSubclasses);
&nbsp;            }
&nbsp;
&nbsp;            public ClassFileVersion getClassFileVersion() {
&nbsp;                return this.classFileVersion;
&nbsp;            }
&nbsp;
&nbsp;            private class LazyRecordComponentDescription extends RecordComponentDescription.InDefinedShape.AbstractBase {
&nbsp;                private final String name;
&nbsp;                private final String descriptor;
&nbsp;                @Nonnull(
&nbsp;                    when = When.MAYBE
&nbsp;                )
&nbsp;                private final String genericSignature;
&nbsp;                private final GenericTypeToken.Resolution.ForRecordComponent signatureResolution;
&nbsp;                private final Map&lt;String, List&lt;AnnotationToken&gt;&gt; typeAnnotationTokens;
&nbsp;                private final List&lt;AnnotationToken&gt; annotationTokens;
&nbsp;
&nbsp;                private LazyRecordComponentDescription(String name, String descriptor, @Nonnull(when = When.MAYBE) String genericSignature, GenericTypeToken.Resolution.ForRecordComponent signatureResolution, Map&lt;String, List&lt;AnnotationToken&gt;&gt; typeAnnotationTokens, List&lt;AnnotationToken&gt; annotationTokens) {
&nbsp;                    this.name = name;
&nbsp;                    this.descriptor = descriptor;
&nbsp;                    this.genericSignature = genericSignature;
&nbsp;                    this.signatureResolution = signatureResolution;
&nbsp;                    this.typeAnnotationTokens = typeAnnotationTokens;
&nbsp;                    this.annotationTokens = annotationTokens;
&nbsp;                }
&nbsp;
&nbsp;                public TypeDescription.Generic getType() {
&nbsp;                    return this.signatureResolution.resolveRecordType(this.descriptor, LazyTypeDescription.this.typePool, this.typeAnnotationTokens, this);
&nbsp;                }
&nbsp;
&nbsp;                @Nonnull
&nbsp;                public TypeDescription getDeclaringType() {
&nbsp;                    return LazyTypeDescription.this;
&nbsp;                }
&nbsp;
&nbsp;                public String getActualName() {
&nbsp;                    return this.name;
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationList getDeclaredAnnotations() {
&nbsp;                    return TypePool.Default.LazyTypeDescription.LazyAnnotationDescription.asList(LazyTypeDescription.this.typePool, this.annotationTokens);
&nbsp;                }
&nbsp;
&nbsp;                @Nonnull(
&nbsp;                    when = When.MAYBE
&nbsp;                )
&nbsp;                public String getGenericSignature() {
&nbsp;                    return this.genericSignature;
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            private class LazyMethodDescription extends MethodDescription.InDefinedShape.AbstractBase {
&nbsp;                private final String internalName;
&nbsp;                private final int modifiers;
&nbsp;                private final String returnTypeDescriptor;
&nbsp;                @Nonnull(
&nbsp;                    when = When.MAYBE
&nbsp;                )
&nbsp;                private final String genericSignature;
&nbsp;                private final GenericTypeToken.Resolution.ForMethod signatureResolution;
&nbsp;                private final List&lt;String&gt; parameterTypeDescriptors;
&nbsp;                private final List&lt;String&gt; exceptionTypeDescriptors;
&nbsp;                private final Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; typeVariableAnnotationTokens;
&nbsp;                private final Map&lt;Integer, Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt;&gt; typeVariableBoundAnnotationTokens;
&nbsp;                private final Map&lt;String, List&lt;AnnotationToken&gt;&gt; returnTypeAnnotationTokens;
&nbsp;                private final Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; parameterTypeAnnotationTokens;
&nbsp;                private final Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; exceptionTypeAnnotationTokens;
&nbsp;                private final Map&lt;String, List&lt;AnnotationToken&gt;&gt; receiverTypeAnnotationTokens;
&nbsp;                private final List&lt;AnnotationToken&gt; annotationTokens;
&nbsp;                private final Map&lt;Integer, List&lt;AnnotationToken&gt;&gt; parameterAnnotationTokens;
&nbsp;                private final String[] parameterNames;
&nbsp;                private final Integer[] parameterModifiers;
&nbsp;                @Nonnull(
&nbsp;                    when = When.MAYBE
&nbsp;                )
&nbsp;                private final AnnotationValue&lt;?, ?&gt; defaultValue;
&nbsp;
&nbsp;                private LazyMethodDescription(String internalName, int modifiers, String descriptor, @Nonnull(when = When.MAYBE) String genericSignature, GenericTypeToken.Resolution.ForMethod signatureResolution, @Nonnull(when = When.MAYBE) String[] exceptionTypeInternalName, Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; typeVariableAnnotationTokens, Map&lt;Integer, Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt;&gt; typeVariableBoundAnnotationTokens, Map&lt;String, List&lt;AnnotationToken&gt;&gt; returnTypeAnnotationTokens, Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; parameterTypeAnnotationTokens, Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; exceptionTypeAnnotationTokens, Map&lt;String, List&lt;AnnotationToken&gt;&gt; receiverTypeAnnotationTokens, List&lt;AnnotationToken&gt; annotationTokens, Map&lt;Integer, List&lt;AnnotationToken&gt;&gt; parameterAnnotationTokens, List&lt;MethodToken.ParameterToken&gt; parameterTokens, @Nonnull(when = When.MAYBE) AnnotationValue&lt;?, ?&gt; defaultValue) {
&nbsp;                    this.modifiers = modifiers;
&nbsp;                    this.internalName = internalName;
&nbsp;                    Type methodType = Type.getMethodType(descriptor);
&nbsp;                    Type returnType = methodType.getReturnType();
&nbsp;                    Type[] parameterType = methodType.getArgumentTypes();
&nbsp;                    this.returnTypeDescriptor = returnType.getDescriptor();
&nbsp;                    this.parameterTypeDescriptors = new ArrayList(parameterType.length);
&nbsp;                    Type[] var21 = parameterType;
&nbsp;                    int var22 = parameterType.length;
&nbsp;
&nbsp;                    int var23;
&nbsp;                    for(var23 = 0; var23 &lt; var22; ++var23) {
&nbsp;                        Type type = var21[var23];
&nbsp;                        this.parameterTypeDescriptors.add(type.getDescriptor());
&nbsp;                    }
&nbsp;
&nbsp;                    this.genericSignature = genericSignature;
&nbsp;                    this.signatureResolution = signatureResolution;
&nbsp;                    if (exceptionTypeInternalName == null) {
&nbsp;                        this.exceptionTypeDescriptors = Collections.emptyList();
&nbsp;                    } else {
&nbsp;                        this.exceptionTypeDescriptors = new ArrayList(exceptionTypeInternalName.length);
&nbsp;                        String[] var25 = exceptionTypeInternalName;
&nbsp;                        var22 = exceptionTypeInternalName.length;
&nbsp;
&nbsp;                        for(var23 = 0; var23 &lt; var22; ++var23) {
&nbsp;                            String anExceptionTypeInternalName = var25[var23];
&nbsp;                            this.exceptionTypeDescriptors.add(Type.getObjectType(anExceptionTypeInternalName).getDescriptor());
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    this.typeVariableAnnotationTokens = typeVariableAnnotationTokens;
&nbsp;                    this.typeVariableBoundAnnotationTokens = typeVariableBoundAnnotationTokens;
&nbsp;                    this.returnTypeAnnotationTokens = returnTypeAnnotationTokens;
&nbsp;                    this.parameterTypeAnnotationTokens = parameterTypeAnnotationTokens;
&nbsp;                    this.exceptionTypeAnnotationTokens = exceptionTypeAnnotationTokens;
&nbsp;                    this.receiverTypeAnnotationTokens = receiverTypeAnnotationTokens;
&nbsp;                    this.annotationTokens = annotationTokens;
&nbsp;                    this.parameterAnnotationTokens = parameterAnnotationTokens;
&nbsp;                    this.parameterNames = new String[parameterType.length];
&nbsp;                    this.parameterModifiers = new Integer[parameterType.length];
&nbsp;                    if (parameterTokens.size() == parameterType.length) {
&nbsp;                        int index = 0;
&nbsp;
&nbsp;                        for(Iterator var27 = parameterTokens.iterator(); var27.hasNext(); ++index) {
&nbsp;                            MethodToken.ParameterToken parameterToken = (MethodToken.ParameterToken)var27.next();
&nbsp;                            this.parameterNames[index] = parameterToken.getName();
&nbsp;                            this.parameterModifiers[index] = parameterToken.getModifiers();
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    this.defaultValue = defaultValue;
&nbsp;                }
&nbsp;
&nbsp;                public TypeDescription.Generic getReturnType() {
&nbsp;                    return this.signatureResolution.resolveReturnType(this.returnTypeDescriptor, LazyTypeDescription.this.typePool, this.returnTypeAnnotationTokens, this);
&nbsp;                }
&nbsp;
&nbsp;                public TypeList.Generic getExceptionTypes() {
&nbsp;                    return this.signatureResolution.resolveExceptionTypes(this.exceptionTypeDescriptors, LazyTypeDescription.this.typePool, this.exceptionTypeAnnotationTokens, this);
&nbsp;                }
&nbsp;
&nbsp;                public ParameterList&lt;ParameterDescription.InDefinedShape&gt; getParameters() {
&nbsp;                    return new LazyParameterList();
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationList getDeclaredAnnotations() {
&nbsp;                    return TypePool.Default.LazyTypeDescription.LazyAnnotationDescription.asList(LazyTypeDescription.this.typePool, this.annotationTokens);
&nbsp;                }
&nbsp;
&nbsp;                public String getInternalName() {
&nbsp;                    return this.internalName;
&nbsp;                }
&nbsp;
&nbsp;                @Nonnull
&nbsp;                public TypeDescription getDeclaringType() {
&nbsp;                    return LazyTypeDescription.this;
&nbsp;                }
&nbsp;
&nbsp;                public int getModifiers() {
&nbsp;                    return this.modifiers;
&nbsp;                }
&nbsp;
&nbsp;                public TypeList.Generic getTypeVariables() {
&nbsp;                    return this.signatureResolution.resolveTypeVariables(LazyTypeDescription.this.typePool, this, this.typeVariableAnnotationTokens, this.typeVariableBoundAnnotationTokens);
&nbsp;                }
&nbsp;
&nbsp;                @Nonnull(
&nbsp;                    when = When.MAYBE
&nbsp;                )
&nbsp;                public AnnotationValue&lt;?, ?&gt; getDefaultValue() {
&nbsp;                    return this.defaultValue;
&nbsp;                }
&nbsp;
&nbsp;                @Nonnull(
&nbsp;                    when = When.MAYBE
&nbsp;                )
&nbsp;                public TypeDescription.Generic getReceiverType() {
&nbsp;                    if (this.isStatic()) {
&nbsp;                        return Generic.UNDEFINED;
&nbsp;                    } else if (this.isConstructor()) {
&nbsp;                        TypeDescription declaringType = this.getDeclaringType();
&nbsp;                        TypeDescription enclosingDeclaringType = declaringType.getEnclosingType();
&nbsp;                        if (enclosingDeclaringType == null) {
&nbsp;                            return (TypeDescription.Generic)(declaringType.isGenerified() ? new LazyParameterizedReceiverType(declaringType) : new LazyNonGenericReceiverType(declaringType));
&nbsp;                        } else {
&nbsp;                            return (TypeDescription.Generic)(!declaringType.isStatic() &amp;&amp; declaringType.isGenerified() ? new LazyParameterizedReceiverType(enclosingDeclaringType) : new LazyNonGenericReceiverType(enclosingDeclaringType));
&nbsp;                        }
&nbsp;                    } else {
&nbsp;                        return (TypeDescription.Generic)(LazyTypeDescription.this.isGenerified() ? new LazyParameterizedReceiverType() : new LazyNonGenericReceiverType());
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Nonnull(
&nbsp;                    when = When.MAYBE
&nbsp;                )
&nbsp;                public String getGenericSignature() {
&nbsp;                    return this.genericSignature;
&nbsp;                }
&nbsp;
&nbsp;                protected class LazyNonGenericReceiverType extends TypeDescription.Generic.OfNonGenericType {
&nbsp;                    private final TypeDescription typeDescription;
&nbsp;
&nbsp;                    protected LazyNonGenericReceiverType() {
&nbsp;                        this(LazyTypeDescription.this);
&nbsp;                    }
&nbsp;
&nbsp;                    protected LazyNonGenericReceiverType(TypeDescription typeDescription) {
&nbsp;                        this.typeDescription = typeDescription;
&nbsp;                    }
&nbsp;
&nbsp;                    @Nonnull(
&nbsp;                        when = When.MAYBE
&nbsp;                    )
&nbsp;                    public TypeDescription.Generic getOwnerType() {
&nbsp;                        TypeDescription declaringType = this.typeDescription.getDeclaringType();
&nbsp;                        return (TypeDescription.Generic)(declaringType == null ? Generic.UNDEFINED : LazyMethodDescription.this.new LazyNonGenericReceiverType(declaringType));
&nbsp;                    }
&nbsp;
&nbsp;                    @Nonnull(
&nbsp;                        when = When.MAYBE
&nbsp;                    )
&nbsp;                    public TypeDescription.Generic getComponentType() {
&nbsp;                        return Generic.UNDEFINED;
&nbsp;                    }
&nbsp;
&nbsp;                    public AnnotationList getDeclaredAnnotations() {
&nbsp;                        StringBuilder typePath = new StringBuilder();
&nbsp;
&nbsp;                        for(int index = 0; index &lt; this.typeDescription.getInnerClassCount(); ++index) {
&nbsp;                            typePath = typePath.append(&#39;.&#39;);
&nbsp;                        }
&nbsp;
&nbsp;                        return TypePool.Default.LazyTypeDescription.LazyAnnotationDescription.asListOfNullable(LazyTypeDescription.this.typePool, (List)LazyMethodDescription.this.receiverTypeAnnotationTokens.get(typePath.toString()));
&nbsp;                    }
&nbsp;
&nbsp;                    public TypeDescription asErasure() {
&nbsp;                        return this.typeDescription;
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                private class LazyParameterizedReceiverType extends TypeDescription.Generic.OfParameterizedType {
&nbsp;                    private final TypeDescription typeDescription;
&nbsp;
&nbsp;                    protected LazyParameterizedReceiverType() {
&nbsp;                        this(LazyTypeDescription.this);
&nbsp;                    }
&nbsp;
&nbsp;                    protected LazyParameterizedReceiverType(TypeDescription typeDescription) {
&nbsp;                        this.typeDescription = typeDescription;
&nbsp;                    }
&nbsp;
&nbsp;                    public TypeList.Generic getTypeArguments() {
&nbsp;                        return new TypeArgumentList(this.typeDescription.getTypeVariables());
&nbsp;                    }
&nbsp;
&nbsp;                    @Nonnull(
&nbsp;                        when = When.MAYBE
&nbsp;                    )
&nbsp;                    public TypeDescription.Generic getOwnerType() {
&nbsp;                        TypeDescription declaringType = this.typeDescription.getDeclaringType();
&nbsp;                        if (declaringType == null) {
&nbsp;                            return Generic.UNDEFINED;
&nbsp;                        } else {
&nbsp;                            return (TypeDescription.Generic)(!this.typeDescription.isStatic() &amp;&amp; declaringType.isGenerified() ? LazyMethodDescription.this.new LazyParameterizedReceiverType(declaringType) : LazyMethodDescription.this.new LazyNonGenericReceiverType(declaringType));
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public AnnotationList getDeclaredAnnotations() {
&nbsp;                        return TypePool.Default.LazyTypeDescription.LazyAnnotationDescription.asListOfNullable(LazyTypeDescription.this.typePool, (List)LazyMethodDescription.this.receiverTypeAnnotationTokens.get(this.getTypePath()));
&nbsp;                    }
&nbsp;
&nbsp;                    private String getTypePath() {
&nbsp;                        StringBuilder typePath = new StringBuilder();
&nbsp;
&nbsp;                        for(int index = 0; index &lt; this.typeDescription.getInnerClassCount(); ++index) {
&nbsp;                            typePath = typePath.append(&#39;.&#39;);
&nbsp;                        }
&nbsp;
&nbsp;                        return typePath.toString();
&nbsp;                    }
&nbsp;
&nbsp;                    public TypeDescription asErasure() {
&nbsp;                        return this.typeDescription;
&nbsp;                    }
&nbsp;
&nbsp;                    protected class TypeArgumentList extends TypeList.Generic.AbstractBase {
&nbsp;                        private final List&lt;? extends TypeDescription.Generic&gt; typeVariables;
&nbsp;
&nbsp;                        protected TypeArgumentList(List&lt;? extends TypeDescription.Generic&gt; typeVariables) {
&nbsp;                            this.typeVariables = typeVariables;
&nbsp;                        }
&nbsp;
&nbsp;                        public TypeDescription.Generic get(int index) {
&nbsp;                            return new AnnotatedTypeVariable((TypeDescription.Generic)this.typeVariables.get(index), index);
&nbsp;                        }
&nbsp;
&nbsp;                        public int size() {
&nbsp;                            return this.typeVariables.size();
&nbsp;                        }
&nbsp;
&nbsp;                        protected class AnnotatedTypeVariable extends TypeDescription.Generic.OfTypeVariable {
&nbsp;                            private final TypeDescription.Generic typeVariable;
&nbsp;                            private final int index;
&nbsp;
&nbsp;                            protected AnnotatedTypeVariable(TypeDescription.Generic typeVariable, int index) {
&nbsp;                                this.typeVariable = typeVariable;
&nbsp;                                this.index = index;
&nbsp;                            }
&nbsp;
&nbsp;                            public TypeList.Generic getUpperBounds() {
&nbsp;                                return this.typeVariable.getUpperBounds();
&nbsp;                            }
&nbsp;
&nbsp;                            public TypeVariableSource getTypeVariableSource() {
&nbsp;                                return this.typeVariable.getTypeVariableSource();
&nbsp;                            }
&nbsp;
&nbsp;                            public String getSymbol() {
&nbsp;                                return this.typeVariable.getSymbol();
&nbsp;                            }
&nbsp;
&nbsp;                            public AnnotationList getDeclaredAnnotations() {
&nbsp;                                return TypePool.Default.LazyTypeDescription.LazyAnnotationDescription.asListOfNullable(LazyTypeDescription.this.typePool, (List)LazyMethodDescription.this.receiverTypeAnnotationTokens.get(LazyParameterizedReceiverType.this.getTypePath() + this.index + &#39;;&#39;));
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                private class LazyParameterDescription extends ParameterDescription.InDefinedShape.AbstractBase {
&nbsp;                    private final int index;
&nbsp;
&nbsp;                    protected LazyParameterDescription(int index) {
&nbsp;                        this.index = index;
&nbsp;                    }
&nbsp;
&nbsp;                    public MethodDescription.InDefinedShape getDeclaringMethod() {
&nbsp;                        return LazyMethodDescription.this;
&nbsp;                    }
&nbsp;
&nbsp;                    public int getIndex() {
&nbsp;                        return this.index;
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean isNamed() {
&nbsp;                        return LazyMethodDescription.this.parameterNames[this.index] != null;
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean hasModifiers() {
&nbsp;                        return LazyMethodDescription.this.parameterModifiers[this.index] != null;
&nbsp;                    }
&nbsp;
&nbsp;                    public String getName() {
&nbsp;                        return this.isNamed() ? LazyMethodDescription.this.parameterNames[this.index] : super.getName();
&nbsp;                    }
&nbsp;
&nbsp;                    public int getModifiers() {
&nbsp;                        return this.hasModifiers() ? LazyMethodDescription.this.parameterModifiers[this.index] : super.getModifiers();
&nbsp;                    }
&nbsp;
&nbsp;                    public TypeDescription.Generic getType() {
&nbsp;                        return (TypeDescription.Generic)LazyMethodDescription.this.signatureResolution.resolveParameterTypes(LazyMethodDescription.this.parameterTypeDescriptors, LazyTypeDescription.this.typePool, LazyMethodDescription.this.parameterTypeAnnotationTokens, LazyMethodDescription.this).get(this.index);
&nbsp;                    }
&nbsp;
&nbsp;                    public AnnotationList getDeclaredAnnotations() {
&nbsp;                        return TypePool.Default.LazyTypeDescription.LazyAnnotationDescription.asListOfNullable(LazyTypeDescription.this.typePool, (List)LazyMethodDescription.this.parameterAnnotationTokens.get(this.index));
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                private class LazyParameterList extends ParameterList.AbstractBase&lt;ParameterDescription.InDefinedShape&gt; {
&nbsp;                    private LazyParameterList() {
&nbsp;                    }
&nbsp;
&nbsp;                    public ParameterDescription.InDefinedShape get(int index) {
&nbsp;                        return LazyMethodDescription.this.new LazyParameterDescription(index);
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean hasExplicitMetaData() {
&nbsp;                        for(int i = 0; i &lt; this.size(); ++i) {
&nbsp;                            if (LazyMethodDescription.this.parameterNames[i] == null || LazyMethodDescription.this.parameterModifiers[i] == null) {
&nbsp;                                return false;
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        return true;
&nbsp;                    }
&nbsp;
&nbsp;                    public int size() {
&nbsp;                        return LazyMethodDescription.this.parameterTypeDescriptors.size();
&nbsp;                    }
&nbsp;
&nbsp;                    public TypeList.Generic asTypeList() {
&nbsp;                        return LazyMethodDescription.this.signatureResolution.resolveParameterTypes(LazyMethodDescription.this.parameterTypeDescriptors, LazyTypeDescription.this.typePool, LazyMethodDescription.this.parameterTypeAnnotationTokens, LazyMethodDescription.this);
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            private class LazyFieldDescription extends FieldDescription.InDefinedShape.AbstractBase {
&nbsp;                private final String name;
&nbsp;                private final int modifiers;
&nbsp;                private final String descriptor;
&nbsp;                @Nonnull(
&nbsp;                    when = When.MAYBE
&nbsp;                )
&nbsp;                private final String genericSignature;
&nbsp;                private final GenericTypeToken.Resolution.ForField signatureResolution;
&nbsp;                private final Map&lt;String, List&lt;AnnotationToken&gt;&gt; typeAnnotationTokens;
&nbsp;                private final List&lt;AnnotationToken&gt; annotationTokens;
&nbsp;
&nbsp;                private LazyFieldDescription(String name, int modifiers, String descriptor, @Nonnull(when = When.MAYBE) String genericSignature, GenericTypeToken.Resolution.ForField signatureResolution, Map&lt;String, List&lt;AnnotationToken&gt;&gt; typeAnnotationTokens, List&lt;AnnotationToken&gt; annotationTokens) {
&nbsp;                    this.modifiers = modifiers;
&nbsp;                    this.name = name;
&nbsp;                    this.descriptor = descriptor;
&nbsp;                    this.genericSignature = genericSignature;
&nbsp;                    this.signatureResolution = signatureResolution;
&nbsp;                    this.typeAnnotationTokens = typeAnnotationTokens;
&nbsp;                    this.annotationTokens = annotationTokens;
&nbsp;                }
&nbsp;
&nbsp;                public TypeDescription.Generic getType() {
&nbsp;                    return this.signatureResolution.resolveFieldType(this.descriptor, LazyTypeDescription.this.typePool, this.typeAnnotationTokens, this);
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationList getDeclaredAnnotations() {
&nbsp;                    return TypePool.Default.LazyTypeDescription.LazyAnnotationDescription.asListOfNullable(LazyTypeDescription.this.typePool, this.annotationTokens);
&nbsp;                }
&nbsp;
&nbsp;                public String getName() {
&nbsp;                    return this.name;
&nbsp;                }
&nbsp;
&nbsp;                @Nonnull
&nbsp;                public TypeDescription getDeclaringType() {
&nbsp;                    return LazyTypeDescription.this;
&nbsp;                }
&nbsp;
&nbsp;                public int getModifiers() {
&nbsp;                    return this.modifiers;
&nbsp;                }
&nbsp;
&nbsp;                @Nonnull(
&nbsp;                    when = When.MAYBE
&nbsp;                )
&nbsp;                public String getGenericSignature() {
&nbsp;                    return this.genericSignature;
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            protected static class TokenizedGenericType extends TypeDescription.Generic.LazyProjection.WithEagerNavigation {
&nbsp;                private final TypePool typePool;
&nbsp;                private final GenericTypeToken genericTypeToken;
&nbsp;                private final String rawTypeDescriptor;
&nbsp;                private final Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens;
&nbsp;                private final TypeVariableSource typeVariableSource;
&nbsp;
&nbsp;                protected TokenizedGenericType(TypePool typePool, GenericTypeToken genericTypeToken, String rawTypeDescriptor, Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens, TypeVariableSource typeVariableSource) {
&nbsp;                    this.typePool = typePool;
&nbsp;                    this.genericTypeToken = genericTypeToken;
&nbsp;                    this.rawTypeDescriptor = rawTypeDescriptor;
&nbsp;                    this.annotationTokens = annotationTokens;
&nbsp;                    this.typeVariableSource = typeVariableSource;
&nbsp;                }
&nbsp;
&nbsp;                protected static TypeDescription.Generic of(TypePool typePool, GenericTypeToken genericTypeToken, String rawTypeDescriptor, @Nonnull(when = When.MAYBE) Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens, TypeVariableSource typeVariableSource) {
&nbsp;                    return new TokenizedGenericType(typePool, genericTypeToken, rawTypeDescriptor, annotationTokens == null ? Collections.emptyMap() : annotationTokens, typeVariableSource);
&nbsp;                }
&nbsp;
&nbsp;                protected static TypeDescription toErasure(TypePool typePool, String descriptor) {
&nbsp;                    Type type = Type.getType(descriptor);
&nbsp;                    return typePool.describe(type.getSort() == 9 ? type.getInternalName().replace(&#39;/&#39;, &#39;.&#39;) : type.getClassName()).resolve();
&nbsp;                }
&nbsp;
&nbsp;                @net.bytebuddy.build.CachedReturnPlugin.Enhance(&quot;resolved&quot;)
&nbsp;                protected TypeDescription.Generic resolve() {
&nbsp;                    TypeDescription.Generic var1 = this.resolved;
&nbsp;                    TypeDescription.Generic var2 = var1 != null ? null : this.genericTypeToken.toGenericType(this.typePool, this.typeVariableSource, &quot;&quot;, this.annotationTokens);
&nbsp;                    if (var2 == null) {
&nbsp;                        var2 = (TypeDescription.Generic)this.resolved;
&nbsp;                    } else {
&nbsp;                        this.resolved = var2;
&nbsp;                    }
&nbsp;
&nbsp;                    return var2;
&nbsp;                }
&nbsp;
&nbsp;                @net.bytebuddy.build.CachedReturnPlugin.Enhance(&quot;erasure&quot;)
&nbsp;                public TypeDescription asErasure() {
&nbsp;                    TypeDescription var1 = this.erasure;
&nbsp;                    TypeDescription var2 = var1 != null ? null : toErasure(this.typePool, this.rawTypeDescriptor);
&nbsp;                    if (var2 == null) {
&nbsp;                        var2 = (TypeDescription)this.erasure;
&nbsp;                    } else {
&nbsp;                        this.erasure = var2;
&nbsp;                    }
&nbsp;
&nbsp;                    return var2;
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationList getDeclaredAnnotations() {
&nbsp;                    return this.resolve().getDeclaredAnnotations();
&nbsp;                }
&nbsp;
&nbsp;                protected static class Malformed extends TypeDescription.Generic.LazyProjection.WithEagerNavigation {
&nbsp;                    private final TypePool typePool;
&nbsp;                    private final String rawTypeDescriptor;
&nbsp;
&nbsp;                    protected Malformed(TypePool typePool, String rawTypeDescriptor) {
&nbsp;                        this.typePool = typePool;
&nbsp;                        this.rawTypeDescriptor = rawTypeDescriptor;
&nbsp;                    }
&nbsp;
&nbsp;                    protected TypeDescription.Generic resolve() {
&nbsp;                        throw new GenericSignatureFormatError();
&nbsp;                    }
&nbsp;
&nbsp;                    public TypeDescription asErasure() {
&nbsp;                        return TypePool.Default.LazyTypeDescription.TokenizedGenericType.toErasure(this.typePool, this.rawTypeDescriptor);
&nbsp;                    }
&nbsp;
&nbsp;                    public AnnotationList getDeclaredAnnotations() {
&nbsp;                        throw new GenericSignatureFormatError();
&nbsp;                    }
&nbsp;
&nbsp;                    protected static class TokenList extends TypeList.Generic.AbstractBase {
&nbsp;                        private final TypePool typePool;
&nbsp;                        private final List&lt;String&gt; rawTypeDescriptors;
&nbsp;
&nbsp;                        protected TokenList(TypePool typePool, List&lt;String&gt; rawTypeDescriptors) {
&nbsp;                            this.typePool = typePool;
&nbsp;                            this.rawTypeDescriptors = rawTypeDescriptors;
&nbsp;                        }
&nbsp;
&nbsp;                        public TypeDescription.Generic get(int index) {
&nbsp;                            return new Malformed(this.typePool, (String)this.rawTypeDescriptors.get(index));
&nbsp;                        }
&nbsp;
&nbsp;                        public int size() {
&nbsp;                            return this.rawTypeDescriptors.size();
&nbsp;                        }
&nbsp;
&nbsp;                        public TypeList asErasures() {
&nbsp;                            return new LazyTypeList(this.typePool, this.rawTypeDescriptors);
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                protected static class TypeVariableList extends TypeList.Generic.AbstractBase {
&nbsp;                    private final TypePool typePool;
&nbsp;                    private final List&lt;GenericTypeToken.OfFormalTypeVariable&gt; typeVariables;
&nbsp;                    private final TypeVariableSource typeVariableSource;
&nbsp;                    private final Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens;
&nbsp;                    private final Map&lt;Integer, Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt;&gt; boundAnnotationTokens;
&nbsp;
&nbsp;                    protected TypeVariableList(TypePool typePool, List&lt;GenericTypeToken.OfFormalTypeVariable&gt; typeVariables, TypeVariableSource typeVariableSource, Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens, Map&lt;Integer, Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt;&gt; boundAnnotationTokens) {
&nbsp;                        this.typePool = typePool;
&nbsp;                        this.typeVariables = typeVariables;
&nbsp;                        this.typeVariableSource = typeVariableSource;
&nbsp;                        this.annotationTokens = annotationTokens;
&nbsp;                        this.boundAnnotationTokens = boundAnnotationTokens;
&nbsp;                    }
&nbsp;
&nbsp;                    public TypeDescription.Generic get(int index) {
&nbsp;                        return ((GenericTypeToken.OfFormalTypeVariable)this.typeVariables.get(index)).toGenericType(this.typePool, this.typeVariableSource, (Map)this.annotationTokens.get(index), (Map)this.boundAnnotationTokens.get(index));
&nbsp;                    }
&nbsp;
&nbsp;                    public int size() {
&nbsp;                        return this.typeVariables.size();
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                protected static class TokenList extends TypeList.Generic.AbstractBase {
&nbsp;                    private final TypePool typePool;
&nbsp;                    private final List&lt;GenericTypeToken&gt; genericTypeTokens;
&nbsp;                    private final List&lt;String&gt; rawTypeDescriptors;
&nbsp;                    private final TypeVariableSource typeVariableSource;
&nbsp;                    private final Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens;
&nbsp;
&nbsp;                    private TokenList(TypePool typePool, List&lt;GenericTypeToken&gt; genericTypeTokens, Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens, List&lt;String&gt; rawTypeDescriptors, TypeVariableSource typeVariableSource) {
&nbsp;                        this.typePool = typePool;
&nbsp;                        this.genericTypeTokens = genericTypeTokens;
&nbsp;                        this.annotationTokens = annotationTokens;
&nbsp;                        this.rawTypeDescriptors = rawTypeDescriptors;
&nbsp;                        this.typeVariableSource = typeVariableSource;
&nbsp;                    }
&nbsp;
&nbsp;                    public TypeDescription.Generic get(int index) {
&nbsp;                        return this.rawTypeDescriptors.size() == this.genericTypeTokens.size() ? TypePool.Default.LazyTypeDescription.TokenizedGenericType.of(this.typePool, (GenericTypeToken)this.genericTypeTokens.get(index), (String)this.rawTypeDescriptors.get(index), (Map)this.annotationTokens.get(index), this.typeVariableSource) : TypePool.Default.LazyTypeDescription.TokenizedGenericType.toErasure(this.typePool, (String)this.rawTypeDescriptors.get(index)).asGenericType();
&nbsp;                    }
&nbsp;
&nbsp;                    public int size() {
&nbsp;                        return this.rawTypeDescriptors.size();
&nbsp;                    }
&nbsp;
&nbsp;                    public TypeList asErasures() {
&nbsp;                        return new LazyTypeList(this.typePool, this.rawTypeDescriptors);
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            protected static class LazyNestMemberList extends TypeList.AbstractBase {
&nbsp;                private final TypeDescription typeDescription;
&nbsp;                private final TypePool typePool;
&nbsp;                private final List&lt;String&gt; nestMembers;
&nbsp;
&nbsp;                protected LazyNestMemberList(TypeDescription typeDescription, TypePool typePool, List&lt;String&gt; nestMembers) {
&nbsp;                    this.typeDescription = typeDescription;
&nbsp;                    this.typePool = typePool;
&nbsp;                    this.nestMembers = nestMembers;
&nbsp;                }
&nbsp;
&nbsp;                public TypeDescription get(int index) {
&nbsp;                    return index == 0 ? this.typeDescription : this.typePool.describe((String)this.nestMembers.get(index - 1)).resolve();
&nbsp;                }
&nbsp;
&nbsp;                public int size() {
&nbsp;                    return this.nestMembers.size() + 1;
&nbsp;                }
&nbsp;
&nbsp;                public String[] toInternalNames() {
&nbsp;                    String[] internalName = new String[this.nestMembers.size() + 1];
&nbsp;                    internalName[0] = this.typeDescription.getInternalName();
&nbsp;                    int index = 1;
&nbsp;
&nbsp;                    String name;
&nbsp;                    for(Iterator var3 = this.nestMembers.iterator(); var3.hasNext(); internalName[index++] = name.replace(&#39;.&#39;, &#39;/&#39;)) {
&nbsp;                        name = (String)var3.next();
&nbsp;                    }
&nbsp;
&nbsp;                    return internalName;
&nbsp;                }
&nbsp;
&nbsp;                public int getStackSize() {
&nbsp;                    return this.nestMembers.size() + 1;
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            protected static class LazyTypeList extends TypeList.AbstractBase {
&nbsp;                private final TypePool typePool;
&nbsp;                private final List&lt;String&gt; descriptors;
&nbsp;
&nbsp;                protected LazyTypeList(TypePool typePool, List&lt;String&gt; descriptors) {
&nbsp;                    this.typePool = typePool;
&nbsp;                    this.descriptors = descriptors;
&nbsp;                }
&nbsp;
&nbsp;                public TypeDescription get(int index) {
&nbsp;                    return TypePool.Default.LazyTypeDescription.TokenizedGenericType.toErasure(this.typePool, (String)this.descriptors.get(index));
&nbsp;                }
&nbsp;
&nbsp;                public int size() {
&nbsp;                    return this.descriptors.size();
&nbsp;                }
&nbsp;
&nbsp;                @Nonnull(
&nbsp;                    when = When.MAYBE
&nbsp;                )
&nbsp;                public String[] toInternalNames() {
&nbsp;                    String[] internalName = new String[this.descriptors.size()];
&nbsp;                    int index = 0;
&nbsp;
&nbsp;                    String descriptor;
&nbsp;                    for(Iterator var3 = this.descriptors.iterator(); var3.hasNext(); internalName[index++] = Type.getType(descriptor).getInternalName()) {
&nbsp;                        descriptor = (String)var3.next();
&nbsp;                    }
&nbsp;
&nbsp;                    return internalName.length == 0 ? NO_INTERFACES : internalName;
&nbsp;                }
&nbsp;
&nbsp;                public int getStackSize() {
&nbsp;                    int stackSize = 0;
&nbsp;
&nbsp;                    String descriptor;
&nbsp;                    for(Iterator var2 = this.descriptors.iterator(); var2.hasNext(); stackSize += Type.getType(descriptor).getSize()) {
&nbsp;                        descriptor = (String)var2.next();
&nbsp;                    }
&nbsp;
&nbsp;                    return stackSize;
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            private static class LazyPackageDescription extends PackageDescription.AbstractBase {
&nbsp;                private final TypePool typePool;
&nbsp;                private final String name;
&nbsp;
&nbsp;                private LazyPackageDescription(TypePool typePool, String name) {
&nbsp;                    this.typePool = typePool;
&nbsp;                    this.name = name;
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationList getDeclaredAnnotations() {
&nbsp;                    Resolution resolution = this.typePool.describe(this.name + &quot;.&quot; + &quot;package-info&quot;);
&nbsp;                    return (AnnotationList)(resolution.isResolved() ? resolution.resolve().getDeclaredAnnotations() : new AnnotationList.Empty());
&nbsp;                }
&nbsp;
&nbsp;                public String getName() {
&nbsp;                    return this.name;
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            private abstract static class LazyAnnotationValue&lt;U, V&gt; extends AnnotationValue.AbstractBase&lt;U, V&gt; {
&nbsp;                private LazyAnnotationValue() {
&nbsp;                }
&nbsp;
&nbsp;                protected abstract AnnotationValue&lt;U, V&gt; doResolve();
&nbsp;
&nbsp;                public AnnotationValue.State getState() {
&nbsp;                    return this.doResolve().getState();
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationValue&lt;U, V&gt; filter(MethodDescription.InDefinedShape property, TypeDefinition typeDefinition) {
&nbsp;                    return this.doResolve().filter(property, typeDefinition);
&nbsp;                }
&nbsp;
&nbsp;                public U resolve() {
&nbsp;                    return this.doResolve().resolve();
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationValue.Loaded&lt;V&gt; load(@Nonnull(when = When.MAYBE) ClassLoader classLoader) {
&nbsp;                    return this.doResolve().load(classLoader);
&nbsp;                }
&nbsp;
&nbsp;                @net.bytebuddy.build.CachedReturnPlugin.Enhance(&quot;hashCode&quot;)
&nbsp;                public int hashCode() {
&nbsp;                    int var1 = this.hashCode;
&nbsp;                    int var2 = var1 != 0 ? 0 : this.doResolve().hashCode();
&nbsp;                    if (var2 == 0) {
&nbsp;                        var2 = this.hashCode;
&nbsp;                    } else {
&nbsp;                        this.hashCode = var2;
&nbsp;                    }
&nbsp;
&nbsp;                    return var2;
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(@CheckForNull Object other) {
&nbsp;                    return this.doResolve().equals(other);
&nbsp;                }
&nbsp;
&nbsp;                public String toString() {
&nbsp;                    return this.doResolve().toString();
&nbsp;                }
&nbsp;
&nbsp;                private static class ForArray extends LazyAnnotationValue&lt;Object, Object&gt; {
&nbsp;                    private final TypePool typePool;
&nbsp;                    private final AbstractBase.ComponentTypeReference componentTypeReference;
&nbsp;                    private final List&lt;AnnotationValue&lt;?, ?&gt;&gt; values;
&nbsp;
&nbsp;                    private ForArray(TypePool typePool, AbstractBase.ComponentTypeReference componentTypeReference, List&lt;AnnotationValue&lt;?, ?&gt;&gt; values) {
&nbsp;                        super(null);
&nbsp;                        this.typePool = typePool;
&nbsp;                        this.componentTypeReference = componentTypeReference;
&nbsp;                        this.values = values;
&nbsp;                    }
&nbsp;
&nbsp;                    public AnnotationValue.Sort getSort() {
&nbsp;                        return net.bytebuddy.description.annotation.AnnotationValue.Sort.ARRAY;
&nbsp;                    }
&nbsp;
&nbsp;                    @net.bytebuddy.build.CachedReturnPlugin.Enhance(&quot;resolved&quot;)
&nbsp;                    protected AnnotationValue&lt;Object, Object&gt; doResolve() {
&nbsp;                        AnnotationValue var1 = this.resolved;
&nbsp;                        Object var10000;
&nbsp;                        if (var1 != null) {
&nbsp;                            var10000 = null;
&nbsp;                        } else {
&nbsp;                            label85: {
&nbsp;                                String typeName = this.componentTypeReference.resolve();
&nbsp;                                if (typeName != null) {
&nbsp;                                    Resolution resolution = this.typePool.describe(typeName);
&nbsp;                                    if (!resolution.isResolved()) {
&nbsp;                                        var10000 = new AnnotationValue.ForMissingType(typeName);
&nbsp;                                        break label85;
&nbsp;                                    }
&nbsp;
&nbsp;                                    if (resolution.resolve().isEnum()) {
&nbsp;                                        var10000 = new AnnotationValue.ForDescriptionArray(EnumerationDescription.class, resolution.resolve(), this.values);
&nbsp;                                        break label85;
&nbsp;                                    }
&nbsp;
&nbsp;                                    if (resolution.resolve().isAnnotation()) {
&nbsp;                                        var10000 = new AnnotationValue.ForDescriptionArray(AnnotationDescription.class, resolution.resolve(), this.values);
&nbsp;                                        break label85;
&nbsp;                                    }
&nbsp;
&nbsp;                                    if (resolution.resolve().represents(Class.class)) {
&nbsp;                                        var10000 = new AnnotationValue.ForDescriptionArray(TypeDescription.class, resolution.resolve(), this.values);
&nbsp;                                        break label85;
&nbsp;                                    }
&nbsp;
&nbsp;                                    if (resolution.resolve().represents(String.class)) {
&nbsp;                                        var10000 = new AnnotationValue.ForDescriptionArray(String.class, resolution.resolve(), this.values);
&nbsp;                                        break label85;
&nbsp;                                    }
&nbsp;
&nbsp;                                    if (resolution.resolve().represents(Boolean.TYPE)) {
&nbsp;                                        var10000 = new AnnotationValue.ForDescriptionArray(Boolean.TYPE, resolution.resolve(), this.values);
&nbsp;                                        break label85;
&nbsp;                                    }
&nbsp;
&nbsp;                                    if (resolution.resolve().represents(Byte.TYPE)) {
&nbsp;                                        var10000 = new AnnotationValue.ForDescriptionArray(Byte.TYPE, resolution.resolve(), this.values);
&nbsp;                                        break label85;
&nbsp;                                    }
&nbsp;
&nbsp;                                    if (resolution.resolve().represents(Short.TYPE)) {
&nbsp;                                        var10000 = new AnnotationValue.ForDescriptionArray(Short.TYPE, resolution.resolve(), this.values);
&nbsp;                                        break label85;
&nbsp;                                    }
&nbsp;
&nbsp;                                    if (resolution.resolve().represents(Character.TYPE)) {
&nbsp;                                        var10000 = new AnnotationValue.ForDescriptionArray(Character.TYPE, resolution.resolve(), this.values);
&nbsp;                                        break label85;
&nbsp;                                    }
&nbsp;
&nbsp;                                    if (resolution.resolve().represents(Integer.TYPE)) {
&nbsp;                                        var10000 = new AnnotationValue.ForDescriptionArray(Integer.TYPE, resolution.resolve(), this.values);
&nbsp;                                        break label85;
&nbsp;                                    }
&nbsp;
&nbsp;                                    if (resolution.resolve().represents(Long.TYPE)) {
&nbsp;                                        var10000 = new AnnotationValue.ForDescriptionArray(Long.TYPE, resolution.resolve(), this.values);
&nbsp;                                        break label85;
&nbsp;                                    }
&nbsp;
&nbsp;                                    if (resolution.resolve().represents(Float.TYPE)) {
&nbsp;                                        var10000 = new AnnotationValue.ForDescriptionArray(Float.TYPE, resolution.resolve(), this.values);
&nbsp;                                        break label85;
&nbsp;                                    }
&nbsp;
&nbsp;                                    if (resolution.resolve().represents(Double.TYPE)) {
&nbsp;                                        var10000 = new AnnotationValue.ForDescriptionArray(Double.TYPE, resolution.resolve(), this.values);
&nbsp;                                        break label85;
&nbsp;                                    }
&nbsp;                                }
&nbsp;
&nbsp;                                AnnotationValue.Sort sort = net.bytebuddy.description.annotation.AnnotationValue.Sort.NONE;
&nbsp;
&nbsp;                                for(ListIterator&lt;AnnotationValue&lt;?, ?&gt;&gt; iterator = this.values.listIterator(this.values.size()); iterator.hasPrevious() &amp;&amp; !sort.isDefined(); sort = ((AnnotationValue)iterator.previous()).getSort()) {
&nbsp;                                }
&nbsp;
&nbsp;                                var10000 = new ForMismatchedType(RenderingDispatcher.CURRENT.toArrayErrorString(sort), sort);
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        Object var2 = var10000;
&nbsp;                        if (var2 == null) {
&nbsp;                            var2 = (AnnotationValue)this.resolved;
&nbsp;                        } else {
&nbsp;                            this.resolved = (AnnotationValue)var2;
&nbsp;                        }
&nbsp;
&nbsp;                        return (AnnotationValue)var2;
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                private static class ForEnumerationValue extends LazyAnnotationValue&lt;EnumerationDescription, Enum&lt;?&gt;&gt; {
&nbsp;                    private final TypePool typePool;
&nbsp;                    private final String typeName;
&nbsp;                    private final String value;
&nbsp;
&nbsp;                    private ForEnumerationValue(TypePool typePool, String typeName, String value) {
&nbsp;                        super(null);
&nbsp;                        this.typePool = typePool;
&nbsp;                        this.typeName = typeName;
&nbsp;                        this.value = value;
&nbsp;                    }
&nbsp;
&nbsp;                    public AnnotationValue.Sort getSort() {
&nbsp;                        return net.bytebuddy.description.annotation.AnnotationValue.Sort.ENUMERATION;
&nbsp;                    }
&nbsp;
&nbsp;                    @net.bytebuddy.build.CachedReturnPlugin.Enhance(&quot;resolved&quot;)
&nbsp;                    protected AnnotationValue&lt;EnumerationDescription, Enum&lt;?&gt;&gt; doResolve() {
&nbsp;                        AnnotationValue var1 = this.resolved;
&nbsp;                        Object var10000;
&nbsp;                        if (var1 != null) {
&nbsp;                            var10000 = null;
&nbsp;                        } else {
&nbsp;                            Resolution resolution = this.typePool.describe(this.typeName);
&nbsp;                            var10000 = !resolution.isResolved() ? new AnnotationValue.ForMissingType(this.typeName) : (!resolution.resolve().isEnum() ? new ForMismatchedType(this.typeName + &quot;.&quot; + this.value, net.bytebuddy.description.annotation.AnnotationValue.Sort.ENUMERATION) : (((FieldList)resolution.resolve().getDeclaredFields().filter(ElementMatchers.named(this.value))).isEmpty() ? new AnnotationValue.ForEnumerationDescription.WithUnknownConstant(resolution.resolve(), this.value) : new AnnotationValue.ForEnumerationDescription(new EnumerationDescription.Latent(resolution.resolve(), this.value))));
&nbsp;                        }
&nbsp;
&nbsp;                        Object var2 = var10000;
&nbsp;                        if (var2 == null) {
&nbsp;                            var2 = (AnnotationValue)this.resolved;
&nbsp;                        } else {
&nbsp;                            this.resolved = (AnnotationValue)var2;
&nbsp;                        }
&nbsp;
&nbsp;                        return (AnnotationValue)var2;
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                private static class ForAnnotationValue extends LazyAnnotationValue&lt;AnnotationDescription, Annotation&gt; {
&nbsp;                    private final TypePool typePool;
&nbsp;                    private final AnnotationToken annotationToken;
&nbsp;
&nbsp;                    private ForAnnotationValue(TypePool typePool, AnnotationToken annotationToken) {
&nbsp;                        super(null);
&nbsp;                        this.typePool = typePool;
&nbsp;                        this.annotationToken = annotationToken;
&nbsp;                    }
&nbsp;
&nbsp;                    public AnnotationValue.Sort getSort() {
&nbsp;                        return net.bytebuddy.description.annotation.AnnotationValue.Sort.ANNOTATION;
&nbsp;                    }
&nbsp;
&nbsp;                    @net.bytebuddy.build.CachedReturnPlugin.Enhance(&quot;resolved&quot;)
&nbsp;                    protected AnnotationValue&lt;AnnotationDescription, Annotation&gt; doResolve() {
&nbsp;                        AnnotationValue var1 = this.resolved;
&nbsp;                        Object var10000;
&nbsp;                        if (var1 != null) {
&nbsp;                            var10000 = null;
&nbsp;                        } else {
&nbsp;                            AnnotationToken.Resolution resolution = this.annotationToken.toAnnotationDescription(this.typePool);
&nbsp;                            var10000 = !resolution.isResolved() ? new AnnotationValue.ForMissingType(this.annotationToken.getBinaryName()) : (!resolution.resolve().getAnnotationType().isAnnotation() ? new ForMismatchedType(resolution.resolve().getAnnotationType().getName(), net.bytebuddy.description.annotation.AnnotationValue.Sort.ANNOTATION) : new AnnotationValue.ForAnnotationDescription(resolution.resolve()));
&nbsp;                        }
&nbsp;
&nbsp;                        Object var2 = var10000;
&nbsp;                        if (var2 == null) {
&nbsp;                            var2 = (AnnotationValue)this.resolved;
&nbsp;                        } else {
&nbsp;                            this.resolved = (AnnotationValue)var2;
&nbsp;                        }
&nbsp;
&nbsp;                        return (AnnotationValue)var2;
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                private static class ForTypeValue extends LazyAnnotationValue&lt;TypeDescription, Class&lt;?&gt;&gt; {
&nbsp;                    private final TypePool typePool;
&nbsp;                    private final String typeName;
&nbsp;
&nbsp;                    private ForTypeValue(TypePool typePool, String typeName) {
&nbsp;                        super(null);
&nbsp;                        this.typePool = typePool;
&nbsp;                        this.typeName = typeName;
&nbsp;                    }
&nbsp;
&nbsp;                    public AnnotationValue.Sort getSort() {
&nbsp;                        return net.bytebuddy.description.annotation.AnnotationValue.Sort.TYPE;
&nbsp;                    }
&nbsp;
&nbsp;                    @net.bytebuddy.build.CachedReturnPlugin.Enhance(&quot;resolved&quot;)
&nbsp;                    protected AnnotationValue&lt;TypeDescription, Class&lt;?&gt;&gt; doResolve() {
&nbsp;                        AnnotationValue var1 = this.resolved;
&nbsp;                        Object var10000;
&nbsp;                        if (var1 != null) {
&nbsp;                            var10000 = null;
&nbsp;                        } else {
&nbsp;                            Resolution resolution = this.typePool.describe(this.typeName);
&nbsp;                            var10000 = resolution.isResolved() ? new AnnotationValue.ForTypeDescription(resolution.resolve()) : new AnnotationValue.ForMissingType(this.typeName);
&nbsp;                        }
&nbsp;
&nbsp;                        Object var2 = var10000;
&nbsp;                        if (var2 == null) {
&nbsp;                            var2 = (AnnotationValue)this.resolved;
&nbsp;                        } else {
&nbsp;                            this.resolved = (AnnotationValue)var2;
&nbsp;                        }
&nbsp;
&nbsp;                        return (AnnotationValue)var2;
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Enhance
&nbsp;                private static class ForMismatchedType&lt;W, X&gt; extends AnnotationValue.AbstractBase&lt;W, X&gt; {
&nbsp;                    private final String value;
&nbsp;                    private final AnnotationValue.Sort sort;
&nbsp;
&nbsp;                    private ForMismatchedType(String value, AnnotationValue.Sort sort) {
&nbsp;                        this.value = value;
&nbsp;                        this.sort = sort;
&nbsp;                    }
&nbsp;
&nbsp;                    public AnnotationValue.State getState() {
&nbsp;                        return State.UNRESOLVED;
&nbsp;                    }
&nbsp;
&nbsp;                    public AnnotationValue.Sort getSort() {
&nbsp;                        return net.bytebuddy.description.annotation.AnnotationValue.Sort.NONE;
&nbsp;                    }
&nbsp;
&nbsp;                    public AnnotationValue&lt;W, X&gt; filter(MethodDescription.InDefinedShape property, TypeDefinition typeDefinition) {
&nbsp;                        return new AnnotationValue.ForMismatchedType(property, property.getReturnType().isArray() ? RenderingDispatcher.CURRENT.toArrayErrorString(this.sort) : this.value);
&nbsp;                    }
&nbsp;
&nbsp;                    public W resolve() {
&nbsp;                        throw new IllegalStateException(&quot;Expected filtering of this unresolved property&quot;);
&nbsp;                    }
&nbsp;
&nbsp;                    public AnnotationValue.Loaded&lt;X&gt; load(@Nonnull(when = When.MAYBE) ClassLoader classLoader) {
&nbsp;                        throw new IllegalStateException(&quot;Expected filtering of this unresolved property&quot;);
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(Object var1) {
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else if (!this.sort.equals(((ForMismatchedType)var1).sort)) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return this.value.equals(((ForMismatchedType)var1).value);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return (this.getClass().hashCode() * 31 + this.value.hashCode()) * 31 + this.sort.hashCode();
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            private static class LazyAnnotationDescription extends AnnotationDescription.AbstractBase {
&nbsp;                protected final TypePool typePool;
&nbsp;                private final TypeDescription annotationType;
&nbsp;                protected final Map&lt;String, AnnotationValue&lt;?, ?&gt;&gt; values;
&nbsp;
&nbsp;                private LazyAnnotationDescription(TypePool typePool, TypeDescription annotationType, Map&lt;String, AnnotationValue&lt;?, ?&gt;&gt; values) {
&nbsp;                    this.typePool = typePool;
&nbsp;                    this.annotationType = annotationType;
&nbsp;                    this.values = values;
&nbsp;                }
&nbsp;
&nbsp;                protected static AnnotationList asListOfNullable(TypePool typePool, @Nonnull(when = When.MAYBE) List&lt;? extends AnnotationToken&gt; tokens) {
&nbsp;                    return (AnnotationList)(tokens == null ? new AnnotationList.Empty() : asList(typePool, tokens));
&nbsp;                }
&nbsp;
&nbsp;                protected static AnnotationList asList(TypePool typePool, List&lt;? extends AnnotationToken&gt; tokens) {
&nbsp;                    List&lt;AnnotationDescription&gt; annotationDescriptions = new ArrayList(tokens.size());
&nbsp;                    Iterator var3 = tokens.iterator();
&nbsp;
&nbsp;                    while(var3.hasNext()) {
&nbsp;                        AnnotationToken token = (AnnotationToken)var3.next();
&nbsp;                        AnnotationToken.Resolution resolution = token.toAnnotationDescription(typePool);
&nbsp;                        if (resolution.isResolved() &amp;&amp; resolution.resolve().getAnnotationType().isAnnotation()) {
&nbsp;                            annotationDescriptions.add(resolution.resolve());
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    return new AnnotationList.Explicit(annotationDescriptions);
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationValue&lt;?, ?&gt; getValue(MethodDescription.InDefinedShape property) {
&nbsp;                    if (!property.getDeclaringType().asErasure().equals(this.annotationType)) {
&nbsp;                        throw new IllegalArgumentException(property + &quot; is not declared by &quot; + this.getAnnotationType());
&nbsp;                    } else {
&nbsp;                        AnnotationValue&lt;?, ?&gt; annotationValue = (AnnotationValue)this.values.get(property.getName());
&nbsp;                        if (annotationValue != null) {
&nbsp;                            return annotationValue.filter(property);
&nbsp;                        } else {
&nbsp;                            annotationValue = ((MethodDescription.InDefinedShape)((MethodList)this.getAnnotationType().getDeclaredMethods().filter(ElementMatchers.is(property))).getOnly()).getDefaultValue();
&nbsp;                            return (AnnotationValue)(annotationValue == null ? new AnnotationValue.ForMissingValue(this.annotationType, property.getName()) : annotationValue);
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public TypeDescription getAnnotationType() {
&nbsp;                    return this.annotationType;
&nbsp;                }
&nbsp;
&nbsp;                public &lt;T extends Annotation&gt; Loadable&lt;T&gt; prepare(Class&lt;T&gt; annotationType) {
&nbsp;                    if (!this.annotationType.represents(annotationType)) {
&nbsp;                        throw new IllegalArgumentException(annotationType + &quot; does not represent &quot; + this.annotationType);
&nbsp;                    } else {
&nbsp;                        return new Loadable(this.typePool, annotationType, this.values);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                private static class Loadable&lt;S extends Annotation&gt; extends LazyAnnotationDescription implements AnnotationDescription.Loadable&lt;S&gt; {
&nbsp;                    private final Class&lt;S&gt; annotationType;
&nbsp;
&nbsp;                    private Loadable(TypePool typePool, Class&lt;S&gt; annotationType, Map&lt;String, AnnotationValue&lt;?, ?&gt;&gt; values) {
&nbsp;                        super(typePool, ForLoadedType.of(annotationType), values, null);
&nbsp;                        this.annotationType = annotationType;
&nbsp;                    }
&nbsp;
&nbsp;                    public S load() {
&nbsp;                        return AnnotationInvocationHandler.of(this.annotationType.getClassLoader(), this.annotationType, this.values);
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Enhance
&nbsp;            protected static class RecordComponentToken {
&nbsp;                private final String name;
&nbsp;                private final String descriptor;
&nbsp;                @Nonnull(
&nbsp;                    when = When.UNKNOWN
&nbsp;                )
&nbsp;                private final String genericSignature;
&nbsp;                private final GenericTypeToken.Resolution.ForRecordComponent signatureResolution;
&nbsp;                private final Map&lt;String, List&lt;AnnotationToken&gt;&gt; typeAnnotationTokens;
&nbsp;                private final List&lt;AnnotationToken&gt; annotationTokens;
&nbsp;
&nbsp;                protected RecordComponentToken(String name, String descriptor, @Nonnull(when = When.MAYBE) String genericSignature, Map&lt;String, List&lt;AnnotationToken&gt;&gt; typeAnnotationTokens, List&lt;AnnotationToken&gt; annotationTokens) {
&nbsp;                    this.name = name;
&nbsp;                    this.descriptor = descriptor;
&nbsp;                    this.genericSignature = genericSignature;
&nbsp;                    this.signatureResolution = (GenericTypeToken.Resolution.ForRecordComponent)(net.bytebuddy.description.type.TypeDescription.AbstractBase.RAW_TYPES ? TypePool.Default.LazyTypeDescription.GenericTypeToken.Resolution.Raw.INSTANCE : TypePool.Default.GenericTypeExtractor.ForSignature.OfRecordComponent.extract(genericSignature));
&nbsp;                    this.typeAnnotationTokens = typeAnnotationTokens;
&nbsp;                    this.annotationTokens = annotationTokens;
&nbsp;                }
&nbsp;
&nbsp;                private RecordComponentDescription.InDefinedShape toRecordComponentDescription(LazyTypeDescription lazyTypeDescription) {
&nbsp;                    return lazyTypeDescription.new LazyRecordComponentDescription(this.name, this.descriptor, this.genericSignature, this.signatureResolution, this.typeAnnotationTokens, this.annotationTokens);
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(Object var1) {
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.name.equals(((RecordComponentToken)var1).name)) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.descriptor.equals(((RecordComponentToken)var1).descriptor)) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.genericSignature.equals(((RecordComponentToken)var1).genericSignature)) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.signatureResolution.equals(((RecordComponentToken)var1).signatureResolution)) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.typeAnnotationTokens.equals(((RecordComponentToken)var1).typeAnnotationTokens)) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.annotationTokens.equals(((RecordComponentToken)var1).annotationTokens);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return (((((this.getClass().hashCode() * 31 + this.name.hashCode()) * 31 + this.descriptor.hashCode()) * 31 + this.genericSignature.hashCode()) * 31 + this.signatureResolution.hashCode()) * 31 + this.typeAnnotationTokens.hashCode()) * 31 + this.annotationTokens.hashCode();
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Enhance
&nbsp;            protected static class MethodToken {
&nbsp;                private final String name;
&nbsp;                private final int modifiers;
&nbsp;                private final String descriptor;
&nbsp;                @Nonnull(
&nbsp;                    when = When.UNKNOWN
&nbsp;                )
&nbsp;                private final String genericSignature;
&nbsp;                private final GenericTypeToken.Resolution.ForMethod signatureResolution;
&nbsp;                @Nonnull(
&nbsp;                    when = When.MAYBE
&nbsp;                )
&nbsp;                private final String[] exceptionName;
&nbsp;                private final Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; typeVariableAnnotationTokens;
&nbsp;                private final Map&lt;Integer, Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt;&gt; typeVariableBoundAnnotationTokens;
&nbsp;                private final Map&lt;String, List&lt;AnnotationToken&gt;&gt; returnTypeAnnotationTokens;
&nbsp;                private final Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; parameterTypeAnnotationTokens;
&nbsp;                private final Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; exceptionTypeAnnotationTokens;
&nbsp;                private final Map&lt;String, List&lt;AnnotationToken&gt;&gt; receiverTypeAnnotationTokens;
&nbsp;                private final List&lt;AnnotationToken&gt; annotationTokens;
&nbsp;                private final Map&lt;Integer, List&lt;AnnotationToken&gt;&gt; parameterAnnotationTokens;
&nbsp;                private final List&lt;ParameterToken&gt; parameterTokens;
&nbsp;                @Nonnull(
&nbsp;                    when = When.UNKNOWN
&nbsp;                )
&nbsp;                private final AnnotationValue&lt;?, ?&gt; defaultValue;
&nbsp;
&nbsp;                protected MethodToken(String name, int modifiers, String descriptor, @Nonnull(when = When.MAYBE) String genericSignature, @Nonnull(when = When.MAYBE) String[] exceptionName, Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; typeVariableAnnotationTokens, Map&lt;Integer, Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt;&gt; typeVariableBoundAnnotationTokens, Map&lt;String, List&lt;AnnotationToken&gt;&gt; returnTypeAnnotationTokens, Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; parameterTypeAnnotationTokens, Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; exceptionTypeAnnotationTokens, Map&lt;String, List&lt;AnnotationToken&gt;&gt; receiverTypeAnnotationTokens, List&lt;AnnotationToken&gt; annotationTokens, Map&lt;Integer, List&lt;AnnotationToken&gt;&gt; parameterAnnotationTokens, List&lt;ParameterToken&gt; parameterTokens, @Nonnull(when = When.MAYBE) AnnotationValue&lt;?, ?&gt; defaultValue) {
&nbsp;                    this.modifiers = modifiers &amp; -131073;
&nbsp;                    this.name = name;
&nbsp;                    this.descriptor = descriptor;
&nbsp;                    this.genericSignature = genericSignature;
&nbsp;                    this.signatureResolution = (GenericTypeToken.Resolution.ForMethod)(net.bytebuddy.description.type.TypeDescription.AbstractBase.RAW_TYPES ? TypePool.Default.LazyTypeDescription.GenericTypeToken.Resolution.Raw.INSTANCE : TypePool.Default.GenericTypeExtractor.ForSignature.OfMethod.extract(genericSignature));
&nbsp;                    this.exceptionName = exceptionName;
&nbsp;                    this.typeVariableAnnotationTokens = typeVariableAnnotationTokens;
&nbsp;                    this.typeVariableBoundAnnotationTokens = typeVariableBoundAnnotationTokens;
&nbsp;                    this.returnTypeAnnotationTokens = returnTypeAnnotationTokens;
&nbsp;                    this.parameterTypeAnnotationTokens = parameterTypeAnnotationTokens;
&nbsp;                    this.exceptionTypeAnnotationTokens = exceptionTypeAnnotationTokens;
&nbsp;                    this.receiverTypeAnnotationTokens = receiverTypeAnnotationTokens;
&nbsp;                    this.annotationTokens = annotationTokens;
&nbsp;                    this.parameterAnnotationTokens = parameterAnnotationTokens;
&nbsp;                    this.parameterTokens = parameterTokens;
&nbsp;                    this.defaultValue = defaultValue;
&nbsp;                }
&nbsp;
&nbsp;                private MethodDescription.InDefinedShape toMethodDescription(LazyTypeDescription lazyTypeDescription) {
&nbsp;                    return lazyTypeDescription.new LazyMethodDescription(this.name, this.modifiers, this.descriptor, this.genericSignature, this.signatureResolution, this.exceptionName, this.typeVariableAnnotationTokens, this.typeVariableBoundAnnotationTokens, this.returnTypeAnnotationTokens, this.parameterTypeAnnotationTokens, this.exceptionTypeAnnotationTokens, this.receiverTypeAnnotationTokens, this.annotationTokens, this.parameterAnnotationTokens, this.parameterTokens, this.defaultValue);
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(Object var1) {
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else if (this.modifiers != ((MethodToken)var1).modifiers) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.name.equals(((MethodToken)var1).name)) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.descriptor.equals(((MethodToken)var1).descriptor)) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.genericSignature.equals(((MethodToken)var1).genericSignature)) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.signatureResolution.equals(((MethodToken)var1).signatureResolution)) {
&nbsp;                        return false;
&nbsp;                    } else if (!Arrays.equals(this.exceptionName, ((MethodToken)var1).exceptionName)) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.typeVariableAnnotationTokens.equals(((MethodToken)var1).typeVariableAnnotationTokens)) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.typeVariableBoundAnnotationTokens.equals(((MethodToken)var1).typeVariableBoundAnnotationTokens)) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.returnTypeAnnotationTokens.equals(((MethodToken)var1).returnTypeAnnotationTokens)) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.parameterTypeAnnotationTokens.equals(((MethodToken)var1).parameterTypeAnnotationTokens)) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.exceptionTypeAnnotationTokens.equals(((MethodToken)var1).exceptionTypeAnnotationTokens)) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.receiverTypeAnnotationTokens.equals(((MethodToken)var1).receiverTypeAnnotationTokens)) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.annotationTokens.equals(((MethodToken)var1).annotationTokens)) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.parameterAnnotationTokens.equals(((MethodToken)var1).parameterAnnotationTokens)) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.parameterTokens.equals(((MethodToken)var1).parameterTokens)) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.defaultValue.equals(((MethodToken)var1).defaultValue);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return (((((((((((((((this.getClass().hashCode() * 31 + this.name.hashCode()) * 31 + this.modifiers) * 31 + this.descriptor.hashCode()) * 31 + this.genericSignature.hashCode()) * 31 + this.signatureResolution.hashCode()) * 31 + Arrays.hashCode(this.exceptionName)) * 31 + this.typeVariableAnnotationTokens.hashCode()) * 31 + this.typeVariableBoundAnnotationTokens.hashCode()) * 31 + this.returnTypeAnnotationTokens.hashCode()) * 31 + this.parameterTypeAnnotationTokens.hashCode()) * 31 + this.exceptionTypeAnnotationTokens.hashCode()) * 31 + this.receiverTypeAnnotationTokens.hashCode()) * 31 + this.annotationTokens.hashCode()) * 31 + this.parameterAnnotationTokens.hashCode()) * 31 + this.parameterTokens.hashCode()) * 31 + this.defaultValue.hashCode();
&nbsp;                }
&nbsp;
&nbsp;                @Enhance
&nbsp;                protected static class ParameterToken {
&nbsp;                    @Nonnull(
&nbsp;                        when = When.NEVER
&nbsp;                    )
&nbsp;                    protected static final String NO_NAME = null;
&nbsp;                    @Nonnull(
&nbsp;                        when = When.NEVER
&nbsp;                    )
&nbsp;                    protected static final Integer NO_MODIFIERS = null;
&nbsp;                    @Nonnull(
&nbsp;                        when = When.MAYBE
&nbsp;                    )
&nbsp;                    @ValueHandling(Sort.REVERSE_NULLABILITY)
&nbsp;                    private final String name;
&nbsp;                    @Nonnull(
&nbsp;                        when = When.MAYBE
&nbsp;                    )
&nbsp;                    @ValueHandling(Sort.REVERSE_NULLABILITY)
&nbsp;                    private final Integer modifiers;
&nbsp;
&nbsp;                    protected ParameterToken() {
&nbsp;                        this(NO_NAME);
&nbsp;                    }
&nbsp;
&nbsp;                    protected ParameterToken(@Nonnull(when = When.MAYBE) String name) {
&nbsp;                        this(name, NO_MODIFIERS);
&nbsp;                    }
&nbsp;
&nbsp;                    protected ParameterToken(@Nonnull(when = When.MAYBE) String name, @Nonnull(when = When.MAYBE) Integer modifiers) {
&nbsp;                        this.name = name;
&nbsp;                        this.modifiers = modifiers;
&nbsp;                    }
&nbsp;
&nbsp;                    @Nonnull(
&nbsp;                        when = When.MAYBE
&nbsp;                    )
&nbsp;                    protected String getName() {
&nbsp;                        return this.name;
&nbsp;                    }
&nbsp;
&nbsp;                    @Nonnull(
&nbsp;                        when = When.MAYBE
&nbsp;                    )
&nbsp;                    protected Integer getModifiers() {
&nbsp;                        return this.modifiers;
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(Object var1) {
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            label42: {
&nbsp;                                Integer var2 = ((ParameterToken)var1).modifiers;
&nbsp;                                Integer var3 = this.modifiers;
&nbsp;                                if (var2 != null) {
&nbsp;                                    if (var3 != null) {
&nbsp;                                        if (!var3.equals(var2)) {
&nbsp;                                            return false;
&nbsp;                                        }
&nbsp;                                        break label42;
&nbsp;                                    }
&nbsp;                                } else if (var3 == null) {
&nbsp;                                    break label42;
&nbsp;                                }
&nbsp;
&nbsp;                                return false;
&nbsp;                            }
&nbsp;
&nbsp;                            String var4 = ((ParameterToken)var1).name;
&nbsp;                            String var5 = this.name;
&nbsp;                            if (var4 != null) {
&nbsp;                                if (var5 == null) {
&nbsp;                                    return false;
&nbsp;                                }
&nbsp;
&nbsp;                                if (!var5.equals(var4)) {
&nbsp;                                    return false;
&nbsp;                                }
&nbsp;                            } else if (var5 != null) {
&nbsp;                                return false;
&nbsp;                            }
&nbsp;
&nbsp;                            return true;
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        int var10000 = this.getClass().hashCode() * 31;
&nbsp;                        String var1 = this.name;
&nbsp;                        if (var1 != null) {
&nbsp;                            var10000 += var1.hashCode();
&nbsp;                        }
&nbsp;
&nbsp;                        var10000 *= 31;
&nbsp;                        Integer var2 = this.modifiers;
&nbsp;                        if (var2 != null) {
&nbsp;                            var10000 += var2.hashCode();
&nbsp;                        }
&nbsp;
&nbsp;                        return var10000;
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Enhance
&nbsp;            protected static class FieldToken {
&nbsp;                private final String name;
&nbsp;                private final int modifiers;
&nbsp;                private final String descriptor;
&nbsp;                @Nonnull(
&nbsp;                    when = When.UNKNOWN
&nbsp;                )
&nbsp;                private final String genericSignature;
&nbsp;                private final GenericTypeToken.Resolution.ForField signatureResolution;
&nbsp;                private final Map&lt;String, List&lt;AnnotationToken&gt;&gt; typeAnnotationTokens;
&nbsp;                private final List&lt;AnnotationToken&gt; annotationTokens;
&nbsp;
&nbsp;                protected FieldToken(String name, int modifiers, String descriptor, @Nonnull(when = When.MAYBE) String genericSignature, Map&lt;String, List&lt;AnnotationToken&gt;&gt; typeAnnotationTokens, List&lt;AnnotationToken&gt; annotationTokens) {
&nbsp;                    this.modifiers = modifiers &amp; -131073;
&nbsp;                    this.name = name;
&nbsp;                    this.descriptor = descriptor;
&nbsp;                    this.genericSignature = genericSignature;
&nbsp;                    this.signatureResolution = (GenericTypeToken.Resolution.ForField)(net.bytebuddy.description.type.TypeDescription.AbstractBase.RAW_TYPES ? TypePool.Default.LazyTypeDescription.GenericTypeToken.Resolution.Raw.INSTANCE : TypePool.Default.GenericTypeExtractor.ForSignature.OfField.extract(genericSignature));
&nbsp;                    this.typeAnnotationTokens = typeAnnotationTokens;
&nbsp;                    this.annotationTokens = annotationTokens;
&nbsp;                }
&nbsp;
&nbsp;                private LazyFieldDescription toFieldDescription(LazyTypeDescription lazyTypeDescription) {
&nbsp;                    return lazyTypeDescription.new LazyFieldDescription(this.name, this.modifiers, this.descriptor, this.genericSignature, this.signatureResolution, this.typeAnnotationTokens, this.annotationTokens);
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(Object var1) {
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else if (this.modifiers != ((FieldToken)var1).modifiers) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.name.equals(((FieldToken)var1).name)) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.descriptor.equals(((FieldToken)var1).descriptor)) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.genericSignature.equals(((FieldToken)var1).genericSignature)) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.signatureResolution.equals(((FieldToken)var1).signatureResolution)) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.typeAnnotationTokens.equals(((FieldToken)var1).typeAnnotationTokens)) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.annotationTokens.equals(((FieldToken)var1).annotationTokens);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return ((((((this.getClass().hashCode() * 31 + this.name.hashCode()) * 31 + this.modifiers) * 31 + this.descriptor.hashCode()) * 31 + this.genericSignature.hashCode()) * 31 + this.signatureResolution.hashCode()) * 31 + this.typeAnnotationTokens.hashCode()) * 31 + this.annotationTokens.hashCode();
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Enhance
&nbsp;            protected static class AnnotationToken {
&nbsp;                private final String descriptor;
&nbsp;                private final Map&lt;String, AnnotationValue&lt;?, ?&gt;&gt; values;
&nbsp;
&nbsp;                protected AnnotationToken(String descriptor, Map&lt;String, AnnotationValue&lt;?, ?&gt;&gt; values) {
&nbsp;                    this.descriptor = descriptor;
&nbsp;                    this.values = values;
&nbsp;                }
&nbsp;
&nbsp;                protected String getBinaryName() {
&nbsp;                    return this.descriptor.substring(1, this.descriptor.length() - 1).replace(&#39;/&#39;, &#39;.&#39;);
&nbsp;                }
&nbsp;
&nbsp;                private Resolution toAnnotationDescription(TypePool typePool) {
&nbsp;                    Resolution resolution = typePool.describe(this.getBinaryName());
&nbsp;                    return (Resolution)(resolution.isResolved() ? new Resolution.Simple(new LazyAnnotationDescription(typePool, resolution.resolve(), this.values)) : new Resolution.Illegal(this.getBinaryName()));
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(Object var1) {
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.descriptor.equals(((AnnotationToken)var1).descriptor)) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.values.equals(((AnnotationToken)var1).values);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return (this.getClass().hashCode() * 31 + this.descriptor.hashCode()) * 31 + this.values.hashCode();
&nbsp;                }
&nbsp;
&nbsp;                protected interface Resolution {
&nbsp;                    boolean isResolved();
&nbsp;
&nbsp;                    AnnotationDescription resolve();
&nbsp;
&nbsp;                    @Enhance
&nbsp;                    public static class Illegal implements Resolution {
&nbsp;                        private final String annotationType;
&nbsp;
&nbsp;                        public Illegal(String annotationType) {
&nbsp;                            this.annotationType = annotationType;
&nbsp;                        }
&nbsp;
&nbsp;                        public boolean isResolved() {
&nbsp;                            return false;
&nbsp;                        }
&nbsp;
&nbsp;                        public AnnotationDescription resolve() {
&nbsp;                            throw new IllegalStateException(&quot;Annotation type is not available: &quot; + this.annotationType);
&nbsp;                        }
&nbsp;
&nbsp;                        public boolean equals(Object var1) {
&nbsp;                            if (this == var1) {
&nbsp;                                return true;
&nbsp;                            } else if (var1 == null) {
&nbsp;                                return false;
&nbsp;                            } else if (this.getClass() != var1.getClass()) {
&nbsp;                                return false;
&nbsp;                            } else {
&nbsp;                                return this.annotationType.equals(((Illegal)var1).annotationType);
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        public int hashCode() {
&nbsp;                            return this.getClass().hashCode() * 31 + this.annotationType.hashCode();
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    @Enhance
&nbsp;                    public static class Simple implements Resolution {
&nbsp;                        private final AnnotationDescription annotationDescription;
&nbsp;
&nbsp;                        protected Simple(AnnotationDescription annotationDescription) {
&nbsp;                            this.annotationDescription = annotationDescription;
&nbsp;                        }
&nbsp;
&nbsp;                        public boolean isResolved() {
&nbsp;                            return true;
&nbsp;                        }
&nbsp;
&nbsp;                        public AnnotationDescription resolve() {
&nbsp;                            return this.annotationDescription;
&nbsp;                        }
&nbsp;
&nbsp;                        public boolean equals(Object var1) {
&nbsp;                            if (this == var1) {
&nbsp;                                return true;
&nbsp;                            } else if (var1 == null) {
&nbsp;                                return false;
&nbsp;                            } else if (this.getClass() != var1.getClass()) {
&nbsp;                                return false;
&nbsp;                            } else {
&nbsp;                                return this.annotationDescription.equals(((Simple)var1).annotationDescription);
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        public int hashCode() {
&nbsp;                            return this.getClass().hashCode() * 31 + this.annotationDescription.hashCode();
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            protected interface GenericTypeToken {
&nbsp;                String EMPTY_TYPE_PATH = &quot;&quot;;
&nbsp;                char COMPONENT_TYPE_PATH = &#39;[&#39;;
&nbsp;                char WILDCARD_TYPE_PATH = &#39;*&#39;;
&nbsp;                char INNER_CLASS_PATH = &#39;.&#39;;
&nbsp;                char INDEXED_TYPE_DELIMITER = &#39;;&#39;;
&nbsp;
&nbsp;                TypeDescription.Generic toGenericType(TypePool var1, TypeVariableSource var2, String var3, Map&lt;String, List&lt;AnnotationToken&gt;&gt; var4);
&nbsp;
&nbsp;                boolean isPrimaryBound(TypePool var1);
&nbsp;
&nbsp;                String getTypePathPrefix();
&nbsp;
&nbsp;                public static class LazyTokenList extends TypeList.Generic.AbstractBase {
&nbsp;                    private final TypePool typePool;
&nbsp;                    private final TypeVariableSource typeVariableSource;
&nbsp;                    private final String typePath;
&nbsp;                    private final Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens;
&nbsp;                    private final List&lt;GenericTypeToken&gt; genericTypeTokens;
&nbsp;
&nbsp;                    protected LazyTokenList(TypePool typePool, TypeVariableSource typeVariableSource, String typePath, Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens, List&lt;GenericTypeToken&gt; genericTypeTokens) {
&nbsp;                        this.typePool = typePool;
&nbsp;                        this.typeVariableSource = typeVariableSource;
&nbsp;                        this.typePath = typePath;
&nbsp;                        this.annotationTokens = annotationTokens;
&nbsp;                        this.genericTypeTokens = genericTypeTokens;
&nbsp;                    }
&nbsp;
&nbsp;                    public TypeDescription.Generic get(int index) {
&nbsp;                        return ((GenericTypeToken)this.genericTypeTokens.get(index)).toGenericType(this.typePool, this.typeVariableSource, this.typePath + index + &#39;;&#39;, this.annotationTokens);
&nbsp;                    }
&nbsp;
&nbsp;                    public int size() {
&nbsp;                        return this.genericTypeTokens.size();
&nbsp;                    }
&nbsp;
&nbsp;                    protected static class ForWildcardBound extends TypeList.Generic.AbstractBase {
&nbsp;                        private final TypePool typePool;
&nbsp;                        private final TypeVariableSource typeVariableSource;
&nbsp;                        private final String typePath;
&nbsp;                        private final Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens;
&nbsp;                        private final GenericTypeToken genericTypeToken;
&nbsp;
&nbsp;                        protected ForWildcardBound(TypePool typePool, TypeVariableSource typeVariableSource, String typePath, Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens, GenericTypeToken genericTypeToken) {
&nbsp;                            this.typePool = typePool;
&nbsp;                            this.typeVariableSource = typeVariableSource;
&nbsp;                            this.typePath = typePath;
&nbsp;                            this.annotationTokens = annotationTokens;
&nbsp;                            this.genericTypeToken = genericTypeToken;
&nbsp;                        }
&nbsp;
&nbsp;                        public TypeDescription.Generic get(int index) {
&nbsp;                            if (index == 0) {
&nbsp;                                return this.genericTypeToken.toGenericType(this.typePool, this.typeVariableSource, this.typePath + &#39;*&#39;, this.annotationTokens);
&nbsp;                            } else {
&nbsp;                                throw new IndexOutOfBoundsException(&quot;index = &quot; + index);
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        public int size() {
&nbsp;                            return 1;
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Enhance
&nbsp;                public static class ForParameterizedType implements GenericTypeToken {
&nbsp;                    private final String name;
&nbsp;                    private final List&lt;GenericTypeToken&gt; parameterTypeTokens;
&nbsp;
&nbsp;                    protected ForParameterizedType(String name, List&lt;GenericTypeToken&gt; parameterTypeTokens) {
&nbsp;                        this.name = name;
&nbsp;                        this.parameterTypeTokens = parameterTypeTokens;
&nbsp;                    }
&nbsp;
&nbsp;                    public TypeDescription.Generic toGenericType(TypePool typePool, TypeVariableSource typeVariableSource, String typePath, Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens) {
&nbsp;                        return new LazyParameterizedType(typePool, typeVariableSource, typePath, annotationTokens, this.name, this.parameterTypeTokens);
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean isPrimaryBound(TypePool typePool) {
&nbsp;                        return !typePool.describe(this.name).resolve().isInterface();
&nbsp;                    }
&nbsp;
&nbsp;                    public String getTypePathPrefix() {
&nbsp;                        return String.valueOf(&#39;.&#39;);
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(Object var1) {
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else if (!this.name.equals(((ForParameterizedType)var1).name)) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return this.parameterTypeTokens.equals(((ForParameterizedType)var1).parameterTypeTokens);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return (this.getClass().hashCode() * 31 + this.name.hashCode()) * 31 + this.parameterTypeTokens.hashCode();
&nbsp;                    }
&nbsp;
&nbsp;                    protected static class LazyParameterizedType extends TypeDescription.Generic.OfParameterizedType {
&nbsp;                        private final TypePool typePool;
&nbsp;                        private final TypeVariableSource typeVariableSource;
&nbsp;                        private final String typePath;
&nbsp;                        private final Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens;
&nbsp;                        private final String name;
&nbsp;                        private final List&lt;GenericTypeToken&gt; parameterTypeTokens;
&nbsp;
&nbsp;                        protected LazyParameterizedType(TypePool typePool, TypeVariableSource typeVariableSource, String typePath, Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens, String name, List&lt;GenericTypeToken&gt; parameterTypeTokens) {
&nbsp;                            this.typePool = typePool;
&nbsp;                            this.typeVariableSource = typeVariableSource;
&nbsp;                            this.typePath = typePath;
&nbsp;                            this.annotationTokens = annotationTokens;
&nbsp;                            this.name = name;
&nbsp;                            this.parameterTypeTokens = parameterTypeTokens;
&nbsp;                        }
&nbsp;
&nbsp;                        public TypeDescription asErasure() {
&nbsp;                            return this.typePool.describe(this.name).resolve();
&nbsp;                        }
&nbsp;
&nbsp;                        public TypeList.Generic getTypeArguments() {
&nbsp;                            return new LazyTokenList(this.typePool, this.typeVariableSource, this.typePath, this.annotationTokens, this.parameterTypeTokens);
&nbsp;                        }
&nbsp;
&nbsp;                        @Nonnull(
&nbsp;                            when = When.MAYBE
&nbsp;                        )
&nbsp;                        public TypeDescription.Generic getOwnerType() {
&nbsp;                            TypeDescription ownerType = this.typePool.describe(this.name).resolve().getEnclosingType();
&nbsp;                            return ownerType == null ? Generic.UNDEFINED : ownerType.asGenericType();
&nbsp;                        }
&nbsp;
&nbsp;                        public AnnotationList getDeclaredAnnotations() {
&nbsp;                            return TypePool.Default.LazyTypeDescription.LazyAnnotationDescription.asListOfNullable(this.typePool, (List)this.annotationTokens.get(this.typePath));
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    @Enhance
&nbsp;                    public static class Nested implements GenericTypeToken {
&nbsp;                        private final String name;
&nbsp;                        private final List&lt;GenericTypeToken&gt; parameterTypeTokens;
&nbsp;                        private final GenericTypeToken ownerTypeToken;
&nbsp;
&nbsp;                        protected Nested(String name, List&lt;GenericTypeToken&gt; parameterTypeTokens, GenericTypeToken ownerTypeToken) {
&nbsp;                            this.name = name;
&nbsp;                            this.parameterTypeTokens = parameterTypeTokens;
&nbsp;                            this.ownerTypeToken = ownerTypeToken;
&nbsp;                        }
&nbsp;
&nbsp;                        public TypeDescription.Generic toGenericType(TypePool typePool, TypeVariableSource typeVariableSource, String typePath, Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens) {
&nbsp;                            return new LazyParameterizedType(typePool, typeVariableSource, typePath, annotationTokens, this.name, this.parameterTypeTokens, this.ownerTypeToken);
&nbsp;                        }
&nbsp;
&nbsp;                        public String getTypePathPrefix() {
&nbsp;                            return this.ownerTypeToken.getTypePathPrefix() + &#39;.&#39;;
&nbsp;                        }
&nbsp;
&nbsp;                        public boolean isPrimaryBound(TypePool typePool) {
&nbsp;                            return !typePool.describe(this.name).resolve().isInterface();
&nbsp;                        }
&nbsp;
&nbsp;                        public boolean equals(Object var1) {
&nbsp;                            if (this == var1) {
&nbsp;                                return true;
&nbsp;                            } else if (var1 == null) {
&nbsp;                                return false;
&nbsp;                            } else if (this.getClass() != var1.getClass()) {
&nbsp;                                return false;
&nbsp;                            } else if (!this.name.equals(((Nested)var1).name)) {
&nbsp;                                return false;
&nbsp;                            } else if (!this.parameterTypeTokens.equals(((Nested)var1).parameterTypeTokens)) {
&nbsp;                                return false;
&nbsp;                            } else {
&nbsp;                                return this.ownerTypeToken.equals(((Nested)var1).ownerTypeToken);
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        public int hashCode() {
&nbsp;                            return ((this.getClass().hashCode() * 31 + this.name.hashCode()) * 31 + this.parameterTypeTokens.hashCode()) * 31 + this.ownerTypeToken.hashCode();
&nbsp;                        }
&nbsp;
&nbsp;                        protected static class LazyParameterizedType extends TypeDescription.Generic.OfParameterizedType {
&nbsp;                            private final TypePool typePool;
&nbsp;                            private final TypeVariableSource typeVariableSource;
&nbsp;                            private final String typePath;
&nbsp;                            private final Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens;
&nbsp;                            private final String name;
&nbsp;                            private final List&lt;GenericTypeToken&gt; parameterTypeTokens;
&nbsp;                            private final GenericTypeToken ownerTypeToken;
&nbsp;
&nbsp;                            protected LazyParameterizedType(TypePool typePool, TypeVariableSource typeVariableSource, String typePath, Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens, String name, List&lt;GenericTypeToken&gt; parameterTypeTokens, GenericTypeToken ownerTypeToken) {
&nbsp;                                this.typePool = typePool;
&nbsp;                                this.typeVariableSource = typeVariableSource;
&nbsp;                                this.typePath = typePath;
&nbsp;                                this.annotationTokens = annotationTokens;
&nbsp;                                this.name = name;
&nbsp;                                this.parameterTypeTokens = parameterTypeTokens;
&nbsp;                                this.ownerTypeToken = ownerTypeToken;
&nbsp;                            }
&nbsp;
&nbsp;                            public TypeDescription asErasure() {
&nbsp;                                return this.typePool.describe(this.name).resolve();
&nbsp;                            }
&nbsp;
&nbsp;                            public TypeList.Generic getTypeArguments() {
&nbsp;                                return new LazyTokenList(this.typePool, this.typeVariableSource, this.typePath + this.ownerTypeToken.getTypePathPrefix(), this.annotationTokens, this.parameterTypeTokens);
&nbsp;                            }
&nbsp;
&nbsp;                            @Nonnull(
&nbsp;                                when = When.MAYBE
&nbsp;                            )
&nbsp;                            public TypeDescription.Generic getOwnerType() {
&nbsp;                                return this.ownerTypeToken.toGenericType(this.typePool, this.typeVariableSource, this.typePath, this.annotationTokens);
&nbsp;                            }
&nbsp;
&nbsp;                            public AnnotationList getDeclaredAnnotations() {
&nbsp;                                return TypePool.Default.LazyTypeDescription.LazyAnnotationDescription.asListOfNullable(this.typePool, (List)this.annotationTokens.get(this.typePath + this.ownerTypeToken.getTypePathPrefix()));
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Enhance
&nbsp;                public static class ForUpperBoundWildcard implements GenericTypeToken {
&nbsp;                    private final GenericTypeToken boundTypeToken;
&nbsp;
&nbsp;                    protected ForUpperBoundWildcard(GenericTypeToken boundTypeToken) {
&nbsp;                        this.boundTypeToken = boundTypeToken;
&nbsp;                    }
&nbsp;
&nbsp;                    public TypeDescription.Generic toGenericType(TypePool typePool, TypeVariableSource typeVariableSource, String typePath, Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens) {
&nbsp;                        return new LazyUpperBoundWildcard(typePool, typeVariableSource, typePath, annotationTokens, this.boundTypeToken);
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean isPrimaryBound(TypePool typePool) {
&nbsp;                        throw new IllegalStateException(&quot;A wildcard type cannot be a type variable bound: &quot; + this);
&nbsp;                    }
&nbsp;
&nbsp;                    public String getTypePathPrefix() {
&nbsp;                        throw new IllegalStateException(&quot;An upper bound wildcard cannot be the owner of a nested type: &quot; + this);
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(Object var1) {
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return this.boundTypeToken.equals(((ForUpperBoundWildcard)var1).boundTypeToken);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return this.getClass().hashCode() * 31 + this.boundTypeToken.hashCode();
&nbsp;                    }
&nbsp;
&nbsp;                    protected static class LazyUpperBoundWildcard extends TypeDescription.Generic.OfWildcardType {
&nbsp;                        private final TypePool typePool;
&nbsp;                        private final TypeVariableSource typeVariableSource;
&nbsp;                        private final String typePath;
&nbsp;                        private final Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens;
&nbsp;                        private final GenericTypeToken boundTypeToken;
&nbsp;
&nbsp;                        protected LazyUpperBoundWildcard(TypePool typePool, TypeVariableSource typeVariableSource, String typePath, Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens, GenericTypeToken boundTypeToken) {
&nbsp;                            this.typePool = typePool;
&nbsp;                            this.typeVariableSource = typeVariableSource;
&nbsp;                            this.typePath = typePath;
&nbsp;                            this.annotationTokens = annotationTokens;
&nbsp;                            this.boundTypeToken = boundTypeToken;
&nbsp;                        }
&nbsp;
&nbsp;                        public TypeList.Generic getUpperBounds() {
&nbsp;                            return new LazyTokenList.ForWildcardBound(this.typePool, this.typeVariableSource, this.typePath, this.annotationTokens, this.boundTypeToken);
&nbsp;                        }
&nbsp;
&nbsp;                        public TypeList.Generic getLowerBounds() {
&nbsp;                            return new TypeList.Generic.Empty();
&nbsp;                        }
&nbsp;
&nbsp;                        public AnnotationList getDeclaredAnnotations() {
&nbsp;                            return TypePool.Default.LazyTypeDescription.LazyAnnotationDescription.asListOfNullable(this.typePool, (List)this.annotationTokens.get(this.typePath));
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Enhance
&nbsp;                public static class ForLowerBoundWildcard implements GenericTypeToken {
&nbsp;                    private final GenericTypeToken boundTypeToken;
&nbsp;
&nbsp;                    protected ForLowerBoundWildcard(GenericTypeToken boundTypeToken) {
&nbsp;                        this.boundTypeToken = boundTypeToken;
&nbsp;                    }
&nbsp;
&nbsp;                    public TypeDescription.Generic toGenericType(TypePool typePool, TypeVariableSource typeVariableSource, String typePath, Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens) {
&nbsp;                        return new LazyLowerBoundWildcard(typePool, typeVariableSource, typePath, annotationTokens, this.boundTypeToken);
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean isPrimaryBound(TypePool typePool) {
&nbsp;                        throw new IllegalStateException(&quot;A wildcard type cannot be a type variable bound: &quot; + this);
&nbsp;                    }
&nbsp;
&nbsp;                    public String getTypePathPrefix() {
&nbsp;                        throw new IllegalStateException(&quot;A lower bound wildcard cannot be the owner of a nested type: &quot; + this);
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(Object var1) {
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return this.boundTypeToken.equals(((ForLowerBoundWildcard)var1).boundTypeToken);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return this.getClass().hashCode() * 31 + this.boundTypeToken.hashCode();
&nbsp;                    }
&nbsp;
&nbsp;                    protected static class LazyLowerBoundWildcard extends TypeDescription.Generic.OfWildcardType {
&nbsp;                        private final TypePool typePool;
&nbsp;                        private final TypeVariableSource typeVariableSource;
&nbsp;                        private final String typePath;
&nbsp;                        private final Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens;
&nbsp;                        private final GenericTypeToken boundTypeToken;
&nbsp;
&nbsp;                        protected LazyLowerBoundWildcard(TypePool typePool, TypeVariableSource typeVariableSource, String typePath, Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens, GenericTypeToken boundTypeToken) {
&nbsp;                            this.typePool = typePool;
&nbsp;                            this.typeVariableSource = typeVariableSource;
&nbsp;                            this.typePath = typePath;
&nbsp;                            this.annotationTokens = annotationTokens;
&nbsp;                            this.boundTypeToken = boundTypeToken;
&nbsp;                        }
&nbsp;
&nbsp;                        public TypeList.Generic getUpperBounds() {
&nbsp;                            return new TypeList.Generic.Explicit(new TypeDefinition[]{Generic.OBJECT});
&nbsp;                        }
&nbsp;
&nbsp;                        public TypeList.Generic getLowerBounds() {
&nbsp;                            return new LazyTokenList.ForWildcardBound(this.typePool, this.typeVariableSource, this.typePath, this.annotationTokens, this.boundTypeToken);
&nbsp;                        }
&nbsp;
&nbsp;                        public AnnotationList getDeclaredAnnotations() {
&nbsp;                            return TypePool.Default.LazyTypeDescription.LazyAnnotationDescription.asListOfNullable(this.typePool, (List)this.annotationTokens.get(this.typePath));
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Enhance
&nbsp;                public static class ForGenericArray implements GenericTypeToken {
&nbsp;                    private final GenericTypeToken componentTypeToken;
&nbsp;
&nbsp;                    protected ForGenericArray(GenericTypeToken componentTypeToken) {
&nbsp;                        this.componentTypeToken = componentTypeToken;
&nbsp;                    }
&nbsp;
&nbsp;                    public TypeDescription.Generic toGenericType(TypePool typePool, TypeVariableSource typeVariableSource, String typePath, Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens) {
&nbsp;                        return new LazyGenericArray(typePool, typeVariableSource, typePath, annotationTokens, this.componentTypeToken);
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean isPrimaryBound(TypePool typePool) {
&nbsp;                        throw new IllegalStateException(&quot;A generic array type cannot be a type variable bound: &quot; + this);
&nbsp;                    }
&nbsp;
&nbsp;                    public String getTypePathPrefix() {
&nbsp;                        throw new IllegalStateException(&quot;A generic array type cannot be the owner of a nested type: &quot; + this);
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(Object var1) {
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return this.componentTypeToken.equals(((ForGenericArray)var1).componentTypeToken);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return this.getClass().hashCode() * 31 + this.componentTypeToken.hashCode();
&nbsp;                    }
&nbsp;
&nbsp;                    protected static class LazyGenericArray extends TypeDescription.Generic.OfGenericArray {
&nbsp;                        private final TypePool typePool;
&nbsp;                        private final TypeVariableSource typeVariableSource;
&nbsp;                        private final String typePath;
&nbsp;                        private final Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens;
&nbsp;                        private final GenericTypeToken componentTypeToken;
&nbsp;
&nbsp;                        protected LazyGenericArray(TypePool typePool, TypeVariableSource typeVariableSource, String typePath, Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens, GenericTypeToken componentTypeToken) {
&nbsp;                            this.typePool = typePool;
&nbsp;                            this.typeVariableSource = typeVariableSource;
&nbsp;                            this.typePath = typePath;
&nbsp;                            this.annotationTokens = annotationTokens;
&nbsp;                            this.componentTypeToken = componentTypeToken;
&nbsp;                        }
&nbsp;
&nbsp;                        public TypeDescription.Generic getComponentType() {
&nbsp;                            return this.componentTypeToken.toGenericType(this.typePool, this.typeVariableSource, this.typePath + &#39;[&#39;, this.annotationTokens);
&nbsp;                        }
&nbsp;
&nbsp;                        public AnnotationList getDeclaredAnnotations() {
&nbsp;                            return TypePool.Default.LazyTypeDescription.LazyAnnotationDescription.asListOfNullable(this.typePool, (List)this.annotationTokens.get(this.typePath));
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Enhance
&nbsp;                public static class ForTypeVariable implements GenericTypeToken {
&nbsp;                    private final String symbol;
&nbsp;
&nbsp;                    protected ForTypeVariable(String symbol) {
&nbsp;                        this.symbol = symbol;
&nbsp;                    }
&nbsp;
&nbsp;                    public TypeDescription.Generic toGenericType(TypePool typePool, TypeVariableSource typeVariableSource, String typePath, Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens) {
&nbsp;                        TypeDescription.Generic typeVariable = typeVariableSource.findVariable(this.symbol);
&nbsp;                        return (TypeDescription.Generic)(typeVariable == null ? new UnresolvedTypeVariable(typeVariableSource, typePool, this.symbol, (List)annotationTokens.get(typePath)) : new AnnotatedTypeVariable(typePool, (List)annotationTokens.get(typePath), typeVariable));
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean isPrimaryBound(TypePool typePool) {
&nbsp;                        return true;
&nbsp;                    }
&nbsp;
&nbsp;                    public String getTypePathPrefix() {
&nbsp;                        throw new IllegalStateException(&quot;A type variable cannot be the owner of a nested type: &quot; + this);
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(Object var1) {
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return this.symbol.equals(((ForTypeVariable)var1).symbol);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return this.getClass().hashCode() * 31 + this.symbol.hashCode();
&nbsp;                    }
&nbsp;
&nbsp;                    @Enhance
&nbsp;                    protected static class Formal implements OfFormalTypeVariable {
&nbsp;                        private final String symbol;
&nbsp;                        private final List&lt;GenericTypeToken&gt; boundTypeTokens;
&nbsp;
&nbsp;                        protected Formal(String symbol, List&lt;GenericTypeToken&gt; boundTypeTokens) {
&nbsp;                            this.symbol = symbol;
&nbsp;                            this.boundTypeTokens = boundTypeTokens;
&nbsp;                        }
&nbsp;
&nbsp;                        public TypeDescription.Generic toGenericType(TypePool typePool, TypeVariableSource typeVariableSource, @Nonnull(when = When.MAYBE) Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens, @Nonnull(when = When.MAYBE) Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; boundaryAnnotationTokens) {
&nbsp;                            return new LazyTypeVariable(typePool, typeVariableSource, annotationTokens == null ? Collections.emptyMap() : annotationTokens, boundaryAnnotationTokens == null ? Collections.emptyMap() : boundaryAnnotationTokens, this.symbol, this.boundTypeTokens);
&nbsp;                        }
&nbsp;
&nbsp;                        public boolean equals(Object var1) {
&nbsp;                            if (this == var1) {
&nbsp;                                return true;
&nbsp;                            } else if (var1 == null) {
&nbsp;                                return false;
&nbsp;                            } else if (this.getClass() != var1.getClass()) {
&nbsp;                                return false;
&nbsp;                            } else if (!this.symbol.equals(((Formal)var1).symbol)) {
&nbsp;                                return false;
&nbsp;                            } else {
&nbsp;                                return this.boundTypeTokens.equals(((Formal)var1).boundTypeTokens);
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        public int hashCode() {
&nbsp;                            return (this.getClass().hashCode() * 31 + this.symbol.hashCode()) * 31 + this.boundTypeTokens.hashCode();
&nbsp;                        }
&nbsp;
&nbsp;                        protected static class LazyTypeVariable extends TypeDescription.Generic.OfTypeVariable {
&nbsp;                            private final TypePool typePool;
&nbsp;                            private final TypeVariableSource typeVariableSource;
&nbsp;                            private final Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens;
&nbsp;                            private final Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; boundaryAnnotationTokens;
&nbsp;                            private final String symbol;
&nbsp;                            private final List&lt;GenericTypeToken&gt; boundTypeTokens;
&nbsp;
&nbsp;                            protected LazyTypeVariable(TypePool typePool, TypeVariableSource typeVariableSource, Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens, Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; boundaryAnnotationTokens, String symbol, List&lt;GenericTypeToken&gt; boundTypeTokens) {
&nbsp;                                this.typePool = typePool;
&nbsp;                                this.typeVariableSource = typeVariableSource;
&nbsp;                                this.annotationTokens = annotationTokens;
&nbsp;                                this.boundaryAnnotationTokens = boundaryAnnotationTokens;
&nbsp;                                this.symbol = symbol;
&nbsp;                                this.boundTypeTokens = boundTypeTokens;
&nbsp;                            }
&nbsp;
&nbsp;                            public TypeList.Generic getUpperBounds() {
&nbsp;                                return new LazyBoundTokenList(this.typePool, this.typeVariableSource, this.boundaryAnnotationTokens, this.boundTypeTokens);
&nbsp;                            }
&nbsp;
&nbsp;                            public TypeVariableSource getTypeVariableSource() {
&nbsp;                                return this.typeVariableSource;
&nbsp;                            }
&nbsp;
&nbsp;                            public String getSymbol() {
&nbsp;                                return this.symbol;
&nbsp;                            }
&nbsp;
&nbsp;                            public AnnotationList getDeclaredAnnotations() {
&nbsp;                                return TypePool.Default.LazyTypeDescription.LazyAnnotationDescription.asListOfNullable(this.typePool, (List)this.annotationTokens.get(&quot;&quot;));
&nbsp;                            }
&nbsp;
&nbsp;                            protected static class LazyBoundTokenList extends TypeList.Generic.AbstractBase {
&nbsp;                                private final TypePool typePool;
&nbsp;                                private final TypeVariableSource typeVariableSource;
&nbsp;                                private final Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens;
&nbsp;                                private final List&lt;GenericTypeToken&gt; boundTypeTokens;
&nbsp;
&nbsp;                                protected LazyBoundTokenList(TypePool typePool, TypeVariableSource typeVariableSource, Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens, List&lt;GenericTypeToken&gt; boundTypeTokens) {
&nbsp;                                    this.typePool = typePool;
&nbsp;                                    this.typeVariableSource = typeVariableSource;
&nbsp;                                    this.annotationTokens = annotationTokens;
&nbsp;                                    this.boundTypeTokens = boundTypeTokens;
&nbsp;                                }
&nbsp;
&nbsp;                                public TypeDescription.Generic get(int index) {
&nbsp;                                    Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens = !this.annotationTokens.containsKey(index) &amp;&amp; !this.annotationTokens.containsKey(index + 1) ? Collections.emptyMap() : (Map)this.annotationTokens.get(index + (((GenericTypeToken)this.boundTypeTokens.get(0)).isPrimaryBound(this.typePool) ? 0 : 1));
&nbsp;                                    return ((GenericTypeToken)this.boundTypeTokens.get(index)).toGenericType(this.typePool, this.typeVariableSource, &quot;&quot;, annotationTokens == null ? Collections.emptyMap() : annotationTokens);
&nbsp;                                }
&nbsp;
&nbsp;                                public int size() {
&nbsp;                                    return this.boundTypeTokens.size();
&nbsp;                                }
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    protected static class UnresolvedTypeVariable extends TypeDescription.Generic.OfTypeVariable {
&nbsp;                        private final TypeVariableSource typeVariableSource;
&nbsp;                        private final TypePool typePool;
&nbsp;                        private final String symbol;
&nbsp;                        private final List&lt;AnnotationToken&gt; annotationTokens;
&nbsp;
&nbsp;                        protected UnresolvedTypeVariable(TypeVariableSource typeVariableSource, TypePool typePool, String symbol, List&lt;AnnotationToken&gt; annotationTokens) {
&nbsp;                            this.typeVariableSource = typeVariableSource;
&nbsp;                            this.typePool = typePool;
&nbsp;                            this.symbol = symbol;
&nbsp;                            this.annotationTokens = annotationTokens;
&nbsp;                        }
&nbsp;
&nbsp;                        public TypeList.Generic getUpperBounds() {
&nbsp;                            throw new IllegalStateException(&quot;Cannot resolve bounds of unresolved type variable &quot; + this + &quot; by &quot; + this.typeVariableSource);
&nbsp;                        }
&nbsp;
&nbsp;                        public TypeVariableSource getTypeVariableSource() {
&nbsp;                            return this.typeVariableSource;
&nbsp;                        }
&nbsp;
&nbsp;                        public String getSymbol() {
&nbsp;                            return this.symbol;
&nbsp;                        }
&nbsp;
&nbsp;                        public AnnotationList getDeclaredAnnotations() {
&nbsp;                            return TypePool.Default.LazyTypeDescription.LazyAnnotationDescription.asListOfNullable(this.typePool, this.annotationTokens);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    protected static class AnnotatedTypeVariable extends TypeDescription.Generic.OfTypeVariable {
&nbsp;                        private final TypePool typePool;
&nbsp;                        private final List&lt;AnnotationToken&gt; annotationTokens;
&nbsp;                        private final TypeDescription.Generic typeVariable;
&nbsp;
&nbsp;                        protected AnnotatedTypeVariable(TypePool typePool, List&lt;AnnotationToken&gt; annotationTokens, TypeDescription.Generic typeVariable) {
&nbsp;                            this.typePool = typePool;
&nbsp;                            this.annotationTokens = annotationTokens;
&nbsp;                            this.typeVariable = typeVariable;
&nbsp;                        }
&nbsp;
&nbsp;                        public TypeList.Generic getUpperBounds() {
&nbsp;                            return this.typeVariable.getUpperBounds();
&nbsp;                        }
&nbsp;
&nbsp;                        public TypeVariableSource getTypeVariableSource() {
&nbsp;                            return this.typeVariable.getTypeVariableSource();
&nbsp;                        }
&nbsp;
&nbsp;                        public String getSymbol() {
&nbsp;                            return this.typeVariable.getSymbol();
&nbsp;                        }
&nbsp;
&nbsp;                        public AnnotationList getDeclaredAnnotations() {
&nbsp;                            return TypePool.Default.LazyTypeDescription.LazyAnnotationDescription.asListOfNullable(this.typePool, this.annotationTokens);
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Enhance
&nbsp;                public static class ForRawType implements GenericTypeToken {
&nbsp;                    private final String name;
&nbsp;
&nbsp;                    protected ForRawType(String name) {
&nbsp;                        this.name = name;
&nbsp;                    }
&nbsp;
&nbsp;                    public TypeDescription.Generic toGenericType(TypePool typePool, TypeVariableSource typeVariableSource, String typePath, Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens) {
&nbsp;                        return new Resolution.Raw.RawAnnotatedType(typePool, typePath, annotationTokens, typePool.describe(this.name).resolve());
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean isPrimaryBound(TypePool typePool) {
&nbsp;                        return !typePool.describe(this.name).resolve().isInterface();
&nbsp;                    }
&nbsp;
&nbsp;                    public String getTypePathPrefix() {
&nbsp;                        throw new IllegalStateException(&quot;A non-generic type cannot be the owner of a nested type: &quot; + this);
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(Object var1) {
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return this.name.equals(((ForRawType)var1).name);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return this.getClass().hashCode() * 31 + this.name.hashCode();
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public interface Resolution {
&nbsp;                    TypeList.Generic resolveTypeVariables(TypePool var1, TypeVariableSource var2, Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; var3, Map&lt;Integer, Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt;&gt; var4);
&nbsp;
&nbsp;                    public interface ForRecordComponent {
&nbsp;                        TypeDescription.Generic resolveRecordType(String var1, TypePool var2, Map&lt;String, List&lt;AnnotationToken&gt;&gt; var3, RecordComponentDescription.InDefinedShape var4);
&nbsp;
&nbsp;                        @Enhance
&nbsp;                        public static class Tokenized implements ForRecordComponent {
&nbsp;                            private final GenericTypeToken recordComponentTypeToken;
&nbsp;
&nbsp;                            protected Tokenized(GenericTypeToken recordComponentTypeToken) {
&nbsp;                                this.recordComponentTypeToken = recordComponentTypeToken;
&nbsp;                            }
&nbsp;
&nbsp;                            public TypeDescription.Generic resolveRecordType(String recordTypeDescriptor, TypePool typePool, Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens, RecordComponentDescription.InDefinedShape definingRecordComponent) {
&nbsp;                                return TypePool.Default.LazyTypeDescription.TokenizedGenericType.of(typePool, this.recordComponentTypeToken, recordTypeDescriptor, annotationTokens, definingRecordComponent.getDeclaringType());
&nbsp;                            }
&nbsp;
&nbsp;                            public boolean equals(Object var1) {
&nbsp;                                if (this == var1) {
&nbsp;                                    return true;
&nbsp;                                } else if (var1 == null) {
&nbsp;                                    return false;
&nbsp;                                } else if (this.getClass() != var1.getClass()) {
&nbsp;                                    return false;
&nbsp;                                } else {
&nbsp;                                    return this.recordComponentTypeToken.equals(((Tokenized)var1).recordComponentTypeToken);
&nbsp;                                }
&nbsp;                            }
&nbsp;
&nbsp;                            public int hashCode() {
&nbsp;                                return this.getClass().hashCode() * 31 + this.recordComponentTypeToken.hashCode();
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public interface ForMethod extends Resolution {
&nbsp;                        TypeDescription.Generic resolveReturnType(String var1, TypePool var2, Map&lt;String, List&lt;AnnotationToken&gt;&gt; var3, MethodDescription.InDefinedShape var4);
&nbsp;
&nbsp;                        TypeList.Generic resolveParameterTypes(List&lt;String&gt; var1, TypePool var2, Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; var3, MethodDescription.InDefinedShape var4);
&nbsp;
&nbsp;                        TypeList.Generic resolveExceptionTypes(List&lt;String&gt; var1, TypePool var2, Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; var3, MethodDescription.InDefinedShape var4);
&nbsp;
&nbsp;                        @Enhance
&nbsp;                        public static class Tokenized implements ForMethod {
&nbsp;                            private final GenericTypeToken returnTypeToken;
&nbsp;                            private final List&lt;GenericTypeToken&gt; parameterTypeTokens;
&nbsp;                            private final List&lt;GenericTypeToken&gt; exceptionTypeTokens;
&nbsp;                            private final List&lt;OfFormalTypeVariable&gt; typeVariableTokens;
&nbsp;
&nbsp;                            protected Tokenized(GenericTypeToken returnTypeToken, List&lt;GenericTypeToken&gt; parameterTypeTokens, List&lt;GenericTypeToken&gt; exceptionTypeTokens, List&lt;OfFormalTypeVariable&gt; typeVariableTokens) {
&nbsp;                                this.returnTypeToken = returnTypeToken;
&nbsp;                                this.parameterTypeTokens = parameterTypeTokens;
&nbsp;                                this.exceptionTypeTokens = exceptionTypeTokens;
&nbsp;                                this.typeVariableTokens = typeVariableTokens;
&nbsp;                            }
&nbsp;
&nbsp;                            public TypeDescription.Generic resolveReturnType(String returnTypeDescriptor, TypePool typePool, Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens, MethodDescription.InDefinedShape definingMethod) {
&nbsp;                                return TypePool.Default.LazyTypeDescription.TokenizedGenericType.of(typePool, this.returnTypeToken, returnTypeDescriptor, annotationTokens, definingMethod);
&nbsp;                            }
&nbsp;
&nbsp;                            public TypeList.Generic resolveParameterTypes(List&lt;String&gt; parameterTypeDescriptors, TypePool typePool, Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens, MethodDescription.InDefinedShape definingMethod) {
&nbsp;                                return new TokenizedGenericType.TokenList(typePool, this.parameterTypeTokens, annotationTokens, parameterTypeDescriptors, definingMethod);
&nbsp;                            }
&nbsp;
&nbsp;                            public TypeList.Generic resolveExceptionTypes(List&lt;String&gt; exceptionTypeDescriptors, TypePool typePool, Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens, MethodDescription.InDefinedShape definingMethod) {
&nbsp;                                return (TypeList.Generic)(this.exceptionTypeTokens.isEmpty() ? TypePool.Default.LazyTypeDescription.GenericTypeToken.Resolution.Raw.INSTANCE.resolveExceptionTypes(exceptionTypeDescriptors, typePool, annotationTokens, definingMethod) : new TokenizedGenericType.TokenList(typePool, this.exceptionTypeTokens, annotationTokens, exceptionTypeDescriptors, definingMethod));
&nbsp;                            }
&nbsp;
&nbsp;                            public TypeList.Generic resolveTypeVariables(TypePool typePool, TypeVariableSource typeVariableSource, Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens, Map&lt;Integer, Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt;&gt; boundAnnotationTokens) {
&nbsp;                                return new TokenizedGenericType.TypeVariableList(typePool, this.typeVariableTokens, typeVariableSource, annotationTokens, boundAnnotationTokens);
&nbsp;                            }
&nbsp;
&nbsp;                            public boolean equals(Object var1) {
&nbsp;                                if (this == var1) {
&nbsp;                                    return true;
&nbsp;                                } else if (var1 == null) {
&nbsp;                                    return false;
&nbsp;                                } else if (this.getClass() != var1.getClass()) {
&nbsp;                                    return false;
&nbsp;                                } else if (!this.returnTypeToken.equals(((Tokenized)var1).returnTypeToken)) {
&nbsp;                                    return false;
&nbsp;                                } else if (!this.parameterTypeTokens.equals(((Tokenized)var1).parameterTypeTokens)) {
&nbsp;                                    return false;
&nbsp;                                } else if (!this.exceptionTypeTokens.equals(((Tokenized)var1).exceptionTypeTokens)) {
&nbsp;                                    return false;
&nbsp;                                } else {
&nbsp;                                    return this.typeVariableTokens.equals(((Tokenized)var1).typeVariableTokens);
&nbsp;                                }
&nbsp;                            }
&nbsp;
&nbsp;                            public int hashCode() {
&nbsp;                                return (((this.getClass().hashCode() * 31 + this.returnTypeToken.hashCode()) * 31 + this.parameterTypeTokens.hashCode()) * 31 + this.exceptionTypeTokens.hashCode()) * 31 + this.typeVariableTokens.hashCode();
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public interface ForField {
&nbsp;                        TypeDescription.Generic resolveFieldType(String var1, TypePool var2, Map&lt;String, List&lt;AnnotationToken&gt;&gt; var3, FieldDescription.InDefinedShape var4);
&nbsp;
&nbsp;                        @Enhance
&nbsp;                        public static class Tokenized implements ForField {
&nbsp;                            private final GenericTypeToken fieldTypeToken;
&nbsp;
&nbsp;                            protected Tokenized(GenericTypeToken fieldTypeToken) {
&nbsp;                                this.fieldTypeToken = fieldTypeToken;
&nbsp;                            }
&nbsp;
&nbsp;                            public TypeDescription.Generic resolveFieldType(String fieldTypeDescriptor, TypePool typePool, Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens, FieldDescription.InDefinedShape definingField) {
&nbsp;                                return TypePool.Default.LazyTypeDescription.TokenizedGenericType.of(typePool, this.fieldTypeToken, fieldTypeDescriptor, annotationTokens, definingField.getDeclaringType());
&nbsp;                            }
&nbsp;
&nbsp;                            public boolean equals(Object var1) {
&nbsp;                                if (this == var1) {
&nbsp;                                    return true;
&nbsp;                                } else if (var1 == null) {
&nbsp;                                    return false;
&nbsp;                                } else if (this.getClass() != var1.getClass()) {
&nbsp;                                    return false;
&nbsp;                                } else {
&nbsp;                                    return this.fieldTypeToken.equals(((Tokenized)var1).fieldTypeToken);
&nbsp;                                }
&nbsp;                            }
&nbsp;
&nbsp;                            public int hashCode() {
&nbsp;                                return this.getClass().hashCode() * 31 + this.fieldTypeToken.hashCode();
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public interface ForType extends Resolution {
&nbsp;                        TypeDescription.Generic resolveSuperClass(String var1, TypePool var2, Map&lt;String, List&lt;AnnotationToken&gt;&gt; var3, TypeDescription var4);
&nbsp;
&nbsp;                        TypeList.Generic resolveInterfaceTypes(List&lt;String&gt; var1, TypePool var2, Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; var3, TypeDescription var4);
&nbsp;
&nbsp;                        @Enhance
&nbsp;                        public static class Tokenized implements ForType {
&nbsp;                            private final GenericTypeToken superClassToken;
&nbsp;                            private final List&lt;GenericTypeToken&gt; interfaceTypeTokens;
&nbsp;                            private final List&lt;OfFormalTypeVariable&gt; typeVariableTokens;
&nbsp;
&nbsp;                            protected Tokenized(GenericTypeToken superClassToken, List&lt;GenericTypeToken&gt; interfaceTypeTokens, List&lt;OfFormalTypeVariable&gt; typeVariableTokens) {
&nbsp;                                this.superClassToken = superClassToken;
&nbsp;                                this.interfaceTypeTokens = interfaceTypeTokens;
&nbsp;                                this.typeVariableTokens = typeVariableTokens;
&nbsp;                            }
&nbsp;
&nbsp;                            public TypeDescription.Generic resolveSuperClass(String superClassDescriptor, TypePool typePool, Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens, TypeDescription definingType) {
&nbsp;                                return TypePool.Default.LazyTypeDescription.TokenizedGenericType.of(typePool, this.superClassToken, superClassDescriptor, annotationTokens, definingType);
&nbsp;                            }
&nbsp;
&nbsp;                            public TypeList.Generic resolveInterfaceTypes(List&lt;String&gt; interfaceTypeDescriptors, TypePool typePool, Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens, TypeDescription definingType) {
&nbsp;                                return new TokenizedGenericType.TokenList(typePool, this.interfaceTypeTokens, annotationTokens, interfaceTypeDescriptors, definingType);
&nbsp;                            }
&nbsp;
&nbsp;                            public TypeList.Generic resolveTypeVariables(TypePool typePool, TypeVariableSource typeVariableSource, Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens, Map&lt;Integer, Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt;&gt; boundAnnotationTokens) {
&nbsp;                                return new TokenizedGenericType.TypeVariableList(typePool, this.typeVariableTokens, typeVariableSource, annotationTokens, boundAnnotationTokens);
&nbsp;                            }
&nbsp;
&nbsp;                            public boolean equals(Object var1) {
&nbsp;                                if (this == var1) {
&nbsp;                                    return true;
&nbsp;                                } else if (var1 == null) {
&nbsp;                                    return false;
&nbsp;                                } else if (this.getClass() != var1.getClass()) {
&nbsp;                                    return false;
&nbsp;                                } else if (!this.superClassToken.equals(((Tokenized)var1).superClassToken)) {
&nbsp;                                    return false;
&nbsp;                                } else if (!this.interfaceTypeTokens.equals(((Tokenized)var1).interfaceTypeTokens)) {
&nbsp;                                    return false;
&nbsp;                                } else {
&nbsp;                                    return this.typeVariableTokens.equals(((Tokenized)var1).typeVariableTokens);
&nbsp;                                }
&nbsp;                            }
&nbsp;
&nbsp;                            public int hashCode() {
&nbsp;                                return ((this.getClass().hashCode() * 31 + this.superClassToken.hashCode()) * 31 + this.interfaceTypeTokens.hashCode()) * 31 + this.typeVariableTokens.hashCode();
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public static enum Malformed implements ForType, ForField, ForMethod, ForRecordComponent {
&nbsp;                        INSTANCE;
&nbsp;
&nbsp;                        private Malformed() {
&nbsp;                        }
&nbsp;
&nbsp;                        public TypeDescription.Generic resolveSuperClass(String superClassDescriptor, TypePool typePool, Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens, TypeDescription definingType) {
&nbsp;                            return new TokenizedGenericType.Malformed(typePool, superClassDescriptor);
&nbsp;                        }
&nbsp;
&nbsp;                        public TypeList.Generic resolveInterfaceTypes(List&lt;String&gt; interfaceTypeDescriptors, TypePool typePool, Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens, TypeDescription definingType) {
&nbsp;                            return new TokenizedGenericType.Malformed.TokenList(typePool, interfaceTypeDescriptors);
&nbsp;                        }
&nbsp;
&nbsp;                        public TypeList.Generic resolveTypeVariables(TypePool typePool, TypeVariableSource typeVariableSource, Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens, Map&lt;Integer, Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt;&gt; boundAnnotationTokens) {
&nbsp;                            throw new GenericSignatureFormatError();
&nbsp;                        }
&nbsp;
&nbsp;                        public TypeDescription.Generic resolveFieldType(String fieldTypeDescriptor, TypePool typePool, Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens, FieldDescription.InDefinedShape definingField) {
&nbsp;                            return new TokenizedGenericType.Malformed(typePool, fieldTypeDescriptor);
&nbsp;                        }
&nbsp;
&nbsp;                        public TypeDescription.Generic resolveReturnType(String returnTypeDescriptor, TypePool typePool, Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens, MethodDescription.InDefinedShape definingMethod) {
&nbsp;                            return new TokenizedGenericType.Malformed(typePool, returnTypeDescriptor);
&nbsp;                        }
&nbsp;
&nbsp;                        public TypeList.Generic resolveParameterTypes(List&lt;String&gt; parameterTypeDescriptors, TypePool typePool, Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens, MethodDescription.InDefinedShape definingMethod) {
&nbsp;                            return new TokenizedGenericType.Malformed.TokenList(typePool, parameterTypeDescriptors);
&nbsp;                        }
&nbsp;
&nbsp;                        public TypeList.Generic resolveExceptionTypes(List&lt;String&gt; exceptionTypeDescriptors, TypePool typePool, Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens, MethodDescription.InDefinedShape definingMethod) {
&nbsp;                            return new TokenizedGenericType.Malformed.TokenList(typePool, exceptionTypeDescriptors);
&nbsp;                        }
&nbsp;
&nbsp;                        public TypeDescription.Generic resolveRecordType(String recordTypeDescriptor, TypePool typePool, Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens, RecordComponentDescription.InDefinedShape definingRecordComponent) {
&nbsp;                            return new TokenizedGenericType.Malformed(typePool, recordTypeDescriptor);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public static enum Raw implements ForType, ForField, ForMethod, ForRecordComponent {
&nbsp;                        INSTANCE;
&nbsp;
&nbsp;                        private Raw() {
&nbsp;                        }
&nbsp;
&nbsp;                        public TypeDescription.Generic resolveSuperClass(String superClassDescriptor, TypePool typePool, Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens, TypeDescription definingType) {
&nbsp;                            return TypePool.Default.LazyTypeDescription.GenericTypeToken.Resolution.Raw.RawAnnotatedType.of(typePool, annotationTokens, superClassDescriptor);
&nbsp;                        }
&nbsp;
&nbsp;                        public TypeList.Generic resolveInterfaceTypes(List&lt;String&gt; interfaceTypeDescriptors, TypePool typePool, Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens, TypeDescription definingType) {
&nbsp;                            return TypePool.Default.LazyTypeDescription.GenericTypeToken.Resolution.Raw.RawAnnotatedType.LazyRawAnnotatedTypeList.of(typePool, annotationTokens, interfaceTypeDescriptors);
&nbsp;                        }
&nbsp;
&nbsp;                        public TypeList.Generic resolveTypeVariables(TypePool typePool, TypeVariableSource typeVariableSource, Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens, Map&lt;Integer, Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt;&gt; boundAnnotationTokens) {
&nbsp;                            return new TypeList.Generic.Empty();
&nbsp;                        }
&nbsp;
&nbsp;                        public TypeDescription.Generic resolveFieldType(String fieldTypeDescriptor, TypePool typePool, Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens, FieldDescription.InDefinedShape definingField) {
&nbsp;                            return TypePool.Default.LazyTypeDescription.GenericTypeToken.Resolution.Raw.RawAnnotatedType.of(typePool, annotationTokens, fieldTypeDescriptor);
&nbsp;                        }
&nbsp;
&nbsp;                        public TypeDescription.Generic resolveReturnType(String returnTypeDescriptor, TypePool typePool, Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens, MethodDescription.InDefinedShape definingMethod) {
&nbsp;                            return TypePool.Default.LazyTypeDescription.GenericTypeToken.Resolution.Raw.RawAnnotatedType.of(typePool, annotationTokens, returnTypeDescriptor);
&nbsp;                        }
&nbsp;
&nbsp;                        public TypeList.Generic resolveParameterTypes(List&lt;String&gt; parameterTypeDescriptors, TypePool typePool, Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens, MethodDescription.InDefinedShape definingMethod) {
&nbsp;                            return TypePool.Default.LazyTypeDescription.GenericTypeToken.Resolution.Raw.RawAnnotatedType.LazyRawAnnotatedTypeList.of(typePool, annotationTokens, parameterTypeDescriptors);
&nbsp;                        }
&nbsp;
&nbsp;                        public TypeList.Generic resolveExceptionTypes(List&lt;String&gt; exceptionTypeDescriptors, TypePool typePool, Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens, MethodDescription.InDefinedShape definingMethod) {
&nbsp;                            return TypePool.Default.LazyTypeDescription.GenericTypeToken.Resolution.Raw.RawAnnotatedType.LazyRawAnnotatedTypeList.of(typePool, annotationTokens, exceptionTypeDescriptors);
&nbsp;                        }
&nbsp;
&nbsp;                        public TypeDescription.Generic resolveRecordType(String recordTypeDescriptor, TypePool typePool, Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens, RecordComponentDescription.InDefinedShape definingRecordComponent) {
&nbsp;                            return TypePool.Default.LazyTypeDescription.GenericTypeToken.Resolution.Raw.RawAnnotatedType.of(typePool, annotationTokens, recordTypeDescriptor);
&nbsp;                        }
&nbsp;
&nbsp;                        protected static class RawAnnotatedType extends TypeDescription.Generic.OfNonGenericType {
&nbsp;                            private final TypePool typePool;
&nbsp;                            private final String typePath;
&nbsp;                            private final Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens;
&nbsp;                            private final TypeDescription typeDescription;
&nbsp;
&nbsp;                            protected RawAnnotatedType(TypePool typePool, String typePath, Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens, TypeDescription typeDescription) {
&nbsp;                                this.typePool = typePool;
&nbsp;                                this.typePath = typePath;
&nbsp;                                this.annotationTokens = annotationTokens;
&nbsp;                                this.typeDescription = typeDescription;
&nbsp;                            }
&nbsp;
&nbsp;                            protected static TypeDescription.Generic of(TypePool typePool, @Nonnull(when = When.MAYBE) Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens, String descriptor) {
&nbsp;                                return new RawAnnotatedType(typePool, &quot;&quot;, annotationTokens == null ? Collections.emptyMap() : annotationTokens, TypePool.Default.LazyTypeDescription.TokenizedGenericType.toErasure(typePool, descriptor));
&nbsp;                            }
&nbsp;
&nbsp;                            public TypeDescription asErasure() {
&nbsp;                                return this.typeDescription;
&nbsp;                            }
&nbsp;
&nbsp;                            @Nonnull(
&nbsp;                                when = When.MAYBE
&nbsp;                            )
&nbsp;                            public TypeDescription.Generic getOwnerType() {
&nbsp;                                TypeDescription declaringType = this.typeDescription.getDeclaringType();
&nbsp;                                return (TypeDescription.Generic)(declaringType == null ? Generic.UNDEFINED : new RawAnnotatedType(this.typePool, this.typePath, this.annotationTokens, declaringType));
&nbsp;                            }
&nbsp;
&nbsp;                            @Nonnull(
&nbsp;                                when = When.MAYBE
&nbsp;                            )
&nbsp;                            public TypeDescription.Generic getComponentType() {
&nbsp;                                TypeDescription componentType = this.typeDescription.getComponentType();
&nbsp;                                return (TypeDescription.Generic)(componentType == null ? Generic.UNDEFINED : new RawAnnotatedType(this.typePool, this.typePath + &#39;[&#39;, this.annotationTokens, componentType));
&nbsp;                            }
&nbsp;
&nbsp;                            public AnnotationList getDeclaredAnnotations() {
&nbsp;                                StringBuilder typePath = new StringBuilder(this.typePath);
&nbsp;
&nbsp;                                for(int index = 0; index &lt; this.typeDescription.getInnerClassCount(); ++index) {
&nbsp;                                    typePath = typePath.append(&#39;.&#39;);
&nbsp;                                }
&nbsp;
&nbsp;                                return TypePool.Default.LazyTypeDescription.LazyAnnotationDescription.asListOfNullable(this.typePool, (List)this.annotationTokens.get(typePath.toString()));
&nbsp;                            }
&nbsp;
&nbsp;                            protected static class LazyRawAnnotatedTypeList extends TypeList.Generic.AbstractBase {
&nbsp;                                private final TypePool typePool;
&nbsp;                                private final Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens;
&nbsp;                                private final List&lt;String&gt; descriptors;
&nbsp;
&nbsp;                                protected LazyRawAnnotatedTypeList(TypePool typePool, Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens, List&lt;String&gt; descriptors) {
&nbsp;                                    this.typePool = typePool;
&nbsp;                                    this.annotationTokens = annotationTokens;
&nbsp;                                    this.descriptors = descriptors;
&nbsp;                                }
&nbsp;
&nbsp;                                protected static TypeList.Generic of(TypePool typePool, @Nonnull(when = When.MAYBE) Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens, List&lt;String&gt; descriptors) {
&nbsp;                                    return new LazyRawAnnotatedTypeList(typePool, annotationTokens == null ? Collections.emptyMap() : annotationTokens, descriptors);
&nbsp;                                }
&nbsp;
&nbsp;                                public TypeDescription.Generic get(int index) {
&nbsp;                                    return TypePool.Default.LazyTypeDescription.GenericTypeToken.Resolution.Raw.RawAnnotatedType.of(this.typePool, (Map)this.annotationTokens.get(index), (String)this.descriptors.get(index));
&nbsp;                                }
&nbsp;
&nbsp;                                public int size() {
&nbsp;                                    return this.descriptors.size();
&nbsp;                                }
&nbsp;
&nbsp;                                public TypeList asErasures() {
&nbsp;                                    return new LazyTypeList(this.typePool, this.descriptors);
&nbsp;                                }
&nbsp;
&nbsp;                                public TypeList.Generic asRawTypes() {
&nbsp;                                    return this;
&nbsp;                                }
&nbsp;
&nbsp;                                public int getStackSize() {
&nbsp;                                    int stackSize = 0;
&nbsp;
&nbsp;                                    String descriptor;
&nbsp;                                    for(Iterator var2 = this.descriptors.iterator(); var2.hasNext(); stackSize += Type.getType(descriptor).getSize()) {
&nbsp;                                        descriptor = (String)var2.next();
&nbsp;                                    }
&nbsp;
&nbsp;                                    return stackSize;
&nbsp;                                }
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public static enum ForUnboundWildcard implements GenericTypeToken {
&nbsp;                    INSTANCE;
&nbsp;
&nbsp;                    private ForUnboundWildcard() {
&nbsp;                    }
&nbsp;
&nbsp;                    public TypeDescription.Generic toGenericType(TypePool typePool, TypeVariableSource typeVariableSource, String typePath, @Nonnull(when = When.MAYBE) Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens) {
&nbsp;                        return new LazyUnboundWildcard(typePool, typePath, annotationTokens == null ? Collections.emptyMap() : annotationTokens);
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean isPrimaryBound(TypePool typePool) {
&nbsp;                        throw new IllegalStateException(&quot;A wildcard type cannot be a type variable bound: &quot; + this);
&nbsp;                    }
&nbsp;
&nbsp;                    public String getTypePathPrefix() {
&nbsp;                        throw new IllegalStateException(&quot;An unbound wildcard cannot be the owner of a nested type: &quot; + this);
&nbsp;                    }
&nbsp;
&nbsp;                    protected static class LazyUnboundWildcard extends TypeDescription.Generic.OfWildcardType {
&nbsp;                        private final TypePool typePool;
&nbsp;                        private final String typePath;
&nbsp;                        private final Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens;
&nbsp;
&nbsp;                        protected LazyUnboundWildcard(TypePool typePool, String typePath, Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens) {
&nbsp;                            this.typePool = typePool;
&nbsp;                            this.typePath = typePath;
&nbsp;                            this.annotationTokens = annotationTokens;
&nbsp;                        }
&nbsp;
&nbsp;                        public TypeList.Generic getUpperBounds() {
&nbsp;                            return new TypeList.Generic.Explicit(new TypeDefinition[]{Generic.OBJECT});
&nbsp;                        }
&nbsp;
&nbsp;                        public TypeList.Generic getLowerBounds() {
&nbsp;                            return new TypeList.Generic.Empty();
&nbsp;                        }
&nbsp;
&nbsp;                        public AnnotationList getDeclaredAnnotations() {
&nbsp;                            return TypePool.Default.LazyTypeDescription.LazyAnnotationDescription.asListOfNullable(this.typePool, (List)this.annotationTokens.get(this.typePath));
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public static enum ForPrimitiveType implements GenericTypeToken {
&nbsp;                    BOOLEAN(Boolean.TYPE),
&nbsp;                    BYTE(Byte.TYPE),
&nbsp;                    SHORT(Short.TYPE),
&nbsp;                    CHAR(Character.TYPE),
&nbsp;                    INTEGER(Integer.TYPE),
&nbsp;                    LONG(Long.TYPE),
&nbsp;                    FLOAT(Float.TYPE),
&nbsp;                    DOUBLE(Double.TYPE),
&nbsp;                    VOID(Void.TYPE);
&nbsp;
&nbsp;                    private final TypeDescription typeDescription;
&nbsp;
&nbsp;                    private ForPrimitiveType(Class type) {
&nbsp;                        this.typeDescription = ForLoadedType.of(type);
&nbsp;                    }
&nbsp;
&nbsp;                    public static GenericTypeToken of(char descriptor) {
&nbsp;                        switch (descriptor) {
&nbsp;                            case &#39;B&#39;:
&nbsp;                                return BYTE;
&nbsp;                            case &#39;C&#39;:
&nbsp;                                return CHAR;
&nbsp;                            case &#39;D&#39;:
&nbsp;                                return DOUBLE;
&nbsp;                            case &#39;E&#39;:
&nbsp;                            case &#39;G&#39;:
&nbsp;                            case &#39;H&#39;:
&nbsp;                            case &#39;K&#39;:
&nbsp;                            case &#39;L&#39;:
&nbsp;                            case &#39;M&#39;:
&nbsp;                            case &#39;N&#39;:
&nbsp;                            case &#39;O&#39;:
&nbsp;                            case &#39;P&#39;:
&nbsp;                            case &#39;Q&#39;:
&nbsp;                            case &#39;R&#39;:
&nbsp;                            case &#39;T&#39;:
&nbsp;                            case &#39;U&#39;:
&nbsp;                            case &#39;W&#39;:
&nbsp;                            case &#39;X&#39;:
&nbsp;                            case &#39;Y&#39;:
&nbsp;                            default:
&nbsp;                                throw new IllegalArgumentException(&quot;Not a valid primitive type descriptor: &quot; + descriptor);
&nbsp;                            case &#39;F&#39;:
&nbsp;                                return FLOAT;
&nbsp;                            case &#39;I&#39;:
&nbsp;                                return INTEGER;
&nbsp;                            case &#39;J&#39;:
&nbsp;                                return LONG;
&nbsp;                            case &#39;S&#39;:
&nbsp;                                return SHORT;
&nbsp;                            case &#39;V&#39;:
&nbsp;                                return VOID;
&nbsp;                            case &#39;Z&#39;:
&nbsp;                                return BOOLEAN;
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public TypeDescription.Generic toGenericType(TypePool typePool, TypeVariableSource typeVariableSource, String typePath, Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens) {
&nbsp;                        return new LazyPrimitiveType(typePool, typePath, annotationTokens, this.typeDescription);
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean isPrimaryBound(TypePool typePool) {
&nbsp;                        throw new IllegalStateException(&quot;A primitive type cannot be a type variable bound: &quot; + this);
&nbsp;                    }
&nbsp;
&nbsp;                    public String getTypePathPrefix() {
&nbsp;                        throw new IllegalStateException(&quot;A primitive type cannot be the owner of a nested type: &quot; + this);
&nbsp;                    }
&nbsp;
&nbsp;                    protected static class LazyPrimitiveType extends TypeDescription.Generic.OfNonGenericType {
&nbsp;                        private final TypePool typePool;
&nbsp;                        private final String typePath;
&nbsp;                        private final Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens;
&nbsp;                        private final TypeDescription typeDescription;
&nbsp;
&nbsp;                        protected LazyPrimitiveType(TypePool typePool, String typePath, Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens, TypeDescription typeDescription) {
&nbsp;                            this.typePool = typePool;
&nbsp;                            this.typePath = typePath;
&nbsp;                            this.annotationTokens = annotationTokens;
&nbsp;                            this.typeDescription = typeDescription;
&nbsp;                        }
&nbsp;
&nbsp;                        public TypeDescription asErasure() {
&nbsp;                            return this.typeDescription;
&nbsp;                        }
&nbsp;
&nbsp;                        @Nonnull(
&nbsp;                            when = When.MAYBE
&nbsp;                        )
&nbsp;                        public TypeDescription.Generic getOwnerType() {
&nbsp;                            return Generic.UNDEFINED;
&nbsp;                        }
&nbsp;
&nbsp;                        @Nonnull(
&nbsp;                            when = When.MAYBE
&nbsp;                        )
&nbsp;                        public TypeDescription.Generic getComponentType() {
&nbsp;                            return Generic.UNDEFINED;
&nbsp;                        }
&nbsp;
&nbsp;                        public AnnotationList getDeclaredAnnotations() {
&nbsp;                            return TypePool.Default.LazyTypeDescription.LazyAnnotationDescription.asListOfNullable(this.typePool, (List)this.annotationTokens.get(this.typePath));
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public interface OfFormalTypeVariable {
&nbsp;                    TypeDescription.Generic toGenericType(TypePool var1, TypeVariableSource var2, Map&lt;String, List&lt;AnnotationToken&gt;&gt; var3, Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; var4);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            protected interface TypeContainment {
&nbsp;                @Nonnull(
&nbsp;                    when = When.MAYBE
&nbsp;                )
&nbsp;                MethodDescription.InDefinedShape getEnclosingMethod(TypePool var1);
&nbsp;
&nbsp;                @Nonnull(
&nbsp;                    when = When.MAYBE
&nbsp;                )
&nbsp;                TypeDescription getEnclosingType(TypePool var1);
&nbsp;
&nbsp;                boolean isSelfContained();
&nbsp;
&nbsp;                boolean isLocalType();
&nbsp;
&nbsp;                @Enhance
&nbsp;                public static class WithinMethod implements TypeContainment {
&nbsp;                    private final String name;
&nbsp;                    private final String methodName;
&nbsp;                    private final String methodDescriptor;
&nbsp;
&nbsp;                    protected WithinMethod(String internalName, String methodName, String methodDescriptor) {
&nbsp;                        this.name = internalName.replace(&#39;/&#39;, &#39;.&#39;);
&nbsp;                        this.methodName = methodName;
&nbsp;                        this.methodDescriptor = methodDescriptor;
&nbsp;                    }
&nbsp;
&nbsp;                    public MethodDescription.InDefinedShape getEnclosingMethod(TypePool typePool) {
&nbsp;                        TypeDescription enclosingType = this.getEnclosingType(typePool);
&nbsp;                        if (enclosingType == null) {
&nbsp;                            throw new IllegalStateException(&quot;Could not resolve enclosing type &quot; + this.name);
&nbsp;                        } else {
&nbsp;                            MethodList&lt;MethodDescription.InDefinedShape&gt; enclosingMethod = (MethodList)enclosingType.getDeclaredMethods().filter(ElementMatchers.hasMethodName(this.methodName).and(ElementMatchers.hasDescriptor(this.methodDescriptor)));
&nbsp;                            if (enclosingMethod.isEmpty()) {
&nbsp;                                throw new IllegalStateException(this.methodName + this.methodDescriptor + &quot; not declared by &quot; + enclosingType);
&nbsp;                            } else {
&nbsp;                                return (MethodDescription.InDefinedShape)enclosingMethod.getOnly();
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public TypeDescription getEnclosingType(TypePool typePool) {
&nbsp;                        return typePool.describe(this.name).resolve();
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean isSelfContained() {
&nbsp;                        return false;
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean isLocalType() {
&nbsp;                        return true;
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(Object var1) {
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else if (!this.name.equals(((WithinMethod)var1).name)) {
&nbsp;                            return false;
&nbsp;                        } else if (!this.methodName.equals(((WithinMethod)var1).methodName)) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return this.methodDescriptor.equals(((WithinMethod)var1).methodDescriptor);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return ((this.getClass().hashCode() * 31 + this.name.hashCode()) * 31 + this.methodName.hashCode()) * 31 + this.methodDescriptor.hashCode();
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Enhance
&nbsp;                public static class WithinType implements TypeContainment {
&nbsp;                    private final String name;
&nbsp;                    private final boolean localType;
&nbsp;
&nbsp;                    protected WithinType(String internalName, boolean localType) {
&nbsp;                        this.name = internalName.replace(&#39;/&#39;, &#39;.&#39;);
&nbsp;                        this.localType = localType;
&nbsp;                    }
&nbsp;
&nbsp;                    @Nonnull(
&nbsp;                        when = When.MAYBE
&nbsp;                    )
&nbsp;                    public MethodDescription.InDefinedShape getEnclosingMethod(TypePool typePool) {
&nbsp;                        return MethodDescription.UNDEFINED;
&nbsp;                    }
&nbsp;
&nbsp;                    public TypeDescription getEnclosingType(TypePool typePool) {
&nbsp;                        return typePool.describe(this.name).resolve();
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean isSelfContained() {
&nbsp;                        return false;
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean isLocalType() {
&nbsp;                        return this.localType;
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(Object var1) {
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else if (this.localType != ((WithinType)var1).localType) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return this.name.equals(((WithinType)var1).name);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return (this.getClass().hashCode() * 31 + this.name.hashCode()) * 31 + this.localType;
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public static enum SelfContained implements TypeContainment {
&nbsp;                    INSTANCE;
&nbsp;
&nbsp;                    private SelfContained() {
&nbsp;                    }
&nbsp;
&nbsp;                    @Nonnull(
&nbsp;                        when = When.MAYBE
&nbsp;                    )
&nbsp;                    public MethodDescription.InDefinedShape getEnclosingMethod(TypePool typePool) {
&nbsp;                        return MethodDescription.UNDEFINED;
&nbsp;                    }
&nbsp;
&nbsp;                    @Nonnull(
&nbsp;                        when = When.MAYBE
&nbsp;                    )
&nbsp;                    public TypeDescription getEnclosingType(TypePool typePool) {
&nbsp;                        return TypeDescription.UNDEFINED;
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean isSelfContained() {
&nbsp;                        return true;
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean isLocalType() {
&nbsp;                        return false;
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            protected class RecordComponentTokenList extends RecordComponentList.AbstractBase&lt;RecordComponentDescription.InDefinedShape&gt; {
&nbsp;                protected RecordComponentTokenList() {
&nbsp;                }
&nbsp;
&nbsp;                public RecordComponentDescription.InDefinedShape get(int index) {
&nbsp;                    return ((RecordComponentToken)LazyTypeDescription.this.recordComponentTokens.get(index)).toRecordComponentDescription(LazyTypeDescription.this);
&nbsp;                }
&nbsp;
&nbsp;                public int size() {
&nbsp;                    return LazyTypeDescription.this.recordComponentTokens.size();
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            protected class MethodTokenList extends MethodList.AbstractBase&lt;MethodDescription.InDefinedShape&gt; {
&nbsp;                protected MethodTokenList() {
&nbsp;                }
&nbsp;
&nbsp;                public MethodDescription.InDefinedShape get(int index) {
&nbsp;                    return ((MethodToken)LazyTypeDescription.this.methodTokens.get(index)).toMethodDescription(LazyTypeDescription.this);
&nbsp;                }
&nbsp;
&nbsp;                public int size() {
&nbsp;                    return LazyTypeDescription.this.methodTokens.size();
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            protected class FieldTokenList extends FieldList.AbstractBase&lt;FieldDescription.InDefinedShape&gt; {
&nbsp;                protected FieldTokenList() {
&nbsp;                }
&nbsp;
&nbsp;                public FieldDescription.InDefinedShape get(int index) {
&nbsp;                    return ((FieldToken)LazyTypeDescription.this.fieldTokens.get(index)).toFieldDescription(LazyTypeDescription.this);
&nbsp;                }
&nbsp;
&nbsp;                public int size() {
&nbsp;                    return LazyTypeDescription.this.fieldTokens.size();
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        protected static class GenericTypeExtractor extends GenericTypeRegistrant.RejectingSignatureVisitor implements GenericTypeRegistrant {
&nbsp;            private final GenericTypeRegistrant genericTypeRegistrant;
&nbsp;            @Nonnull(
&nbsp;                when = When.UNKNOWN
&nbsp;            )
&nbsp;            private IncompleteToken incompleteToken;
&nbsp;
&nbsp;            protected GenericTypeExtractor(GenericTypeRegistrant genericTypeRegistrant) {
&nbsp;                this.genericTypeRegistrant = genericTypeRegistrant;
&nbsp;            }
&nbsp;
&nbsp;            public void visitBaseType(char descriptor) {
&nbsp;                this.genericTypeRegistrant.register(TypePool.Default.LazyTypeDescription.GenericTypeToken.ForPrimitiveType.of(descriptor));
&nbsp;            }
&nbsp;
&nbsp;            public void visitTypeVariable(String name) {
&nbsp;                this.genericTypeRegistrant.register(new LazyTypeDescription.GenericTypeToken.ForTypeVariable(name));
&nbsp;            }
&nbsp;
&nbsp;            public SignatureVisitor visitArrayType() {
&nbsp;                return new GenericTypeExtractor(this);
&nbsp;            }
&nbsp;
&nbsp;            public void register(LazyTypeDescription.GenericTypeToken componentTypeToken) {
&nbsp;                this.genericTypeRegistrant.register(new LazyTypeDescription.GenericTypeToken.ForGenericArray(componentTypeToken));
&nbsp;            }
&nbsp;
&nbsp;            public void visitClassType(String name) {
&nbsp;                this.incompleteToken = new IncompleteToken.ForTopLevelType(name);
&nbsp;            }
&nbsp;
&nbsp;            public void visitInnerClassType(String name) {
&nbsp;                this.incompleteToken = new IncompleteToken.ForInnerClass(name, this.incompleteToken);
&nbsp;            }
&nbsp;
&nbsp;            public void visitTypeArgument() {
&nbsp;                this.incompleteToken.appendPlaceholder();
&nbsp;            }
&nbsp;
&nbsp;            public SignatureVisitor visitTypeArgument(char wildcard) {
&nbsp;                switch (wildcard) {
&nbsp;                    case &#39;+&#39;:
&nbsp;                        return this.incompleteToken.appendUpperBound();
&nbsp;                    case &#39;-&#39;:
&nbsp;                        return this.incompleteToken.appendLowerBound();
&nbsp;                    case &#39;=&#39;:
&nbsp;                        return this.incompleteToken.appendDirectBound();
&nbsp;                    default:
&nbsp;                        throw new IllegalArgumentException(&quot;Unknown wildcard: &quot; + wildcard);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public void visitEnd() {
&nbsp;                this.genericTypeRegistrant.register(this.incompleteToken.toToken());
&nbsp;            }
&nbsp;
&nbsp;            protected abstract static class ForSignature&lt;T extends LazyTypeDescription.GenericTypeToken.Resolution&gt; extends GenericTypeRegistrant.RejectingSignatureVisitor implements GenericTypeRegistrant {
&nbsp;                protected final List&lt;LazyTypeDescription.GenericTypeToken.OfFormalTypeVariable&gt; typeVariableTokens = new ArrayList();
&nbsp;                @Nonnull(
&nbsp;                    when = When.MAYBE
&nbsp;                )
&nbsp;                protected String currentTypeParameter;
&nbsp;                @Nonnull(
&nbsp;                    when = When.UNKNOWN
&nbsp;                )
&nbsp;                protected List&lt;LazyTypeDescription.GenericTypeToken&gt; currentBounds;
&nbsp;
&nbsp;                public ForSignature() {
&nbsp;                }
&nbsp;
&nbsp;                protected static &lt;S extends LazyTypeDescription.GenericTypeToken.Resolution&gt; S extract(String genericSignature, ForSignature&lt;S&gt; visitor) {
&nbsp;                    SignatureReader signatureReader = new SignatureReader(genericSignature);
&nbsp;                    signatureReader.accept(visitor);
&nbsp;                    return visitor.resolve();
&nbsp;                }
&nbsp;
&nbsp;                public void visitFormalTypeParameter(String name) {
&nbsp;                    this.collectTypeParameter();
&nbsp;                    this.currentTypeParameter = name;
&nbsp;                    this.currentBounds = new ArrayList();
&nbsp;                }
&nbsp;
&nbsp;                public SignatureVisitor visitClassBound() {
&nbsp;                    return new GenericTypeExtractor(this);
&nbsp;                }
&nbsp;
&nbsp;                public SignatureVisitor visitInterfaceBound() {
&nbsp;                    return new GenericTypeExtractor(this);
&nbsp;                }
&nbsp;
&nbsp;                public void register(LazyTypeDescription.GenericTypeToken token) {
&nbsp;                    if (this.currentBounds == null) {
&nbsp;                        throw new IllegalStateException(&quot;Did not expect &quot; + token + &quot; before finding formal parameter&quot;);
&nbsp;                    } else {
&nbsp;                        this.currentBounds.add(token);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                protected void collectTypeParameter() {
&nbsp;                    if (this.currentTypeParameter != null) {
&nbsp;                        this.typeVariableTokens.add(new LazyTypeDescription.GenericTypeToken.ForTypeVariable.Formal(this.currentTypeParameter, this.currentBounds));
&nbsp;                    }
&nbsp;
&nbsp;                }
&nbsp;
&nbsp;                public abstract T resolve();
&nbsp;
&nbsp;                protected static class OfRecordComponent implements GenericTypeRegistrant {
&nbsp;                    @Nonnull(
&nbsp;                        when = When.UNKNOWN
&nbsp;                    )
&nbsp;                    private LazyTypeDescription.GenericTypeToken recordComponentType;
&nbsp;
&nbsp;                    protected OfRecordComponent() {
&nbsp;                    }
&nbsp;
&nbsp;                    public static LazyTypeDescription.GenericTypeToken.Resolution.ForRecordComponent extract(@Nonnull(when = When.MAYBE) String genericSignature) {
&nbsp;                        if (genericSignature == null) {
&nbsp;                            return TypePool.Default.LazyTypeDescription.GenericTypeToken.Resolution.Raw.INSTANCE;
&nbsp;                        } else {
&nbsp;                            SignatureReader signatureReader = new SignatureReader(genericSignature);
&nbsp;                            OfRecordComponent visitor = new OfRecordComponent();
&nbsp;
&nbsp;                            try {
&nbsp;                                signatureReader.acceptType(new GenericTypeExtractor(visitor));
&nbsp;                                return visitor.resolve();
&nbsp;                            } catch (RuntimeException var4) {
&nbsp;                                return TypePool.Default.LazyTypeDescription.GenericTypeToken.Resolution.Malformed.INSTANCE;
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public void register(LazyTypeDescription.GenericTypeToken token) {
&nbsp;                        this.recordComponentType = token;
&nbsp;                    }
&nbsp;
&nbsp;                    protected LazyTypeDescription.GenericTypeToken.Resolution.ForRecordComponent resolve() {
&nbsp;                        return new LazyTypeDescription.GenericTypeToken.Resolution.ForRecordComponent.Tokenized(this.recordComponentType);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                protected static class OfMethod extends ForSignature&lt;LazyTypeDescription.GenericTypeToken.Resolution.ForMethod&gt; {
&nbsp;                    private final List&lt;LazyTypeDescription.GenericTypeToken&gt; parameterTypeTokens = new ArrayList();
&nbsp;                    private final List&lt;LazyTypeDescription.GenericTypeToken&gt; exceptionTypeTokens = new ArrayList();
&nbsp;                    @Nonnull(
&nbsp;                        when = When.UNKNOWN
&nbsp;                    )
&nbsp;                    private LazyTypeDescription.GenericTypeToken returnTypeToken;
&nbsp;
&nbsp;                    public OfMethod() {
&nbsp;                    }
&nbsp;
&nbsp;                    public static LazyTypeDescription.GenericTypeToken.Resolution.ForMethod extract(@Nonnull(when = When.MAYBE) String genericSignature) {
&nbsp;                        try {
&nbsp;                            return (LazyTypeDescription.GenericTypeToken.Resolution.ForMethod)(genericSignature == null ? TypePool.Default.LazyTypeDescription.GenericTypeToken.Resolution.Raw.INSTANCE : (LazyTypeDescription.GenericTypeToken.Resolution.ForMethod)TypePool.Default.GenericTypeExtractor.ForSignature.extract(genericSignature, new OfMethod()));
&nbsp;                        } catch (RuntimeException var2) {
&nbsp;                            return TypePool.Default.LazyTypeDescription.GenericTypeToken.Resolution.Malformed.INSTANCE;
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public SignatureVisitor visitParameterType() {
&nbsp;                        return new GenericTypeExtractor(new ParameterTypeRegistrant());
&nbsp;                    }
&nbsp;
&nbsp;                    public SignatureVisitor visitReturnType() {
&nbsp;                        this.collectTypeParameter();
&nbsp;                        return new GenericTypeExtractor(new ReturnTypeTypeRegistrant());
&nbsp;                    }
&nbsp;
&nbsp;                    public SignatureVisitor visitExceptionType() {
&nbsp;                        return new GenericTypeExtractor(new ExceptionTypeRegistrant());
&nbsp;                    }
&nbsp;
&nbsp;                    public LazyTypeDescription.GenericTypeToken.Resolution.ForMethod resolve() {
&nbsp;                        return new LazyTypeDescription.GenericTypeToken.Resolution.ForMethod.Tokenized(this.returnTypeToken, this.parameterTypeTokens, this.exceptionTypeTokens, this.typeVariableTokens);
&nbsp;                    }
&nbsp;
&nbsp;                    @Enhance(
&nbsp;                        includeSyntheticFields = true
&nbsp;                    )
&nbsp;                    protected class ExceptionTypeRegistrant implements GenericTypeRegistrant {
&nbsp;                        protected ExceptionTypeRegistrant() {
&nbsp;                        }
&nbsp;
&nbsp;                        public void register(LazyTypeDescription.GenericTypeToken token) {
&nbsp;                            OfMethod.this.exceptionTypeTokens.add(token);
&nbsp;                        }
&nbsp;
&nbsp;                        public boolean equals(Object var1) {
&nbsp;                            if (this == var1) {
&nbsp;                                return true;
&nbsp;                            } else if (var1 == null) {
&nbsp;                                return false;
&nbsp;                            } else if (this.getClass() != var1.getClass()) {
&nbsp;                                return false;
&nbsp;                            } else {
&nbsp;                                return OfMethod.this.equals(OfMethod.this);
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        public int hashCode() {
&nbsp;                            return this.getClass().hashCode() * 31 + OfMethod.this.hashCode();
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    @Enhance(
&nbsp;                        includeSyntheticFields = true
&nbsp;                    )
&nbsp;                    protected class ReturnTypeTypeRegistrant implements GenericTypeRegistrant {
&nbsp;                        protected ReturnTypeTypeRegistrant() {
&nbsp;                        }
&nbsp;
&nbsp;                        public void register(LazyTypeDescription.GenericTypeToken token) {
&nbsp;                            OfMethod.this.returnTypeToken = token;
&nbsp;                        }
&nbsp;
&nbsp;                        public boolean equals(Object var1) {
&nbsp;                            if (this == var1) {
&nbsp;                                return true;
&nbsp;                            } else if (var1 == null) {
&nbsp;                                return false;
&nbsp;                            } else if (this.getClass() != var1.getClass()) {
&nbsp;                                return false;
&nbsp;                            } else {
&nbsp;                                return OfMethod.this.equals(OfMethod.this);
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        public int hashCode() {
&nbsp;                            return this.getClass().hashCode() * 31 + OfMethod.this.hashCode();
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    @Enhance(
&nbsp;                        includeSyntheticFields = true
&nbsp;                    )
&nbsp;                    protected class ParameterTypeRegistrant implements GenericTypeRegistrant {
&nbsp;                        protected ParameterTypeRegistrant() {
&nbsp;                        }
&nbsp;
&nbsp;                        public void register(LazyTypeDescription.GenericTypeToken token) {
&nbsp;                            OfMethod.this.parameterTypeTokens.add(token);
&nbsp;                        }
&nbsp;
&nbsp;                        public boolean equals(Object var1) {
&nbsp;                            if (this == var1) {
&nbsp;                                return true;
&nbsp;                            } else if (var1 == null) {
&nbsp;                                return false;
&nbsp;                            } else if (this.getClass() != var1.getClass()) {
&nbsp;                                return false;
&nbsp;                            } else {
&nbsp;                                return OfMethod.this.equals(OfMethod.this);
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        public int hashCode() {
&nbsp;                            return this.getClass().hashCode() * 31 + OfMethod.this.hashCode();
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                protected static class OfField implements GenericTypeRegistrant {
&nbsp;                    @Nonnull(
&nbsp;                        when = When.UNKNOWN
&nbsp;                    )
&nbsp;                    private LazyTypeDescription.GenericTypeToken fieldTypeToken;
&nbsp;
&nbsp;                    protected OfField() {
&nbsp;                    }
&nbsp;
&nbsp;                    public static LazyTypeDescription.GenericTypeToken.Resolution.ForField extract(@Nonnull(when = When.MAYBE) String genericSignature) {
&nbsp;                        if (genericSignature == null) {
&nbsp;                            return TypePool.Default.LazyTypeDescription.GenericTypeToken.Resolution.Raw.INSTANCE;
&nbsp;                        } else {
&nbsp;                            SignatureReader signatureReader = new SignatureReader(genericSignature);
&nbsp;                            OfField visitor = new OfField();
&nbsp;
&nbsp;                            try {
&nbsp;                                signatureReader.acceptType(new GenericTypeExtractor(visitor));
&nbsp;                                return visitor.resolve();
&nbsp;                            } catch (RuntimeException var4) {
&nbsp;                                return TypePool.Default.LazyTypeDescription.GenericTypeToken.Resolution.Malformed.INSTANCE;
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public void register(LazyTypeDescription.GenericTypeToken token) {
&nbsp;                        this.fieldTypeToken = token;
&nbsp;                    }
&nbsp;
&nbsp;                    protected LazyTypeDescription.GenericTypeToken.Resolution.ForField resolve() {
&nbsp;                        return new LazyTypeDescription.GenericTypeToken.Resolution.ForField.Tokenized(this.fieldTypeToken);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                protected static class OfType extends ForSignature&lt;LazyTypeDescription.GenericTypeToken.Resolution.ForType&gt; {
&nbsp;                    private final List&lt;LazyTypeDescription.GenericTypeToken&gt; interfaceTypeTokens = new ArrayList();
&nbsp;                    @Nonnull(
&nbsp;                        when = When.UNKNOWN
&nbsp;                    )
&nbsp;                    private LazyTypeDescription.GenericTypeToken superClassToken;
&nbsp;
&nbsp;                    protected OfType() {
&nbsp;                    }
&nbsp;
&nbsp;                    public static LazyTypeDescription.GenericTypeToken.Resolution.ForType extract(@Nonnull(when = When.MAYBE) String genericSignature) {
&nbsp;                        try {
&nbsp;                            return (LazyTypeDescription.GenericTypeToken.Resolution.ForType)(genericSignature == null ? TypePool.Default.LazyTypeDescription.GenericTypeToken.Resolution.Raw.INSTANCE : (LazyTypeDescription.GenericTypeToken.Resolution.ForType)TypePool.Default.GenericTypeExtractor.ForSignature.extract(genericSignature, new OfType()));
&nbsp;                        } catch (RuntimeException var2) {
&nbsp;                            return TypePool.Default.LazyTypeDescription.GenericTypeToken.Resolution.Malformed.INSTANCE;
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public SignatureVisitor visitSuperclass() {
&nbsp;                        this.collectTypeParameter();
&nbsp;                        return new GenericTypeExtractor(new SuperClassRegistrant());
&nbsp;                    }
&nbsp;
&nbsp;                    public SignatureVisitor visitInterface() {
&nbsp;                        return new GenericTypeExtractor(new InterfaceTypeRegistrant());
&nbsp;                    }
&nbsp;
&nbsp;                    public LazyTypeDescription.GenericTypeToken.Resolution.ForType resolve() {
&nbsp;                        return new LazyTypeDescription.GenericTypeToken.Resolution.ForType.Tokenized(this.superClassToken, this.interfaceTypeTokens, this.typeVariableTokens);
&nbsp;                    }
&nbsp;
&nbsp;                    @Enhance(
&nbsp;                        includeSyntheticFields = true
&nbsp;                    )
&nbsp;                    protected class InterfaceTypeRegistrant implements GenericTypeRegistrant {
&nbsp;                        protected InterfaceTypeRegistrant() {
&nbsp;                        }
&nbsp;
&nbsp;                        public void register(LazyTypeDescription.GenericTypeToken token) {
&nbsp;                            OfType.this.interfaceTypeTokens.add(token);
&nbsp;                        }
&nbsp;
&nbsp;                        public boolean equals(Object var1) {
&nbsp;                            if (this == var1) {
&nbsp;                                return true;
&nbsp;                            } else if (var1 == null) {
&nbsp;                                return false;
&nbsp;                            } else if (this.getClass() != var1.getClass()) {
&nbsp;                                return false;
&nbsp;                            } else {
&nbsp;                                return OfType.this.equals(OfType.this);
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        public int hashCode() {
&nbsp;                            return this.getClass().hashCode() * 31 + OfType.this.hashCode();
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    @Enhance(
&nbsp;                        includeSyntheticFields = true
&nbsp;                    )
&nbsp;                    protected class SuperClassRegistrant implements GenericTypeRegistrant {
&nbsp;                        protected SuperClassRegistrant() {
&nbsp;                        }
&nbsp;
&nbsp;                        public void register(LazyTypeDescription.GenericTypeToken token) {
&nbsp;                            OfType.this.superClassToken = token;
&nbsp;                        }
&nbsp;
&nbsp;                        public boolean equals(Object var1) {
&nbsp;                            if (this == var1) {
&nbsp;                                return true;
&nbsp;                            } else if (var1 == null) {
&nbsp;                                return false;
&nbsp;                            } else if (this.getClass() != var1.getClass()) {
&nbsp;                                return false;
&nbsp;                            } else {
&nbsp;                                return OfType.this.equals(OfType.this);
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        public int hashCode() {
&nbsp;                            return this.getClass().hashCode() * 31 + OfType.this.hashCode();
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            protected interface IncompleteToken {
&nbsp;                SignatureVisitor appendLowerBound();
&nbsp;
&nbsp;                SignatureVisitor appendUpperBound();
&nbsp;
&nbsp;                SignatureVisitor appendDirectBound();
&nbsp;
&nbsp;                void appendPlaceholder();
&nbsp;
&nbsp;                boolean isParameterized();
&nbsp;
&nbsp;                String getName();
&nbsp;
&nbsp;                LazyTypeDescription.GenericTypeToken toToken();
&nbsp;
&nbsp;                @Enhance
&nbsp;                public static class ForInnerClass extends AbstractBase {
&nbsp;                    private static final char INNER_CLASS_SEPARATOR = &#39;$&#39;;
&nbsp;                    private final String internalName;
&nbsp;                    private final IncompleteToken outerTypeToken;
&nbsp;
&nbsp;                    public ForInnerClass(String internalName, IncompleteToken outerTypeToken) {
&nbsp;                        this.internalName = internalName;
&nbsp;                        this.outerTypeToken = outerTypeToken;
&nbsp;                    }
&nbsp;
&nbsp;                    public LazyTypeDescription.GenericTypeToken toToken() {
&nbsp;                        return (LazyTypeDescription.GenericTypeToken)(!this.isParameterized() &amp;&amp; !this.outerTypeToken.isParameterized() ? new LazyTypeDescription.GenericTypeToken.ForRawType(this.getName()) : new LazyTypeDescription.GenericTypeToken.ForParameterizedType.Nested(this.getName(), this.parameters, this.outerTypeToken.toToken()));
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean isParameterized() {
&nbsp;                        return !this.parameters.isEmpty() || !this.outerTypeToken.isParameterized();
&nbsp;                    }
&nbsp;
&nbsp;                    public String getName() {
&nbsp;                        return this.outerTypeToken.getName() + &#39;$&#39; + this.internalName.replace(&#39;/&#39;, &#39;.&#39;);
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(Object var1) {
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else if (!this.internalName.equals(((ForInnerClass)var1).internalName)) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return this.outerTypeToken.equals(((ForInnerClass)var1).outerTypeToken);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return (this.getClass().hashCode() * 31 + this.internalName.hashCode()) * 31 + this.outerTypeToken.hashCode();
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Enhance
&nbsp;                public static class ForTopLevelType extends AbstractBase {
&nbsp;                    private final String internalName;
&nbsp;
&nbsp;                    public ForTopLevelType(String internalName) {
&nbsp;                        this.internalName = internalName;
&nbsp;                    }
&nbsp;
&nbsp;                    public LazyTypeDescription.GenericTypeToken toToken() {
&nbsp;                        return (LazyTypeDescription.GenericTypeToken)(this.isParameterized() ? new LazyTypeDescription.GenericTypeToken.ForParameterizedType(this.getName(), this.parameters) : new LazyTypeDescription.GenericTypeToken.ForRawType(this.getName()));
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean isParameterized() {
&nbsp;                        return !this.parameters.isEmpty();
&nbsp;                    }
&nbsp;
&nbsp;                    public String getName() {
&nbsp;                        return this.internalName.replace(&#39;/&#39;, &#39;.&#39;);
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(Object var1) {
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return this.internalName.equals(((ForTopLevelType)var1).internalName);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return this.getClass().hashCode() * 31 + this.internalName.hashCode();
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public abstract static class AbstractBase implements IncompleteToken {
&nbsp;                    protected final List&lt;LazyTypeDescription.GenericTypeToken&gt; parameters = new ArrayList();
&nbsp;
&nbsp;                    public AbstractBase() {
&nbsp;                    }
&nbsp;
&nbsp;                    public SignatureVisitor appendDirectBound() {
&nbsp;                        return new GenericTypeExtractor(new ForDirectBound());
&nbsp;                    }
&nbsp;
&nbsp;                    public SignatureVisitor appendUpperBound() {
&nbsp;                        return new GenericTypeExtractor(new ForUpperBound());
&nbsp;                    }
&nbsp;
&nbsp;                    public SignatureVisitor appendLowerBound() {
&nbsp;                        return new GenericTypeExtractor(new ForLowerBound());
&nbsp;                    }
&nbsp;
&nbsp;                    public void appendPlaceholder() {
&nbsp;                        this.parameters.add(TypePool.Default.LazyTypeDescription.GenericTypeToken.ForUnboundWildcard.INSTANCE);
&nbsp;                    }
&nbsp;
&nbsp;                    protected class ForLowerBound implements GenericTypeRegistrant {
&nbsp;                        protected ForLowerBound() {
&nbsp;                        }
&nbsp;
&nbsp;                        public void register(LazyTypeDescription.GenericTypeToken token) {
&nbsp;                            AbstractBase.this.parameters.add(new LazyTypeDescription.GenericTypeToken.ForLowerBoundWildcard(token));
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    protected class ForUpperBound implements GenericTypeRegistrant {
&nbsp;                        protected ForUpperBound() {
&nbsp;                        }
&nbsp;
&nbsp;                        public void register(LazyTypeDescription.GenericTypeToken token) {
&nbsp;                            AbstractBase.this.parameters.add(new LazyTypeDescription.GenericTypeToken.ForUpperBoundWildcard(token));
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    protected class ForDirectBound implements GenericTypeRegistrant {
&nbsp;                        protected ForDirectBound() {
&nbsp;                        }
&nbsp;
&nbsp;                        public void register(LazyTypeDescription.GenericTypeToken token) {
&nbsp;                            AbstractBase.this.parameters.add(token);
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        protected static class ParameterBag {
&nbsp;            private final Type[] parameterType;
&nbsp;            private final Map&lt;Integer, String&gt; parameterRegistry;
&nbsp;
&nbsp;            protected ParameterBag(Type[] parameterType) {
&nbsp;                this.parameterType = parameterType;
&nbsp;                this.parameterRegistry = new HashMap();
&nbsp;            }
&nbsp;
&nbsp;            protected void register(int offset, String name) {
&nbsp;                this.parameterRegistry.put(offset, name);
&nbsp;            }
&nbsp;
&nbsp;            protected List&lt;LazyTypeDescription.MethodToken.ParameterToken&gt; resolve(boolean isStatic) {
&nbsp;                List&lt;LazyTypeDescription.MethodToken.ParameterToken&gt; parameterTokens = new ArrayList(this.parameterType.length);
&nbsp;                int offset = isStatic ? StackSize.ZERO.getSize() : StackSize.SINGLE.getSize();
&nbsp;                Type[] var4 = this.parameterType;
&nbsp;                int var5 = var4.length;
&nbsp;
&nbsp;                for(int var6 = 0; var6 &lt; var5; ++var6) {
&nbsp;                    Type aParameterType = var4[var6];
&nbsp;                    String name = (String)this.parameterRegistry.get(offset);
&nbsp;                    parameterTokens.add(name == null ? new LazyTypeDescription.MethodToken.ParameterToken() : new LazyTypeDescription.MethodToken.ParameterToken(name));
&nbsp;                    offset += aParameterType.getSize();
&nbsp;                }
&nbsp;
&nbsp;                return parameterTokens;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        protected interface GenericTypeRegistrant {
&nbsp;            void register(LazyTypeDescription.GenericTypeToken var1);
&nbsp;
&nbsp;            public static class RejectingSignatureVisitor extends SignatureVisitor {
&nbsp;                private static final String MESSAGE = &quot;Unexpected token in generic signature&quot;;
&nbsp;
&nbsp;                public RejectingSignatureVisitor() {
&nbsp;                    super(OpenedClassReader.ASM_API);
&nbsp;                }
&nbsp;
&nbsp;                public void visitFormalTypeParameter(String name) {
&nbsp;                    throw new IllegalStateException(&quot;Unexpected token in generic signature&quot;);
&nbsp;                }
&nbsp;
&nbsp;                public SignatureVisitor visitClassBound() {
&nbsp;                    throw new IllegalStateException(&quot;Unexpected token in generic signature&quot;);
&nbsp;                }
&nbsp;
&nbsp;                public SignatureVisitor visitInterfaceBound() {
&nbsp;                    throw new IllegalStateException(&quot;Unexpected token in generic signature&quot;);
&nbsp;                }
&nbsp;
&nbsp;                public SignatureVisitor visitSuperclass() {
&nbsp;                    throw new IllegalStateException(&quot;Unexpected token in generic signature&quot;);
&nbsp;                }
&nbsp;
&nbsp;                public SignatureVisitor visitInterface() {
&nbsp;                    throw new IllegalStateException(&quot;Unexpected token in generic signature&quot;);
&nbsp;                }
&nbsp;
&nbsp;                public SignatureVisitor visitParameterType() {
&nbsp;                    throw new IllegalStateException(&quot;Unexpected token in generic signature&quot;);
&nbsp;                }
&nbsp;
&nbsp;                public SignatureVisitor visitReturnType() {
&nbsp;                    throw new IllegalStateException(&quot;Unexpected token in generic signature&quot;);
&nbsp;                }
&nbsp;
&nbsp;                public SignatureVisitor visitExceptionType() {
&nbsp;                    throw new IllegalStateException(&quot;Unexpected token in generic signature&quot;);
&nbsp;                }
&nbsp;
&nbsp;                public void visitBaseType(char descriptor) {
&nbsp;                    throw new IllegalStateException(&quot;Unexpected token in generic signature&quot;);
&nbsp;                }
&nbsp;
&nbsp;                public void visitTypeVariable(String name) {
&nbsp;                    throw new IllegalStateException(&quot;Unexpected token in generic signature&quot;);
&nbsp;                }
&nbsp;
&nbsp;                public SignatureVisitor visitArrayType() {
&nbsp;                    throw new IllegalStateException(&quot;Unexpected token in generic signature&quot;);
&nbsp;                }
&nbsp;
&nbsp;                public void visitClassType(String name) {
&nbsp;                    throw new IllegalStateException(&quot;Unexpected token in generic signature&quot;);
&nbsp;                }
&nbsp;
&nbsp;                public void visitInnerClassType(String name) {
&nbsp;                    throw new IllegalStateException(&quot;Unexpected token in generic signature&quot;);
&nbsp;                }
&nbsp;
&nbsp;                public void visitTypeArgument() {
&nbsp;                    throw new IllegalStateException(&quot;Unexpected token in generic signature&quot;);
&nbsp;                }
&nbsp;
&nbsp;                public SignatureVisitor visitTypeArgument(char wildcard) {
&nbsp;                    throw new IllegalStateException(&quot;Unexpected token in generic signature&quot;);
&nbsp;                }
&nbsp;
&nbsp;                public void visitEnd() {
&nbsp;                    throw new IllegalStateException(&quot;Unexpected token in generic signature&quot;);
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        protected interface ComponentTypeLocator {
&nbsp;            AbstractBase.ComponentTypeReference bind(String var1);
&nbsp;
&nbsp;            @Enhance
&nbsp;            public static class ForArrayType implements ComponentTypeLocator, AbstractBase.ComponentTypeReference {
&nbsp;                private final String componentType;
&nbsp;
&nbsp;                public ForArrayType(String methodDescriptor) {
&nbsp;                    String arrayType = Type.getMethodType(methodDescriptor).getReturnType().getClassName();
&nbsp;                    this.componentType = arrayType.substring(0, arrayType.length() - 2);
&nbsp;                }
&nbsp;
&nbsp;                public AbstractBase.ComponentTypeReference bind(String name) {
&nbsp;                    return this;
&nbsp;                }
&nbsp;
&nbsp;                public String resolve() {
&nbsp;                    return this.componentType;
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(Object var1) {
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.componentType.equals(((ForArrayType)var1).componentType);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return this.getClass().hashCode() * 31 + this.componentType.hashCode();
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Enhance
&nbsp;            public static class ForAnnotationProperty implements ComponentTypeLocator {
&nbsp;                private final TypePool typePool;
&nbsp;                private final String annotationName;
&nbsp;
&nbsp;                public ForAnnotationProperty(TypePool typePool, String annotationDescriptor) {
&nbsp;                    this.typePool = typePool;
&nbsp;                    this.annotationName = annotationDescriptor.substring(1, annotationDescriptor.length() - 1).replace(&#39;/&#39;, &#39;.&#39;);
&nbsp;                }
&nbsp;
&nbsp;                public AbstractBase.ComponentTypeReference bind(String name) {
&nbsp;                    return new Bound(name);
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(Object var1) {
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.annotationName.equals(((ForAnnotationProperty)var1).annotationName)) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.typePool.equals(((ForAnnotationProperty)var1).typePool);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return (this.getClass().hashCode() * 31 + this.typePool.hashCode()) * 31 + this.annotationName.hashCode();
&nbsp;                }
&nbsp;
&nbsp;                @Enhance(
&nbsp;                    includeSyntheticFields = true
&nbsp;                )
&nbsp;                protected class Bound implements AbstractBase.ComponentTypeReference {
&nbsp;                    private final String name;
&nbsp;
&nbsp;                    protected Bound(String name) {
&nbsp;                        this.name = name;
&nbsp;                    }
&nbsp;
&nbsp;                    @Nonnull(
&nbsp;                        when = When.MAYBE
&nbsp;                    )
&nbsp;                    public String resolve() {
&nbsp;                        TypeDescription componentType = ((MethodDescription.InDefinedShape)((MethodList)ForAnnotationProperty.this.typePool.describe(ForAnnotationProperty.this.annotationName).resolve().getDeclaredMethods().filter(ElementMatchers.named(this.name))).getOnly()).getReturnType().asErasure().getComponentType();
&nbsp;                        return componentType == null ? NO_ARRAY : componentType.getName();
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(Object var1) {
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else if (!this.name.equals(((Bound)var1).name)) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return ForAnnotationProperty.this.equals(ForAnnotationProperty.this);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return (this.getClass().hashCode() * 31 + this.name.hashCode()) * 31 + ForAnnotationProperty.this.hashCode();
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public static enum Illegal implements ComponentTypeLocator {
&nbsp;                INSTANCE;
&nbsp;
&nbsp;                private Illegal() {
&nbsp;                }
&nbsp;
&nbsp;                public AbstractBase.ComponentTypeReference bind(String name) {
&nbsp;                    throw new IllegalStateException(&quot;Unexpected lookup of component type for &quot; + name);
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        protected interface AnnotationRegistrant {
&nbsp;            void register(String var1, AnnotationValue&lt;?, ?&gt; var2);
&nbsp;
&nbsp;            void onComplete();
&nbsp;
&nbsp;            public static class ForTypeVariable extends AbstractBase.ForTypeVariable {
&nbsp;                private final Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt; pathMap;
&nbsp;
&nbsp;                protected ForTypeVariable(String descriptor, @Nonnull(when = When.MAYBE) TypePath typePath, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt; pathMap) {
&nbsp;                    super(descriptor, typePath);
&nbsp;                    this.pathMap = pathMap;
&nbsp;                }
&nbsp;
&nbsp;                protected Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt; getPathMap() {
&nbsp;                    return this.pathMap;
&nbsp;                }
&nbsp;
&nbsp;                public static class WithIndex extends AbstractBase.ForTypeVariable.WithIndex {
&nbsp;                    private final Map&lt;Integer, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;&gt; indexedPathMap;
&nbsp;
&nbsp;                    protected WithIndex(String descriptor, @Nonnull(when = When.MAYBE) TypePath typePath, int index, Map&lt;Integer, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;&gt; indexedPathMap) {
&nbsp;                        super(descriptor, typePath, index);
&nbsp;                        this.indexedPathMap = indexedPathMap;
&nbsp;                    }
&nbsp;
&nbsp;                    protected Map&lt;Integer, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;&gt; getIndexedPathMap() {
&nbsp;                        return this.indexedPathMap;
&nbsp;                    }
&nbsp;
&nbsp;                    public static class DoubleIndexed extends AbstractBase.ForTypeVariable.WithIndex.DoubleIndexed {
&nbsp;                        private final Map&lt;Integer, Map&lt;Integer, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;&gt;&gt; doubleIndexedPathMap;
&nbsp;
&nbsp;                        protected DoubleIndexed(String descriptor, @Nonnull(when = When.MAYBE) TypePath typePath, int index, int preIndex, Map&lt;Integer, Map&lt;Integer, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;&gt;&gt; doubleIndexedPathMap) {
&nbsp;                            super(descriptor, typePath, index, preIndex);
&nbsp;                            this.doubleIndexedPathMap = doubleIndexedPathMap;
&nbsp;                        }
&nbsp;
&nbsp;                        protected Map&lt;Integer, Map&lt;Integer, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;&gt;&gt; getDoubleIndexedPathMap() {
&nbsp;                            return this.doubleIndexedPathMap;
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public static class ForByteCodeElement extends AbstractBase {
&nbsp;                private final List&lt;LazyTypeDescription.AnnotationToken&gt; annotationTokens;
&nbsp;
&nbsp;                protected ForByteCodeElement(String descriptor, List&lt;LazyTypeDescription.AnnotationToken&gt; annotationTokens) {
&nbsp;                    super(descriptor);
&nbsp;                    this.annotationTokens = annotationTokens;
&nbsp;                }
&nbsp;
&nbsp;                protected List&lt;LazyTypeDescription.AnnotationToken&gt; getTokens() {
&nbsp;                    return this.annotationTokens;
&nbsp;                }
&nbsp;
&nbsp;                public static class WithIndex extends AbstractBase {
&nbsp;                    private final int index;
&nbsp;                    private final Map&lt;Integer, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt; annotationTokens;
&nbsp;
&nbsp;                    protected WithIndex(String descriptor, int index, Map&lt;Integer, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt; annotationTokens) {
&nbsp;                        super(descriptor);
&nbsp;                        this.index = index;
&nbsp;                        this.annotationTokens = annotationTokens;
&nbsp;                    }
&nbsp;
&nbsp;                    protected List&lt;LazyTypeDescription.AnnotationToken&gt; getTokens() {
&nbsp;                        List&lt;LazyTypeDescription.AnnotationToken&gt; annotationTokens = (List)this.annotationTokens.get(this.index);
&nbsp;                        if (annotationTokens == null) {
&nbsp;                            annotationTokens = new ArrayList();
&nbsp;                            this.annotationTokens.put(this.index, annotationTokens);
&nbsp;                        }
&nbsp;
&nbsp;                        return (List)annotationTokens;
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public abstract static class AbstractBase implements AnnotationRegistrant {
&nbsp;                private final String descriptor;
&nbsp;                private final Map&lt;String, AnnotationValue&lt;?, ?&gt;&gt; values;
&nbsp;
&nbsp;                protected AbstractBase(String descriptor) {
&nbsp;                    this.descriptor = descriptor;
&nbsp;                    this.values = new HashMap();
&nbsp;                }
&nbsp;
&nbsp;                public void register(String name, AnnotationValue&lt;?, ?&gt; annotationValue) {
&nbsp;                    this.values.put(name, annotationValue);
&nbsp;                }
&nbsp;
&nbsp;                public void onComplete() {
&nbsp;                    this.getTokens().add(new LazyTypeDescription.AnnotationToken(this.descriptor, this.values));
&nbsp;                }
&nbsp;
&nbsp;                protected abstract List&lt;LazyTypeDescription.AnnotationToken&gt; getTokens();
&nbsp;
&nbsp;                protected abstract static class ForTypeVariable extends AbstractBase {
&nbsp;                    private final String typePath;
&nbsp;
&nbsp;                    protected ForTypeVariable(String descriptor, @Nonnull(when = When.MAYBE) TypePath typePath) {
&nbsp;                        super(descriptor);
&nbsp;                        this.typePath = typePath == null ? &quot;&quot; : typePath.toString();
&nbsp;                    }
&nbsp;
&nbsp;                    protected List&lt;LazyTypeDescription.AnnotationToken&gt; getTokens() {
&nbsp;                        Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt; pathMap = this.getPathMap();
&nbsp;                        List&lt;LazyTypeDescription.AnnotationToken&gt; tokens = (List)pathMap.get(this.typePath);
&nbsp;                        if (tokens == null) {
&nbsp;                            tokens = new ArrayList();
&nbsp;                            pathMap.put(this.typePath, tokens);
&nbsp;                        }
&nbsp;
&nbsp;                        return (List)tokens;
&nbsp;                    }
&nbsp;
&nbsp;                    protected abstract Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt; getPathMap();
&nbsp;
&nbsp;                    protected abstract static class WithIndex extends ForTypeVariable {
&nbsp;                        private final int index;
&nbsp;
&nbsp;                        protected WithIndex(String descriptor, @Nonnull(when = When.MAYBE) TypePath typePath, int index) {
&nbsp;                            super(descriptor, typePath);
&nbsp;                            this.index = index;
&nbsp;                        }
&nbsp;
&nbsp;                        protected Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt; getPathMap() {
&nbsp;                            Map&lt;Integer, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;&gt; indexedPathMap = this.getIndexedPathMap();
&nbsp;                            Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt; pathMap = (Map)indexedPathMap.get(this.index);
&nbsp;                            if (pathMap == null) {
&nbsp;                                pathMap = new HashMap();
&nbsp;                                indexedPathMap.put(this.index, pathMap);
&nbsp;                            }
&nbsp;
&nbsp;                            return (Map)pathMap;
&nbsp;                        }
&nbsp;
&nbsp;                        protected abstract Map&lt;Integer, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;&gt; getIndexedPathMap();
&nbsp;
&nbsp;                        protected abstract static class DoubleIndexed extends WithIndex {
&nbsp;                            private final int preIndex;
&nbsp;
&nbsp;                            protected DoubleIndexed(String descriptor, @Nonnull(when = When.MAYBE) TypePath typePath, int index, int preIndex) {
&nbsp;                                super(descriptor, typePath, index);
&nbsp;                                this.preIndex = preIndex;
&nbsp;                            }
&nbsp;
&nbsp;                            protected Map&lt;Integer, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;&gt; getIndexedPathMap() {
&nbsp;                                Map&lt;Integer, Map&lt;Integer, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;&gt;&gt; doubleIndexPathMap = this.getDoubleIndexedPathMap();
&nbsp;                                Map&lt;Integer, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;&gt; indexedPathMap = (Map)doubleIndexPathMap.get(this.preIndex);
&nbsp;                                if (indexedPathMap == null) {
&nbsp;                                    indexedPathMap = new HashMap();
&nbsp;                                    doubleIndexPathMap.put(this.preIndex, indexedPathMap);
&nbsp;                                }
&nbsp;
&nbsp;                                return (Map)indexedPathMap;
&nbsp;                            }
&nbsp;
&nbsp;                            protected abstract Map&lt;Integer, Map&lt;Integer, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;&gt;&gt; getDoubleIndexedPathMap();
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public static class WithLazyResolution extends Default {
&nbsp;            public WithLazyResolution(CacheProvider cacheProvider, ClassFileLocator classFileLocator, ReaderMode readerMode) {
&nbsp;                this(cacheProvider, classFileLocator, readerMode, TypePool.Empty.INSTANCE);
&nbsp;            }
&nbsp;
&nbsp;            public WithLazyResolution(CacheProvider cacheProvider, ClassFileLocator classFileLocator, ReaderMode readerMode, TypePool parentPool) {
&nbsp;                super(cacheProvider, classFileLocator, readerMode, parentPool);
&nbsp;            }
&nbsp;
&nbsp;            public static TypePool ofSystemLoader() {
&nbsp;                return of(ForClassLoader.ofSystemLoader());
&nbsp;            }
&nbsp;
&nbsp;            public static TypePool ofPlatformLoader() {
&nbsp;                return of(ForClassLoader.ofPlatformLoader());
&nbsp;            }
&nbsp;
&nbsp;            public static TypePool ofBootLoader() {
&nbsp;                return of(ForClassLoader.ofBootLoader());
&nbsp;            }
&nbsp;
&nbsp;            public static TypePool of(@Nonnull(when = When.MAYBE) ClassLoader classLoader) {
&nbsp;                return of(ForClassLoader.of(classLoader));
&nbsp;            }
&nbsp;
&nbsp;            public static TypePool of(ClassFileLocator classFileLocator) {
&nbsp;                return new WithLazyResolution(new CacheProvider.Simple(), classFileLocator, TypePool.Default.ReaderMode.FAST);
&nbsp;            }
&nbsp;
&nbsp;            protected Resolution doDescribe(String name) {
&nbsp;                return new LazyResolution(name);
&nbsp;            }
&nbsp;
&nbsp;            protected Resolution doCache(String name, Resolution resolution) {
&nbsp;                return resolution;
&nbsp;            }
&nbsp;
&nbsp;            protected Resolution doResolve(String name) {
&nbsp;                Resolution resolution = this.cacheProvider.find(name);
&nbsp;                if (resolution == null) {
&nbsp;                    resolution = this.cacheProvider.register(name, access$001(this, name));
&nbsp;                }
&nbsp;
&nbsp;                return resolution;
&nbsp;            }
&nbsp;
&nbsp;            protected class LazyTypeDescription extends TypeDescription.AbstractBase.OfSimpleType.WithDelegation {
&nbsp;                private final String name;
&nbsp;
&nbsp;                protected LazyTypeDescription(String name) {
&nbsp;                    this.name = name;
&nbsp;                }
&nbsp;
&nbsp;                public String getName() {
&nbsp;                    return this.name;
&nbsp;                }
&nbsp;
&nbsp;                @net.bytebuddy.build.CachedReturnPlugin.Enhance(&quot;delegate&quot;)
&nbsp;                protected TypeDescription delegate() {
&nbsp;                    TypeDescription var1 = this.delegate;
&nbsp;                    TypeDescription var2 = var1 != null ? null : WithLazyResolution.this.doResolve(this.name).resolve();
&nbsp;                    if (var2 == null) {
&nbsp;                        var2 = (TypeDescription)this.delegate;
&nbsp;                    } else {
&nbsp;                        this.delegate = var2;
&nbsp;                    }
&nbsp;
&nbsp;                    return var2;
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Enhance(
&nbsp;                includeSyntheticFields = true
&nbsp;            )
&nbsp;            protected class LazyResolution implements Resolution {
&nbsp;                private final String name;
&nbsp;
&nbsp;                protected LazyResolution(String name) {
&nbsp;                    this.name = name;
&nbsp;                }
&nbsp;
&nbsp;                public boolean isResolved() {
&nbsp;                    return WithLazyResolution.this.doResolve(this.name).isResolved();
&nbsp;                }
&nbsp;
&nbsp;                public TypeDescription resolve() {
&nbsp;                    return WithLazyResolution.this.new LazyTypeDescription(this.name);
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(Object var1) {
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.name.equals(((LazyResolution)var1).name)) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return WithLazyResolution.this.equals(WithLazyResolution.this);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return (this.getClass().hashCode() * 31 + this.name.hashCode()) * 31 + WithLazyResolution.this.hashCode();
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public static enum ReaderMode {
&nbsp;            EXTENDED(4),
&nbsp;            FAST(1);
&nbsp;
&nbsp;            private final int flags;
&nbsp;
&nbsp;            private ReaderMode(int flags) {
&nbsp;                this.flags = flags;
&nbsp;            }
&nbsp;
&nbsp;            protected int getFlags() {
&nbsp;                return this.flags;
&nbsp;            }
&nbsp;
&nbsp;            public boolean isExtended() {
&nbsp;                return this == EXTENDED;
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Enhance
&nbsp;    public abstract static class AbstractBase implements TypePool {
&nbsp;        protected static final Map&lt;String, TypeDescription&gt; PRIMITIVE_TYPES;
&nbsp;        protected static final Map&lt;String, String&gt; PRIMITIVE_DESCRIPTORS;
&nbsp;        private static final String ARRAY_SYMBOL = &quot;[&quot;;
&nbsp;        protected final CacheProvider cacheProvider;
&nbsp;
&nbsp;        protected AbstractBase(CacheProvider cacheProvider) {
&nbsp;            this.cacheProvider = cacheProvider;
&nbsp;        }
&nbsp;
&nbsp;        public Resolution describe(String name) {
&nbsp;            if (name.contains(&quot;/&quot;)) {
&nbsp;                throw new IllegalArgumentException(name + &quot; contains the illegal character &#39;/&#39;&quot;);
&nbsp;            } else {
&nbsp;                int arity;
&nbsp;                for(arity = 0; name.startsWith(&quot;[&quot;); name = name.substring(1)) {
&nbsp;                    ++arity;
&nbsp;                }
&nbsp;
&nbsp;                if (arity &gt; 0) {
&nbsp;                    String primitiveName = (String)PRIMITIVE_DESCRIPTORS.get(name);
&nbsp;                    name = primitiveName == null ? name.substring(1, name.length() - 1) : primitiveName;
&nbsp;                }
&nbsp;
&nbsp;                TypeDescription typeDescription = (TypeDescription)PRIMITIVE_TYPES.get(name);
&nbsp;                Resolution resolution = typeDescription == null ? this.cacheProvider.find(name) : new Resolution.Simple(typeDescription);
&nbsp;                if (resolution == null) {
&nbsp;                    resolution = this.doCache(name, this.doDescribe(name));
&nbsp;                }
&nbsp;
&nbsp;                return TypePool.AbstractBase.ArrayTypeResolution.of((Resolution)resolution, arity);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        protected Resolution doCache(String name, Resolution resolution) {
&nbsp;            return this.cacheProvider.register(name, resolution);
&nbsp;        }
&nbsp;
&nbsp;        public void clear() {
&nbsp;            this.cacheProvider.clear();
&nbsp;        }
&nbsp;
&nbsp;        protected abstract Resolution doDescribe(String var1);
&nbsp;
&nbsp;        static {
&nbsp;            Map&lt;String, TypeDescription&gt; primitiveTypes = new HashMap();
&nbsp;            Map&lt;String, String&gt; primitiveDescriptors = new HashMap();
&nbsp;            Class[] var2 = new Class[]{Boolean.TYPE, Byte.TYPE, Short.TYPE, Character.TYPE, Integer.TYPE, Long.TYPE, Float.TYPE, Double.TYPE, Void.TYPE};
&nbsp;            int var3 = var2.length;
&nbsp;
&nbsp;            for(int var4 = 0; var4 &lt; var3; ++var4) {
&nbsp;                Class&lt;?&gt; type = var2[var4];
&nbsp;                primitiveTypes.put(type.getName(), ForLoadedType.of(type));
&nbsp;                primitiveDescriptors.put(Type.getDescriptor(type), type.getName());
&nbsp;            }
&nbsp;
&nbsp;            PRIMITIVE_TYPES = Collections.unmodifiableMap(primitiveTypes);
&nbsp;            PRIMITIVE_DESCRIPTORS = Collections.unmodifiableMap(primitiveDescriptors);
&nbsp;        }
&nbsp;
&nbsp;        public boolean equals(Object var1) {
&nbsp;            if (this == var1) {
&nbsp;                return true;
&nbsp;            } else if (var1 == null) {
&nbsp;                return false;
&nbsp;            } else if (this.getClass() != var1.getClass()) {
&nbsp;                return false;
&nbsp;            } else {
&nbsp;                return this.cacheProvider.equals(((AbstractBase)var1).cacheProvider);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public int hashCode() {
&nbsp;            return this.getClass().hashCode() * 31 + this.cacheProvider.hashCode();
&nbsp;        }
&nbsp;
&nbsp;        @Enhance
&nbsp;        protected static class ArrayTypeResolution implements Resolution {
&nbsp;            private final Resolution resolution;
&nbsp;            private final int arity;
&nbsp;
&nbsp;            protected ArrayTypeResolution(Resolution resolution, int arity) {
&nbsp;                this.resolution = resolution;
&nbsp;                this.arity = arity;
&nbsp;            }
&nbsp;
&nbsp;            protected static Resolution of(Resolution resolution, int arity) {
&nbsp;                return (Resolution)(arity == 0 ? resolution : new ArrayTypeResolution(resolution, arity));
&nbsp;            }
&nbsp;
&nbsp;            public boolean isResolved() {
&nbsp;                return this.resolution.isResolved();
&nbsp;            }
&nbsp;
&nbsp;            public TypeDescription resolve() {
&nbsp;                return ArrayProjection.of(this.resolution.resolve(), this.arity);
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(Object var1) {
&nbsp;                if (this == var1) {
&nbsp;                    return true;
&nbsp;                } else if (var1 == null) {
&nbsp;                    return false;
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
&nbsp;                } else if (this.arity != ((ArrayTypeResolution)var1).arity) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return this.resolution.equals(((ArrayTypeResolution)var1).resolution);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public int hashCode() {
&nbsp;                return (this.getClass().hashCode() * 31 + this.resolution.hashCode()) * 31 + this.arity;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Enhance
&nbsp;        public abstract static class Hierarchical extends AbstractBase {
&nbsp;            private final TypePool parent;
&nbsp;
&nbsp;            protected Hierarchical(CacheProvider cacheProvider, TypePool parent) {
&nbsp;                super(cacheProvider);
&nbsp;                this.parent = parent;
&nbsp;            }
&nbsp;
&nbsp;            public Resolution describe(String name) {
&nbsp;                Resolution resolution = this.parent.describe(name);
&nbsp;                return resolution.isResolved() ? resolution : super.describe(name);
&nbsp;            }
&nbsp;
&nbsp;            public void clear() {
&nbsp;                try {
&nbsp;                    this.parent.clear();
&nbsp;                } finally {
&nbsp;                    super.clear();
&nbsp;                }
&nbsp;
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(Object var1) {
&nbsp;                if (!super.equals(var1)) {
&nbsp;                    return false;
&nbsp;                } else if (this == var1) {
&nbsp;                    return true;
&nbsp;                } else if (var1 == null) {
&nbsp;                    return false;
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return this.parent.equals(((Hierarchical)var1).parent);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public int hashCode() {
&nbsp;                return super.hashCode() * 31 + this.parent.hashCode();
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        protected interface ComponentTypeReference {
&nbsp;            @Nonnull(
&nbsp;                when = When.MAYBE
&nbsp;            )
&nbsp;            String NO_ARRAY = null;
&nbsp;
&nbsp;            @Nonnull(
&nbsp;                when = When.MAYBE
&nbsp;            )
&nbsp;            String resolve();
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static enum Empty implements TypePool {
&nbsp;        INSTANCE;
&nbsp;
&nbsp;        private Empty() {
&nbsp;        }
&nbsp;
&nbsp;        public Resolution describe(String name) {
&nbsp;            return new Resolution.Illegal(name);
&nbsp;        }
&nbsp;
&nbsp;        public void clear() {
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public interface CacheProvider {
&nbsp;        @Nonnull(
&nbsp;            when = When.MAYBE
&nbsp;        )
&nbsp;        Resolution UNRESOLVED = null;
&nbsp;
&nbsp;        @Nonnull(
&nbsp;            when = When.MAYBE
&nbsp;        )
&nbsp;        Resolution find(String var1);
&nbsp;
&nbsp;        Resolution register(String var1, Resolution var2);
&nbsp;
&nbsp;        void clear();
&nbsp;
&nbsp;        public static class Discriminating implements CacheProvider {
&nbsp;            private final ElementMatcher&lt;String&gt; matcher;
&nbsp;            private final CacheProvider matched;
&nbsp;            private final CacheProvider unmatched;
&nbsp;
&nbsp;            public Discriminating(ElementMatcher&lt;String&gt; matcher, CacheProvider matched, CacheProvider unmatched) {
&nbsp;                this.matcher = matcher;
&nbsp;                this.matched = matched;
&nbsp;                this.unmatched = unmatched;
&nbsp;            }
&nbsp;
&nbsp;            @Nonnull(
&nbsp;                when = When.MAYBE
&nbsp;            )
&nbsp;            public Resolution find(String name) {
&nbsp;                return (this.matcher.matches(name) ? this.matched : this.unmatched).find(name);
&nbsp;            }
&nbsp;
&nbsp;            public Resolution register(String name, Resolution resolution) {
&nbsp;                return (this.matcher.matches(name) ? this.matched : this.unmatched).register(name, resolution);
&nbsp;            }
&nbsp;
&nbsp;            public void clear() {
&nbsp;                try {
&nbsp;                    this.unmatched.clear();
&nbsp;                } finally {
&nbsp;                    this.matched.clear();
&nbsp;                }
&nbsp;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public static class Simple implements CacheProvider {
&nbsp;            private final ConcurrentMap&lt;String, Resolution&gt; storage;
&nbsp;
&nbsp;            public Simple() {
&nbsp;                this(new ConcurrentHashMap());
&nbsp;            }
&nbsp;
&nbsp;            public Simple(ConcurrentMap&lt;String, Resolution&gt; storage) {
&nbsp;                this.storage = storage;
&nbsp;            }
&nbsp;
&nbsp;            public static CacheProvider withObjectType() {
&nbsp;                CacheProvider cacheProvider = new Simple();
&nbsp;                cacheProvider.register(Object.class.getName(), new Resolution.Simple(TypeDescription.OBJECT));
&nbsp;                return cacheProvider;
&nbsp;            }
&nbsp;
&nbsp;            @Nonnull(
&nbsp;                when = When.MAYBE
&nbsp;            )
&nbsp;            public Resolution find(String name) {
&nbsp;                return (Resolution)this.storage.get(name);
&nbsp;            }
&nbsp;
&nbsp;            public Resolution register(String name, Resolution resolution) {
&nbsp;                Resolution cached = (Resolution)this.storage.putIfAbsent(name, resolution);
&nbsp;                return cached == null ? resolution : cached;
&nbsp;            }
&nbsp;
&nbsp;            public void clear() {
&nbsp;                this.storage.clear();
&nbsp;            }
&nbsp;
&nbsp;            public ConcurrentMap&lt;String, Resolution&gt; getStorage() {
&nbsp;                return this.storage;
&nbsp;            }
&nbsp;
&nbsp;            public static class UsingSoftReference implements CacheProvider {
&nbsp;                private final AtomicReference&lt;SoftReference&lt;Simple&gt;&gt; delegate = new AtomicReference(new SoftReference(new Simple()));
&nbsp;
&nbsp;                public UsingSoftReference() {
&nbsp;                }
&nbsp;
&nbsp;                @Nonnull(
&nbsp;                    when = When.MAYBE
&nbsp;                )
&nbsp;                public Resolution find(String name) {
&nbsp;                    CacheProvider provider = (CacheProvider)((SoftReference)this.delegate.get()).get();
&nbsp;                    return provider == null ? UNRESOLVED : provider.find(name);
&nbsp;                }
&nbsp;
&nbsp;                public Resolution register(String name, Resolution resolution) {
&nbsp;                    SoftReference&lt;Simple&gt; reference = (SoftReference)this.delegate.get();
&nbsp;                    Simple provider = (Simple)reference.get();
&nbsp;                    if (provider == null) {
&nbsp;                        provider = new Simple();
&nbsp;
&nbsp;                        while(!this.delegate.compareAndSet(reference, new SoftReference(provider))) {
&nbsp;                            reference = (SoftReference)this.delegate.get();
&nbsp;                            Simple previous = (Simple)reference.get();
&nbsp;                            if (previous != null) {
&nbsp;                                provider = previous;
&nbsp;                                break;
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    return provider.register(name, resolution);
&nbsp;                }
&nbsp;
&nbsp;                public void clear() {
&nbsp;                    CacheProvider provider = (CacheProvider)((SoftReference)this.delegate.get()).get();
&nbsp;                    if (provider != null) {
&nbsp;                        provider.clear();
&nbsp;                    }
&nbsp;
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public static enum NoOp implements CacheProvider {
&nbsp;            INSTANCE;
&nbsp;
&nbsp;            private NoOp() {
&nbsp;            }
&nbsp;
&nbsp;            @Nonnull(
&nbsp;                when = When.MAYBE
&nbsp;            )
&nbsp;            public Resolution find(String name) {
&nbsp;                return UNRESOLVED;
&nbsp;            }
&nbsp;
&nbsp;            public Resolution register(String name, Resolution resolution) {
&nbsp;                return resolution;
&nbsp;            }
&nbsp;
&nbsp;            public void clear() {
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public interface Resolution {
&nbsp;        boolean isResolved();
&nbsp;
&nbsp;        TypeDescription resolve();
&nbsp;
&nbsp;        public static class NoSuchTypeException extends IllegalStateException {
&nbsp;            private static final long serialVersionUID = 1L;
&nbsp;            private final String name;
&nbsp;
&nbsp;            public NoSuchTypeException(String name) {
&nbsp;                super(&quot;Cannot resolve type description for &quot; + name);
&nbsp;                this.name = name;
&nbsp;            }
&nbsp;
&nbsp;            public String getName() {
&nbsp;                return this.name;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Enhance
&nbsp;        public static class Illegal implements Resolution {
&nbsp;            private final String name;
&nbsp;
&nbsp;            public Illegal(String name) {
&nbsp;                this.name = name;
&nbsp;            }
&nbsp;
&nbsp;            public boolean isResolved() {
&nbsp;                return false;
&nbsp;            }
&nbsp;
&nbsp;            public TypeDescription resolve() {
&nbsp;                throw new NoSuchTypeException(this.name);
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(Object var1) {
&nbsp;                if (this == var1) {
&nbsp;                    return true;
&nbsp;                } else if (var1 == null) {
&nbsp;                    return false;
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return this.name.equals(((Illegal)var1).name);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public int hashCode() {
&nbsp;                return this.getClass().hashCode() * 31 + this.name.hashCode();
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Enhance
&nbsp;        public static class Simple implements Resolution {
&nbsp;            private final TypeDescription typeDescription;
&nbsp;
&nbsp;            public Simple(TypeDescription typeDescription) {
&nbsp;                this.typeDescription = typeDescription;
&nbsp;            }
&nbsp;
&nbsp;            public boolean isResolved() {
&nbsp;                return true;
&nbsp;            }
&nbsp;
&nbsp;            public TypeDescription resolve() {
&nbsp;                return this.typeDescription;
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(Object var1) {
&nbsp;                if (this == var1) {
&nbsp;                    return true;
&nbsp;                } else if (var1 == null) {
&nbsp;                    return false;
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return this.typeDescription.equals(((Simple)var1).typeDescription);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public int hashCode() {
&nbsp;                return this.getClass().hashCode() * 31 + this.typeDescription.hashCode();
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-22 12:49</div>
</div>
</body>
</html>
