


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=GBK"> 
  <title>Coverage Report > AnnotationValue</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.description.annotation</a>
</div>

<h1>Coverage Summary for Class: AnnotationValue (net.bytebuddy.description.annotation)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">AnnotationValue</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
</tr>
  <tr>
    <td class="name">AnnotationValue$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$ForConstant</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (22/22)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$ForConstant$PropertyDelegate$ForNonArrayType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (11/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$ForConstant$PropertyDelegate$ForNonArrayType$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$ForConstant$PropertyDelegate$ForNonArrayType$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$ForConstant$PropertyDelegate$ForNonArrayType$3</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$ForConstant$PropertyDelegate$ForNonArrayType$4</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$ForConstant$PropertyDelegate$ForNonArrayType$5</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$ForConstant$PropertyDelegate$ForNonArrayType$6</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$ForConstant$PropertyDelegate$ForNonArrayType$7</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$ForConstant$PropertyDelegate$ForNonArrayType$8</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$ForConstant$PropertyDelegate$ForNonArrayType$9</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$ForEnumerationDescription</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$ForEnumerationDescription$Loaded</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$ForTypeDescription</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$Loaded$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (66/66)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;//
&nbsp;// Source code recreated from a .class file by IntelliJ IDEA
&nbsp;// (powered by FernFlower decompiler)
&nbsp;//
&nbsp;
&nbsp;package net.bytebuddy.description.annotation;
&nbsp;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import java.lang.annotation.Annotation;
&nbsp;import java.lang.annotation.AnnotationTypeMismatchException;
&nbsp;import java.lang.annotation.IncompleteAnnotationException;
&nbsp;import java.lang.reflect.Array;
&nbsp;import java.lang.reflect.Method;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.Iterator;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import javax.annotation.CheckForNull;
&nbsp;import javax.annotation.Nonnull;
&nbsp;import javax.annotation.meta.When;
&nbsp;import net.bytebuddy.ClassFileVersion;
&nbsp;import net.bytebuddy.build.CachedReturnPlugin.Enhance;
&nbsp;import net.bytebuddy.description.enumeration.EnumerationDescription;
&nbsp;import net.bytebuddy.description.method.MethodDescription;
&nbsp;import net.bytebuddy.description.type.TypeDefinition;
&nbsp;import net.bytebuddy.description.type.TypeDescription;
&nbsp;import net.bytebuddy.description.type.TypeDescription.ForLoadedType;
&nbsp;
&nbsp;public interface AnnotationValue&lt;T, S&gt; {
&nbsp;    @Nonnull(
&nbsp;        when = When.NEVER
&nbsp;    )
&nbsp;    AnnotationValue&lt;?, ?&gt; UNDEFINED = null;
&nbsp;
&nbsp;    State getState();
&nbsp;
&nbsp;    Sort getSort();
&nbsp;
&nbsp;    AnnotationValue&lt;T, S&gt; filter(MethodDescription.InDefinedShape var1);
&nbsp;
&nbsp;    AnnotationValue&lt;T, S&gt; filter(MethodDescription.InDefinedShape var1, TypeDefinition var2);
&nbsp;
&nbsp;    T resolve();
&nbsp;
&nbsp;    &lt;W&gt; W resolve(Class&lt;? extends W&gt; var1);
&nbsp;
&nbsp;    Loaded&lt;S&gt; load(@Nonnull(when = When.MAYBE) ClassLoader var1);
&nbsp;
&nbsp;    public static class ForIncompatibleType&lt;U, V&gt; extends AbstractBase&lt;U, V&gt; {
&nbsp;        private final TypeDescription typeDescription;
&nbsp;
&nbsp;        public ForIncompatibleType(TypeDescription typeDescription) {
<b class="fc">&nbsp;            this.typeDescription = typeDescription;</b>
&nbsp;        }
&nbsp;
&nbsp;        public State getState() {
&nbsp;            return AnnotationValue.State.UNRESOLVED;
&nbsp;        }
&nbsp;
&nbsp;        public Sort getSort() {
&nbsp;            return AnnotationValue.Sort.NONE;
&nbsp;        }
&nbsp;
&nbsp;        public AnnotationValue&lt;U, V&gt; filter(MethodDescription.InDefinedShape property, TypeDefinition typeDefinition) {
&nbsp;            return this;
&nbsp;        }
&nbsp;
&nbsp;        public U resolve() {
&nbsp;            throw new IllegalStateException(&quot;Property is defined with an incompatible runtime type: &quot; + this.typeDescription);
&nbsp;        }
&nbsp;
&nbsp;        public Loaded&lt;V&gt; load(@Nonnull(when = When.MAYBE) ClassLoader classLoader) {
&nbsp;            try {
&nbsp;                return new Loaded(Class.forName(this.typeDescription.getName(), false, classLoader));
&nbsp;            } catch (ClassNotFoundException var3) {
&nbsp;                return new ForMissingType.Loaded(this.typeDescription.getName(), var3);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public String toString() {
&nbsp;            return &quot;/* Warning type incompatibility! \&quot;&quot; + this.typeDescription.getName() + &quot;\&quot; */&quot;;
&nbsp;        }
&nbsp;
&nbsp;        public static class Loaded&lt;W&gt; extends Loaded.AbstractBase.ForUnresolvedProperty&lt;W&gt; {
&nbsp;            private final Class&lt;?&gt; type;
&nbsp;
&nbsp;            public Loaded(Class&lt;?&gt; type) {
&nbsp;                this.type = type;
&nbsp;            }
&nbsp;
&nbsp;            public W resolve() {
&nbsp;                throw new IncompatibleClassChangeError(this.type.toString());
&nbsp;            }
&nbsp;
&nbsp;            public String toString() {
&nbsp;                return &quot;/* Warning type incompatibility! \&quot;&quot; + this.type.getName() + &quot;\&quot; */&quot;;
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static class ForMissingValue&lt;U, V&gt; extends AbstractBase&lt;U, V&gt; {
&nbsp;        private final TypeDescription typeDescription;
&nbsp;        private final String property;
&nbsp;
&nbsp;        public ForMissingValue(TypeDescription typeDescription, String property) {
&nbsp;            this.typeDescription = typeDescription;
&nbsp;            this.property = property;
&nbsp;        }
&nbsp;
&nbsp;        public State getState() {
&nbsp;            return AnnotationValue.State.UNDEFINED;
&nbsp;        }
&nbsp;
&nbsp;        public Sort getSort() {
&nbsp;            return AnnotationValue.Sort.NONE;
&nbsp;        }
&nbsp;
&nbsp;        public AnnotationValue&lt;U, V&gt; filter(MethodDescription.InDefinedShape property, TypeDefinition typeDefinition) {
&nbsp;            return this;
&nbsp;        }
&nbsp;
&nbsp;        public Loaded&lt;V&gt; load(@Nonnull(when = When.MAYBE) ClassLoader classLoader) {
&nbsp;            try {
&nbsp;                Class&lt;? extends Annotation&gt; type = Class.forName(this.typeDescription.getName(), false, classLoader);
&nbsp;                return (Loaded)(type.isAnnotation() ? new Loaded(type, this.property) : new ForIncompatibleType.Loaded(type));
&nbsp;            } catch (ClassNotFoundException var3) {
&nbsp;                return new ForMissingType.Loaded(this.typeDescription.getName(), var3);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public U resolve() {
&nbsp;            throw new IllegalStateException(this.typeDescription + &quot; does not define &quot; + this.property);
&nbsp;        }
&nbsp;
&nbsp;        public static class Loaded&lt;W&gt; extends Loaded.AbstractBase&lt;W&gt; {
&nbsp;            private final Class&lt;? extends Annotation&gt; type;
&nbsp;            private final String property;
&nbsp;
&nbsp;            public Loaded(Class&lt;? extends Annotation&gt; type, String property) {
&nbsp;                this.type = type;
&nbsp;                this.property = property;
&nbsp;            }
&nbsp;
&nbsp;            public State getState() {
&nbsp;                return AnnotationValue.State.UNDEFINED;
&nbsp;            }
&nbsp;
&nbsp;            public W resolve() {
&nbsp;                throw new IncompleteAnnotationException(this.type, this.property);
&nbsp;            }
&nbsp;
&nbsp;            public boolean represents(Object value) {
&nbsp;                return false;
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static class ForMismatchedType&lt;U, V&gt; extends AbstractBase&lt;U, V&gt; {
&nbsp;        private final MethodDescription.InDefinedShape property;
&nbsp;        private final String value;
&nbsp;
&nbsp;        public ForMismatchedType(MethodDescription.InDefinedShape property, String value) {
&nbsp;            this.property = property;
&nbsp;            this.value = value;
&nbsp;        }
&nbsp;
&nbsp;        public State getState() {
&nbsp;            return AnnotationValue.State.UNRESOLVED;
&nbsp;        }
&nbsp;
&nbsp;        public Sort getSort() {
&nbsp;            return AnnotationValue.Sort.NONE;
&nbsp;        }
&nbsp;
&nbsp;        public AnnotationValue&lt;U, V&gt; filter(MethodDescription.InDefinedShape property, TypeDefinition typeDefinition) {
&nbsp;            return new ForMismatchedType(property, this.value);
&nbsp;        }
&nbsp;
&nbsp;        public U resolve() {
&nbsp;            throw new IllegalStateException(this.value + &quot; cannot be used as value for &quot; + this.property);
&nbsp;        }
&nbsp;
&nbsp;        public Loaded&lt;V&gt; load(@Nonnull(when = When.MAYBE) ClassLoader classLoader) {
&nbsp;            try {
&nbsp;                Class&lt;?&gt; type = Class.forName(this.property.getDeclaringType().getName(), false, classLoader);
&nbsp;
&nbsp;                try {
&nbsp;                    return new Loaded(type.getMethod(this.property.getName()), this.value);
&nbsp;                } catch (NoSuchMethodException var4) {
&nbsp;                    return new ForIncompatibleType.Loaded(type);
&nbsp;                }
&nbsp;            } catch (ClassNotFoundException var5) {
&nbsp;                return new ForMissingType.Loaded(this.property.getDeclaringType().getName(), var5);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public String toString() {
&nbsp;            return &quot;/* Warning type mismatch! \&quot;&quot; + this.value + &quot;\&quot; */&quot;;
&nbsp;        }
&nbsp;
&nbsp;        public static class Loaded&lt;W&gt; extends Loaded.AbstractBase.ForUnresolvedProperty&lt;W&gt; {
&nbsp;            private final Method property;
&nbsp;            private final String value;
&nbsp;
&nbsp;            public Loaded(Method property, String value) {
&nbsp;                this.property = property;
&nbsp;                this.value = value;
&nbsp;            }
&nbsp;
&nbsp;            public W resolve() {
&nbsp;                throw new AnnotationTypeMismatchException(this.property, this.value);
&nbsp;            }
&nbsp;
&nbsp;            public String toString() {
&nbsp;                return &quot;/* Warning type mismatch! \&quot;&quot; + this.value + &quot;\&quot; */&quot;;
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static class ForMissingType&lt;U, V&gt; extends AbstractBase&lt;U, V&gt; {
&nbsp;        private final String typeName;
&nbsp;
&nbsp;        public ForMissingType(String typeName) {
&nbsp;            this.typeName = typeName;
&nbsp;        }
&nbsp;
&nbsp;        public State getState() {
&nbsp;            return AnnotationValue.State.UNRESOLVED;
&nbsp;        }
&nbsp;
&nbsp;        public Sort getSort() {
&nbsp;            return AnnotationValue.Sort.NONE;
&nbsp;        }
&nbsp;
&nbsp;        public AnnotationValue&lt;U, V&gt; filter(MethodDescription.InDefinedShape property, TypeDefinition typeDefinition) {
&nbsp;            return this;
&nbsp;        }
&nbsp;
&nbsp;        public U resolve() {
&nbsp;            throw new IllegalStateException(&quot;Type not found: &quot; + this.typeName);
&nbsp;        }
&nbsp;
&nbsp;        public Loaded&lt;V&gt; load(@Nonnull(when = When.MAYBE) ClassLoader classLoader) {
&nbsp;            return new Loaded(this.typeName, new ClassNotFoundException(this.typeName));
&nbsp;        }
&nbsp;
&nbsp;        public String toString() {
&nbsp;            return this.typeName + &quot;.class /* Warning: type not present! */&quot;;
&nbsp;        }
&nbsp;
&nbsp;        public static class Loaded&lt;U&gt; extends Loaded.AbstractBase.ForUnresolvedProperty&lt;U&gt; {
&nbsp;            private final String typeName;
&nbsp;            private final ClassNotFoundException exception;
&nbsp;
&nbsp;            public Loaded(String typeName, ClassNotFoundException exception) {
&nbsp;                this.typeName = typeName;
&nbsp;                this.exception = exception;
&nbsp;            }
&nbsp;
&nbsp;            public U resolve() {
&nbsp;                throw new TypeNotPresentException(this.typeName, this.exception);
&nbsp;            }
&nbsp;
&nbsp;            public String toString() {
&nbsp;                return this.typeName + &quot;.class /* Warning: type not present! */&quot;;
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static class ForDescriptionArray&lt;U, V&gt; extends AbstractBase&lt;U, V&gt; {
&nbsp;        private final Class&lt;?&gt; unloadedComponentType;
&nbsp;        private final TypeDescription componentType;
&nbsp;        private final List&lt;? extends AnnotationValue&lt;?, ?&gt;&gt; values;
&nbsp;
&nbsp;        public ForDescriptionArray(Class&lt;?&gt; unloadedComponentType, TypeDescription componentType, List&lt;? extends AnnotationValue&lt;?, ?&gt;&gt; values) {
&nbsp;            this.unloadedComponentType = unloadedComponentType;
&nbsp;            this.componentType = componentType;
&nbsp;            this.values = values;
&nbsp;        }
&nbsp;
&nbsp;        public static &lt;W extends Enum&lt;W&gt;&gt; AnnotationValue&lt;EnumerationDescription[], W[]&gt; of(TypeDescription enumerationType, EnumerationDescription[] enumerationDescription) {
&nbsp;            List&lt;AnnotationValue&lt;EnumerationDescription, W&gt;&gt; values = new ArrayList(enumerationDescription.length);
&nbsp;            EnumerationDescription[] var3 = enumerationDescription;
&nbsp;            int var4 = enumerationDescription.length;
&nbsp;
&nbsp;            for(int var5 = 0; var5 &lt; var4; ++var5) {
&nbsp;                EnumerationDescription value = var3[var5];
&nbsp;                if (!value.getEnumerationType().equals(enumerationType)) {
&nbsp;                    throw new IllegalArgumentException(value + &quot; is not of &quot; + enumerationType);
&nbsp;                }
&nbsp;
&nbsp;                values.add(AnnotationValue.ForEnumerationDescription.of(value));
&nbsp;            }
&nbsp;
&nbsp;            return new ForDescriptionArray(EnumerationDescription.class, enumerationType, values);
&nbsp;        }
&nbsp;
&nbsp;        public static &lt;W extends Annotation&gt; AnnotationValue&lt;AnnotationDescription[], W[]&gt; of(TypeDescription annotationType, AnnotationDescription[] annotationDescription) {
&nbsp;            List&lt;AnnotationValue&lt;AnnotationDescription, W&gt;&gt; values = new ArrayList(annotationDescription.length);
&nbsp;            AnnotationDescription[] var3 = annotationDescription;
&nbsp;            int var4 = annotationDescription.length;
&nbsp;
&nbsp;            for(int var5 = 0; var5 &lt; var4; ++var5) {
&nbsp;                AnnotationDescription value = var3[var5];
&nbsp;                if (!value.getAnnotationType().equals(annotationType)) {
&nbsp;                    throw new IllegalArgumentException(value + &quot; is not of &quot; + annotationType);
&nbsp;                }
&nbsp;
&nbsp;                values.add(new ForAnnotationDescription(value));
&nbsp;            }
&nbsp;
&nbsp;            return new ForDescriptionArray(AnnotationDescription.class, annotationType, values);
&nbsp;        }
&nbsp;
&nbsp;        public static AnnotationValue&lt;TypeDescription[], Class&lt;?&gt;[]&gt; of(TypeDescription[] typeDescription) {
&nbsp;            List&lt;AnnotationValue&lt;TypeDescription, Class&lt;?&gt;&gt;&gt; values = new ArrayList(typeDescription.length);
&nbsp;            TypeDescription[] var2 = typeDescription;
&nbsp;            int var3 = typeDescription.length;
&nbsp;
&nbsp;            for(int var4 = 0; var4 &lt; var3; ++var4) {
&nbsp;                TypeDescription value = var2[var4];
&nbsp;                values.add(AnnotationValue.ForTypeDescription.of(value));
&nbsp;            }
&nbsp;
&nbsp;            return new ForDescriptionArray(TypeDescription.class, TypeDescription.CLASS, values);
&nbsp;        }
&nbsp;
&nbsp;        public State getState() {
&nbsp;            return AnnotationValue.State.RESOLVED;
&nbsp;        }
&nbsp;
&nbsp;        public Sort getSort() {
&nbsp;            return AnnotationValue.Sort.ARRAY;
&nbsp;        }
&nbsp;
&nbsp;        @SuppressFBWarnings(
&nbsp;            value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;            justification = &quot;Assuming component type for array type.&quot;
&nbsp;        )
&nbsp;        public AnnotationValue&lt;U, V&gt; filter(MethodDescription.InDefinedShape property, TypeDefinition typeDefinition) {
&nbsp;            if (typeDefinition.isArray() &amp;&amp; typeDefinition.getComponentType().asErasure().equals(this.componentType)) {
&nbsp;                Iterator var3 = this.values.iterator();
&nbsp;
&nbsp;                AnnotationValue value;
&nbsp;                do {
&nbsp;                    if (!var3.hasNext()) {
&nbsp;                        return this;
&nbsp;                    }
&nbsp;
&nbsp;                    value = (AnnotationValue)var3.next();
&nbsp;                    value = value.filter(property, typeDefinition.getComponentType());
&nbsp;                } while(value.getState() == AnnotationValue.State.RESOLVED);
&nbsp;
&nbsp;                return value;
&nbsp;            } else {
&nbsp;                return new ForMismatchedType(property, AnnotationValue.RenderingDispatcher.CURRENT.toArrayErrorString(AnnotationValue.Sort.of(this.componentType)));
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public U resolve() {
&nbsp;            U resolved = Array.newInstance(this.unloadedComponentType, this.values.size());
&nbsp;            int index = 0;
&nbsp;            Iterator var3 = this.values.iterator();
&nbsp;
&nbsp;            while(var3.hasNext()) {
&nbsp;                AnnotationValue&lt;?, ?&gt; value = (AnnotationValue)var3.next();
&nbsp;                Array.set(resolved, index++, value.resolve());
&nbsp;            }
&nbsp;
&nbsp;            return resolved;
&nbsp;        }
&nbsp;
&nbsp;        public Loaded&lt;V&gt; load(@Nonnull(when = When.MAYBE) ClassLoader classLoader) {
&nbsp;            List&lt;Loaded&lt;?&gt;&gt; values = new ArrayList(this.values.size());
&nbsp;            Iterator var3 = this.values.iterator();
&nbsp;
&nbsp;            while(var3.hasNext()) {
&nbsp;                AnnotationValue&lt;?, ?&gt; value = (AnnotationValue)var3.next();
&nbsp;                values.add(value.load(classLoader));
&nbsp;            }
&nbsp;
&nbsp;            try {
&nbsp;                return new Loaded(Class.forName(this.componentType.getName(), false, classLoader), values);
&nbsp;            } catch (ClassNotFoundException var5) {
&nbsp;                return new ForMissingType.Loaded(this.componentType.getName(), var5);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Enhance(&quot;hashCode&quot;)
&nbsp;        public int hashCode() {
&nbsp;            int var1 = this.hashCode;
&nbsp;            int var10000;
&nbsp;            if (var1 != 0) {
&nbsp;                var10000 = 0;
&nbsp;            } else {
&nbsp;                int result = 1;
&nbsp;
&nbsp;                AnnotationValue value;
&nbsp;                for(Iterator var4 = this.values.iterator(); var4.hasNext(); result = 31 * result + value.hashCode()) {
&nbsp;                    value = (AnnotationValue)var4.next();
&nbsp;                }
&nbsp;
&nbsp;                var10000 = result;
&nbsp;            }
&nbsp;
&nbsp;            int var2 = var10000;
&nbsp;            if (var2 == 0) {
&nbsp;                var2 = this.hashCode;
&nbsp;            } else {
&nbsp;                this.hashCode = var2;
&nbsp;            }
&nbsp;
&nbsp;            return var2;
&nbsp;        }
&nbsp;
&nbsp;        public boolean equals(@CheckForNull Object other) {
&nbsp;            if (this == other) {
&nbsp;                return true;
&nbsp;            } else if (!(other instanceof AnnotationValue)) {
&nbsp;                return false;
&nbsp;            } else {
&nbsp;                AnnotationValue&lt;?, ?&gt; annotationValue = (AnnotationValue)other;
&nbsp;                Object value = annotationValue.resolve();
&nbsp;                if (!value.getClass().isArray()) {
&nbsp;                    return false;
&nbsp;                } else if (this.values.size() != Array.getLength(value)) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    Iterator&lt;? extends AnnotationValue&lt;?, ?&gt;&gt; iterator = this.values.iterator();
&nbsp;
&nbsp;                    for(int index = 0; index &lt; this.values.size(); ++index) {
&nbsp;                        AnnotationValue&lt;?, ?&gt; self = (AnnotationValue)iterator.next();
&nbsp;                        if (!self.resolve().equals(Array.get(value, index))) {
&nbsp;                            return false;
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    return true;
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public String toString() {
&nbsp;            return AnnotationValue.RenderingDispatcher.CURRENT.toSourceString(this.values);
&nbsp;        }
&nbsp;
&nbsp;        protected static class Loaded&lt;W&gt; extends Loaded.AbstractBase&lt;W&gt; {
&nbsp;            private final Class&lt;W&gt; componentType;
&nbsp;            private final List&lt;Loaded&lt;?&gt;&gt; values;
&nbsp;
&nbsp;            protected Loaded(Class&lt;W&gt; componentType, List&lt;Loaded&lt;?&gt;&gt; values) {
&nbsp;                this.componentType = componentType;
&nbsp;                this.values = values;
&nbsp;            }
&nbsp;
&nbsp;            public State getState() {
&nbsp;                Iterator var1 = this.values.iterator();
&nbsp;
&nbsp;                Loaded value;
&nbsp;                do {
&nbsp;                    if (!var1.hasNext()) {
&nbsp;                        return AnnotationValue.State.RESOLVED;
&nbsp;                    }
&nbsp;
&nbsp;                    value = (Loaded)var1.next();
&nbsp;                } while(value.getState().isResolved());
&nbsp;
&nbsp;                return AnnotationValue.State.UNRESOLVED;
&nbsp;            }
&nbsp;
&nbsp;            public W resolve() {
&nbsp;                W array = Array.newInstance(this.componentType, this.values.size());
&nbsp;                int index = 0;
&nbsp;                Iterator var3 = this.values.iterator();
&nbsp;
&nbsp;                while(var3.hasNext()) {
&nbsp;                    Loaded&lt;?&gt; annotationValue = (Loaded)var3.next();
&nbsp;                    Array.set(array, index++, annotationValue.resolve());
&nbsp;                }
&nbsp;
&nbsp;                return array;
&nbsp;            }
&nbsp;
&nbsp;            public boolean represents(Object value) {
&nbsp;                if (!(value instanceof Object[])) {
&nbsp;                    return false;
&nbsp;                } else if (value.getClass().getComponentType() != this.componentType) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    Object[] array = (Object[])((Object[])value);
&nbsp;                    if (this.values.size() != array.length) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        Iterator&lt;Loaded&lt;?&gt;&gt; iterator = this.values.iterator();
&nbsp;                        Object[] var4 = array;
&nbsp;                        int var5 = array.length;
&nbsp;
&nbsp;                        for(int var6 = 0; var6 &lt; var5; ++var6) {
&nbsp;                            Object aValue = var4[var6];
&nbsp;                            Loaded&lt;?&gt; self = (Loaded)iterator.next();
&nbsp;                            if (!self.represents(aValue)) {
&nbsp;                                return false;
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        return true;
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Enhance(&quot;hashCode&quot;)
&nbsp;            public int hashCode() {
&nbsp;                int var1 = this.hashCode;
&nbsp;                int var10000;
&nbsp;                if (var1 != 0) {
&nbsp;                    var10000 = 0;
&nbsp;                } else {
&nbsp;                    int result = 1;
&nbsp;
&nbsp;                    Loaded value;
&nbsp;                    for(Iterator var4 = this.values.iterator(); var4.hasNext(); result = 31 * result + value.hashCode()) {
&nbsp;                        value = (Loaded)var4.next();
&nbsp;                    }
&nbsp;
&nbsp;                    var10000 = result;
&nbsp;                }
&nbsp;
&nbsp;                int var2 = var10000;
&nbsp;                if (var2 == 0) {
&nbsp;                    var2 = this.hashCode;
&nbsp;                } else {
&nbsp;                    this.hashCode = var2;
&nbsp;                }
&nbsp;
&nbsp;                return var2;
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(@CheckForNull Object other) {
&nbsp;                if (this == other) {
&nbsp;                    return true;
&nbsp;                } else if (!(other instanceof Loaded)) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    Loaded&lt;?&gt; annotationValue = (Loaded)other;
&nbsp;                    if (!annotationValue.getState().isResolved()) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        Object value = annotationValue.resolve();
&nbsp;                        if (!(value instanceof Object[])) {
&nbsp;                            return false;
<b class="fc">&nbsp;                        } else {</b>
&nbsp;                            Object[] arrayValue = (Object[])((Object[])value);
&nbsp;                            if (this.values.size() != arrayValue.length) {
&nbsp;                                return false;
&nbsp;                            } else {
&nbsp;                                Iterator&lt;Loaded&lt;?&gt;&gt; iterator = this.values.iterator();
<b class="fc">&nbsp;                                Object[] var6 = arrayValue;</b>
&nbsp;                                int var7 = arrayValue.length;
&nbsp;
&nbsp;                                for(int var8 = 0; var8 &lt; var7; ++var8) {
&nbsp;                                    Object aValue = var6[var8];
&nbsp;                                    Loaded&lt;?&gt; self = (Loaded)iterator.next();
&nbsp;                                    if (!self.getState().isResolved() || !self.resolve().equals(aValue)) {
&nbsp;                                        return false;
&nbsp;                                    }
&nbsp;                                }
&nbsp;
&nbsp;                                return true;
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public String toString() {
&nbsp;                return AnnotationValue.RenderingDispatcher.CURRENT.toSourceString(this.values);
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static class ForTypeDescription&lt;U extends Class&lt;U&gt;&gt; extends AbstractBase&lt;TypeDescription, U&gt; {
&nbsp;        private static final boolean NO_INITIALIZATION = false;
&nbsp;        private static final Map&lt;TypeDescription, Class&lt;?&gt;&gt; PRIMITIVE_TYPES = new HashMap();
&nbsp;        private final TypeDescription typeDescription;
&nbsp;
&nbsp;        public ForTypeDescription(TypeDescription typeDescription) {
&nbsp;            this.typeDescription = typeDescription;
&nbsp;        }
&nbsp;
&nbsp;        public static &lt;V extends Class&lt;V&gt;&gt; AnnotationValue&lt;TypeDescription, V&gt; of(TypeDescription typeDescription) {
&nbsp;            return new ForTypeDescription(typeDescription);
&nbsp;        }
&nbsp;
&nbsp;        public State getState() {
&nbsp;            return AnnotationValue.State.RESOLVED;
&nbsp;        }
&nbsp;
&nbsp;        public Sort getSort() {
&nbsp;            return AnnotationValue.Sort.TYPE;
&nbsp;        }
&nbsp;
&nbsp;        public AnnotationValue&lt;TypeDescription, U&gt; filter(MethodDescription.InDefinedShape property, TypeDefinition typeDefinition) {
&nbsp;            return (AnnotationValue)(typeDefinition.asErasure().represents(Class.class) ? this : new ForMismatchedType(property, property.getReturnType().isArray() ? AnnotationValue.RenderingDispatcher.CURRENT.toArrayErrorString(AnnotationValue.Sort.TYPE) : Class.class.getName() + &#39;[&#39; + this.typeDescription.getName() + &#39;]&#39;));
&nbsp;        }
&nbsp;
&nbsp;        public TypeDescription resolve() {
&nbsp;            return this.typeDescription;
&nbsp;        }
&nbsp;
&nbsp;        public Loaded&lt;U&gt; load(@Nonnull(when = When.MAYBE) ClassLoader classLoader) {
&nbsp;            try {
&nbsp;                return new Loaded(this.typeDescription.isPrimitive() ? (Class)PRIMITIVE_TYPES.get(this.typeDescription) : Class.forName(this.typeDescription.getName(), false, classLoader));
&nbsp;            } catch (ClassNotFoundException var3) {
&nbsp;                return new ForMissingType.Loaded(this.typeDescription.getName(), var3);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public int hashCode() {
&nbsp;            return this.typeDescription.hashCode();
&nbsp;        }
&nbsp;
&nbsp;        public boolean equals(@CheckForNull Object other) {
&nbsp;            return this == other || other instanceof AnnotationValue &amp;&amp; this.typeDescription.equals(((AnnotationValue)other).resolve());
&nbsp;        }
&nbsp;
&nbsp;        public String toString() {
&nbsp;            return AnnotationValue.RenderingDispatcher.CURRENT.toSourceString(this.typeDescription);
&nbsp;        }
&nbsp;
&nbsp;        static {
&nbsp;            Class[] var0 = new Class[]{Boolean.TYPE, Byte.TYPE, Short.TYPE, Character.TYPE, Integer.TYPE, Long.TYPE, Float.TYPE, Double.TYPE, Void.TYPE};
&nbsp;            int var1 = var0.length;
&nbsp;
&nbsp;            for(int var2 = 0; var2 &lt; var1; ++var2) {
&nbsp;                Class&lt;?&gt; type = var0[var2];
&nbsp;                PRIMITIVE_TYPES.put(ForLoadedType.of(type), type);
&nbsp;            }
&nbsp;
&nbsp;        }
&nbsp;
&nbsp;        protected static class Loaded&lt;U extends Class&lt;U&gt;&gt; extends Loaded.AbstractBase&lt;U&gt; {
&nbsp;            private final U type;
&nbsp;
&nbsp;            public Loaded(U type) {
&nbsp;                this.type = type;
&nbsp;            }
&nbsp;
&nbsp;            public State getState() {
&nbsp;                return AnnotationValue.State.RESOLVED;
&nbsp;            }
&nbsp;
&nbsp;            public U resolve() {
&nbsp;                return this.type;
&nbsp;            }
&nbsp;
&nbsp;            public boolean represents(Object value) {
&nbsp;                return this.type.equals(value);
&nbsp;            }
&nbsp;
&nbsp;            public int hashCode() {
&nbsp;                return this.type.hashCode();
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(@CheckForNull Object other) {
&nbsp;                if (this == other) {
&nbsp;                    return true;
&nbsp;                } else if (!(other instanceof Loaded)) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    Loaded&lt;?&gt; annotationValue = (Loaded)other;
&nbsp;                    return annotationValue.getState().isResolved() &amp;&amp; this.type.equals(annotationValue.resolve());
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public String toString() {
&nbsp;                return AnnotationValue.RenderingDispatcher.CURRENT.toSourceString(ForLoadedType.of(this.type));
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static class ForEnumerationDescription&lt;U extends Enum&lt;U&gt;&gt; extends AbstractBase&lt;EnumerationDescription, U&gt; {
&nbsp;        private final EnumerationDescription enumerationDescription;
&nbsp;
&nbsp;        public ForEnumerationDescription(EnumerationDescription enumerationDescription) {
&nbsp;            this.enumerationDescription = enumerationDescription;
&nbsp;        }
&nbsp;
&nbsp;        public static &lt;V extends Enum&lt;V&gt;&gt; AnnotationValue&lt;EnumerationDescription, V&gt; of(EnumerationDescription value) {
&nbsp;            return new ForEnumerationDescription(value);
&nbsp;        }
&nbsp;
&nbsp;        public EnumerationDescription resolve() {
&nbsp;            return this.enumerationDescription;
&nbsp;        }
&nbsp;
&nbsp;        public State getState() {
&nbsp;            return AnnotationValue.State.RESOLVED;
&nbsp;        }
&nbsp;
&nbsp;        public Sort getSort() {
&nbsp;            return AnnotationValue.Sort.ENUMERATION;
&nbsp;        }
&nbsp;
&nbsp;        public AnnotationValue&lt;EnumerationDescription, U&gt; filter(MethodDescription.InDefinedShape property, TypeDefinition typeDefinition) {
&nbsp;            return (AnnotationValue)(typeDefinition.asErasure().equals(this.enumerationDescription.getEnumerationType()) ? this : new ForMismatchedType(property, property.getReturnType().isArray() ? AnnotationValue.RenderingDispatcher.CURRENT.toArrayErrorString(AnnotationValue.Sort.ENUMERATION) : this.enumerationDescription.getEnumerationType().getName() + &#39;.&#39; + this.enumerationDescription.getValue()));
&nbsp;        }
&nbsp;
&nbsp;        public Loaded&lt;U&gt; load(@Nonnull(when = When.MAYBE) ClassLoader classLoader) {
&nbsp;            try {
&nbsp;                return new Loaded(this.enumerationDescription.load(Class.forName(this.enumerationDescription.getEnumerationType().getName(), false, classLoader)));
&nbsp;            } catch (ClassNotFoundException var3) {
&nbsp;                return new ForMissingType.Loaded(this.enumerationDescription.getEnumerationType().getName(), var3);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public int hashCode() {
&nbsp;            return this.enumerationDescription.hashCode();
&nbsp;        }
&nbsp;
&nbsp;        public boolean equals(@CheckForNull Object other) {
&nbsp;            return this == other || other instanceof AnnotationValue &amp;&amp; this.enumerationDescription.equals(((AnnotationValue)other).resolve());
&nbsp;        }
&nbsp;
&nbsp;        public String toString() {
&nbsp;            return this.enumerationDescription.toString();
&nbsp;        }
&nbsp;
&nbsp;        public static class WithUnknownConstant&lt;U extends Enum&lt;U&gt;&gt; extends AbstractBase&lt;EnumerationDescription, U&gt; {
&nbsp;            private final TypeDescription typeDescription;
&nbsp;            private final String value;
&nbsp;
&nbsp;            public WithUnknownConstant(TypeDescription typeDescription, String value) {
&nbsp;                this.typeDescription = typeDescription;
&nbsp;                this.value = value;
&nbsp;            }
&nbsp;
&nbsp;            public State getState() {
&nbsp;                return AnnotationValue.State.UNRESOLVED;
&nbsp;            }
&nbsp;
&nbsp;            public Sort getSort() {
&nbsp;                return AnnotationValue.Sort.NONE;
&nbsp;            }
&nbsp;
&nbsp;            public AnnotationValue&lt;EnumerationDescription, U&gt; filter(MethodDescription.InDefinedShape property, TypeDefinition typeDefinition) {
&nbsp;                return this;
&nbsp;            }
&nbsp;
&nbsp;            public EnumerationDescription resolve() {
&nbsp;                throw new IllegalStateException(this.typeDescription + &quot; does not declare enumeration constant &quot; + this.value);
&nbsp;            }
&nbsp;
&nbsp;            public Loaded&lt;U&gt; load(@Nonnull(when = When.MAYBE) ClassLoader classLoader) {
&nbsp;                try {
&nbsp;                    return (Loaded)(new Loaded(Class.forName(this.typeDescription.getName(), false, classLoader), this.value));
&nbsp;                } catch (ClassNotFoundException var3) {
&nbsp;                    return new ForMissingType.Loaded(this.typeDescription.getName(), var3);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public String toString() {
&nbsp;                return this.value + &quot; /* Warning: constant not present! */&quot;;
&nbsp;            }
&nbsp;
&nbsp;            public static class Loaded extends Loaded.AbstractBase.ForUnresolvedProperty&lt;Enum&lt;?&gt;&gt; {
&nbsp;                private final Class&lt;? extends Enum&lt;?&gt;&gt; enumType;
&nbsp;                private final String value;
&nbsp;
&nbsp;                public Loaded(Class&lt;? extends Enum&lt;?&gt;&gt; enumType, String value) {
&nbsp;                    this.enumType = enumType;
&nbsp;                    this.value = value;
&nbsp;                }
&nbsp;
&nbsp;                public Enum&lt;?&gt; resolve() {
&nbsp;                    throw new EnumConstantNotPresentException(this.enumType, this.value);
&nbsp;                }
&nbsp;
&nbsp;                public String toString() {
<b class="fc">&nbsp;                    return this.value + &quot; /* Warning: constant not present! */&quot;;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public static class Loaded&lt;V extends Enum&lt;V&gt;&gt; extends Loaded.AbstractBase&lt;V&gt; {
<b class="fc">&nbsp;            private final V enumeration;</b>
&nbsp;
&nbsp;            public Loaded(V enumeration) {
&nbsp;                this.enumeration = enumeration;
&nbsp;            }
&nbsp;
&nbsp;            public State getState() {
<b class="fc">&nbsp;                return AnnotationValue.State.RESOLVED;</b>
&nbsp;            }
&nbsp;
&nbsp;            public V resolve() {
&nbsp;                return this.enumeration;
&nbsp;            }
&nbsp;
&nbsp;            public boolean represents(Object value) {
&nbsp;                return this.enumeration.equals(value);
&nbsp;            }
&nbsp;
&nbsp;            public int hashCode() {
&nbsp;                return this.enumeration.hashCode();
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(@CheckForNull Object other) {
&nbsp;                if (this == other) {
&nbsp;                    return true;
&nbsp;                } else if (!(other instanceof Loaded)) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    Loaded&lt;?&gt; annotationValue = (Loaded)other;
&nbsp;                    return annotationValue.getState().isResolved() &amp;&amp; this.enumeration.equals(annotationValue.resolve());
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public String toString() {
<b class="fc">&nbsp;                return this.enumeration.toString();</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;</b>
&nbsp;            public static class WithIncompatibleRuntimeType extends Loaded.AbstractBase&lt;Enum&lt;?&gt;&gt; {
&nbsp;                private final Class&lt;?&gt; type;
&nbsp;
&nbsp;                public WithIncompatibleRuntimeType(Class&lt;?&gt; type) {
&nbsp;                    this.type = type;
&nbsp;                }
&nbsp;
&nbsp;                public State getState() {
&nbsp;                    return AnnotationValue.State.UNRESOLVED;
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                public Enum&lt;?&gt; resolve() {
&nbsp;                    throw new IncompatibleClassChangeError(&quot;Not an enumeration type: &quot; + this.type.getName());
&nbsp;                }
&nbsp;
&nbsp;                public boolean represents(Object value) {
&nbsp;                    return false;
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static class ForAnnotationDescription&lt;U extends Annotation&gt; extends AbstractBase&lt;AnnotationDescription, U&gt; {
&nbsp;        private final AnnotationDescription annotationDescription;
&nbsp;
&nbsp;        public ForAnnotationDescription(AnnotationDescription annotationDescription) {
&nbsp;            this.annotationDescription = annotationDescription;
&nbsp;        }
&nbsp;
&nbsp;        public static &lt;V extends Annotation&gt; AnnotationValue&lt;AnnotationDescription, V&gt; of(TypeDescription annotationType, Map&lt;String, ? extends AnnotationValue&lt;?, ?&gt;&gt; annotationValues) {
&nbsp;            return new ForAnnotationDescription(new AnnotationDescription.Latent(annotationType, annotationValues));
&nbsp;        }
&nbsp;
&nbsp;        public State getState() {
&nbsp;            return AnnotationValue.State.RESOLVED;
&nbsp;        }
&nbsp;
&nbsp;        public Sort getSort() {
&nbsp;            return AnnotationValue.Sort.ANNOTATION;
&nbsp;        }
&nbsp;
&nbsp;        public AnnotationValue&lt;AnnotationDescription, U&gt; filter(MethodDescription.InDefinedShape property, TypeDefinition typeDefinition) {
&nbsp;            return (AnnotationValue)(typeDefinition.asErasure().equals(this.annotationDescription.getAnnotationType()) ? this : new ForMismatchedType(property, property.getReturnType().isArray() ? AnnotationValue.RenderingDispatcher.CURRENT.toArrayErrorString(AnnotationValue.Sort.ANNOTATION) : this.annotationDescription.toString()));
&nbsp;        }
&nbsp;
&nbsp;        public AnnotationDescription resolve() {
&nbsp;            return this.annotationDescription;
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        public Loaded&lt;U&gt; load(@Nonnull(when = When.MAYBE) ClassLoader classLoader) {</b>
&nbsp;            try {
&nbsp;                return new Loaded(this.annotationDescription.prepare(Class.forName(this.annotationDescription.getAnnotationType().getName(), false, classLoader)).load());
&nbsp;            } catch (ClassNotFoundException var3) {
&nbsp;                return new ForMissingType.Loaded(this.annotationDescription.getAnnotationType().getName(), var3);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public int hashCode() {
&nbsp;            return this.annotationDescription.hashCode();
&nbsp;        }
&nbsp;
&nbsp;        public boolean equals(@CheckForNull Object other) {
&nbsp;            return this == other || other instanceof AnnotationValue &amp;&amp; this.annotationDescription.equals(((AnnotationValue)other).resolve());
&nbsp;        }
&nbsp;
&nbsp;        public String toString() {
&nbsp;            return this.annotationDescription.toString();
&nbsp;        }
&nbsp;
&nbsp;        public static class Loaded&lt;V extends Annotation&gt; extends Loaded.AbstractBase&lt;V&gt; {
&nbsp;            private final V annotation;
&nbsp;
&nbsp;            public Loaded(V annotation) {
&nbsp;                this.annotation = annotation;
&nbsp;            }
&nbsp;
&nbsp;            public State getState() {
&nbsp;                return AnnotationValue.State.RESOLVED;
&nbsp;            }
&nbsp;
&nbsp;            public V resolve() {
&nbsp;                return this.annotation;
&nbsp;            }
&nbsp;
&nbsp;            public boolean represents(Object value) {
&nbsp;                return this.annotation.equals(value);
&nbsp;            }
&nbsp;
&nbsp;            public int hashCode() {
<b class="fc">&nbsp;                return this.annotation.hashCode();</b>
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(@CheckForNull Object other) {
&nbsp;                if (this == other) {
&nbsp;                    return true;
&nbsp;                } else if (!(other instanceof Loaded)) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    Loaded&lt;?&gt; annotationValue = (Loaded)other;
&nbsp;                    return annotationValue.getState().isResolved() &amp;&amp; this.annotation.equals(annotationValue.resolve());
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public String toString() {
&nbsp;                return this.annotation.toString();
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static class ForConstant&lt;U&gt; extends AbstractBase&lt;U, U&gt; {
&nbsp;        private final U value;
&nbsp;        private final PropertyDelegate propertyDelegate;
&nbsp;
&nbsp;        protected ForConstant(U value, PropertyDelegate propertyDelegate) {
&nbsp;            this.value = value;
&nbsp;            this.propertyDelegate = propertyDelegate;
&nbsp;        }
&nbsp;
&nbsp;        public static AnnotationValue&lt;Boolean, Boolean&gt; of(boolean value) {
&nbsp;            return new ForConstant(value, AnnotationValue.ForConstant.PropertyDelegate.ForNonArrayType.BOOLEAN);
&nbsp;        }
&nbsp;
&nbsp;        public static AnnotationValue&lt;Byte, Byte&gt; of(byte value) {
&nbsp;            return new ForConstant(value, AnnotationValue.ForConstant.PropertyDelegate.ForNonArrayType.BYTE);
&nbsp;        }
&nbsp;
&nbsp;        public static AnnotationValue&lt;Short, Short&gt; of(short value) {
&nbsp;            return new ForConstant(value, AnnotationValue.ForConstant.PropertyDelegate.ForNonArrayType.SHORT);
&nbsp;        }
&nbsp;
&nbsp;        public static AnnotationValue&lt;Character, Character&gt; of(char value) {
&nbsp;            return new ForConstant(value, AnnotationValue.ForConstant.PropertyDelegate.ForNonArrayType.CHARACTER);
&nbsp;        }
&nbsp;
&nbsp;        public static AnnotationValue&lt;Integer, Integer&gt; of(int value) {
&nbsp;            return new ForConstant(value, AnnotationValue.ForConstant.PropertyDelegate.ForNonArrayType.INTEGER);
&nbsp;        }
&nbsp;
&nbsp;        public static AnnotationValue&lt;Long, Long&gt; of(long value) {
&nbsp;            return new ForConstant(value, AnnotationValue.ForConstant.PropertyDelegate.ForNonArrayType.LONG);
&nbsp;        }
&nbsp;
&nbsp;        public static AnnotationValue&lt;Float, Float&gt; of(float value) {
&nbsp;            return new ForConstant(value, AnnotationValue.ForConstant.PropertyDelegate.ForNonArrayType.FLOAT);
&nbsp;        }
&nbsp;
&nbsp;        public static AnnotationValue&lt;Double, Double&gt; of(double value) {
&nbsp;            return new ForConstant(value, AnnotationValue.ForConstant.PropertyDelegate.ForNonArrayType.DOUBLE);
&nbsp;        }
&nbsp;
&nbsp;        public static AnnotationValue&lt;String, String&gt; of(String value) {
&nbsp;            return new ForConstant(value, AnnotationValue.ForConstant.PropertyDelegate.ForNonArrayType.STRING);
&nbsp;        }
&nbsp;
&nbsp;        public static AnnotationValue&lt;boolean[], boolean[]&gt; of(boolean... value) {
&nbsp;            return new ForConstant(value, AnnotationValue.ForConstant.PropertyDelegate.ForArrayType.BOOLEAN);
&nbsp;        }
&nbsp;
&nbsp;        public static AnnotationValue&lt;byte[], byte[]&gt; of(byte... value) {
&nbsp;            return new ForConstant(value, AnnotationValue.ForConstant.PropertyDelegate.ForArrayType.BYTE);
&nbsp;        }
&nbsp;
&nbsp;        public static AnnotationValue&lt;short[], short[]&gt; of(short... value) {
&nbsp;            return new ForConstant(value, AnnotationValue.ForConstant.PropertyDelegate.ForArrayType.SHORT);
&nbsp;        }
&nbsp;
&nbsp;        public static AnnotationValue&lt;char[], char[]&gt; of(char... value) {
&nbsp;            return new ForConstant(value, AnnotationValue.ForConstant.PropertyDelegate.ForArrayType.CHARACTER);
&nbsp;        }
&nbsp;
&nbsp;        public static AnnotationValue&lt;int[], int[]&gt; of(int... value) {
&nbsp;            return new ForConstant(value, AnnotationValue.ForConstant.PropertyDelegate.ForArrayType.INTEGER);
&nbsp;        }
&nbsp;
&nbsp;        public static AnnotationValue&lt;long[], long[]&gt; of(long... value) {
&nbsp;            return new ForConstant(value, AnnotationValue.ForConstant.PropertyDelegate.ForArrayType.LONG);
&nbsp;        }
&nbsp;
&nbsp;        public static AnnotationValue&lt;float[], float[]&gt; of(float... value) {
&nbsp;            return new ForConstant(value, AnnotationValue.ForConstant.PropertyDelegate.ForArrayType.FLOAT);
&nbsp;        }
&nbsp;
&nbsp;        public static AnnotationValue&lt;double[], double[]&gt; of(double... value) {
&nbsp;            return new ForConstant(value, AnnotationValue.ForConstant.PropertyDelegate.ForArrayType.DOUBLE);
&nbsp;        }
&nbsp;
&nbsp;        public static AnnotationValue&lt;String[], String[]&gt; of(String... value) {
&nbsp;            return new ForConstant(value, AnnotationValue.ForConstant.PropertyDelegate.ForArrayType.STRING);
&nbsp;        }
&nbsp;
&nbsp;        public static AnnotationValue&lt;?, ?&gt; of(Object value) {
<b class="fc">&nbsp;            if (value instanceof Boolean) {</b>
<b class="fc">&nbsp;                return of((Boolean)value);</b>
<b class="fc">&nbsp;            } else if (value instanceof Byte) {</b>
&nbsp;                return of((Byte)value);
<b class="fc">&nbsp;            } else if (value instanceof Short) {</b>
&nbsp;                return of((Short)value);
<b class="fc">&nbsp;            } else if (value instanceof Character) {</b>
&nbsp;                return of((Character)value);
<b class="fc">&nbsp;            } else if (value instanceof Integer) {</b>
<b class="fc">&nbsp;                return of((Integer)value);</b>
<b class="fc">&nbsp;            } else if (value instanceof Long) {</b>
&nbsp;                return of((Long)value);
<b class="fc">&nbsp;            } else if (value instanceof Float) {</b>
&nbsp;                return of((Float)value);
<b class="fc">&nbsp;            } else if (value instanceof Double) {</b>
&nbsp;                return of((Double)value);
<b class="fc">&nbsp;            } else if (value instanceof String) {</b>
<b class="fc">&nbsp;                return of((String)value);</b>
&nbsp;            } else if (value instanceof boolean[]) {
&nbsp;                return of((boolean[])((boolean[])value));
&nbsp;            } else if (value instanceof byte[]) {
&nbsp;                return of((byte[])((byte[])value));
&nbsp;            } else if (value instanceof short[]) {
&nbsp;                return of((short[])((short[])value));
&nbsp;            } else if (value instanceof char[]) {
&nbsp;                return of((char[])((char[])value));
&nbsp;            } else if (value instanceof int[]) {
&nbsp;                return of((int[])((int[])value));
&nbsp;            } else if (value instanceof long[]) {
&nbsp;                return of((long[])((long[])value));
&nbsp;            } else if (value instanceof float[]) {
&nbsp;                return of((float[])((float[])value));
&nbsp;            } else if (value instanceof double[]) {
&nbsp;                return of((double[])((double[])value));
&nbsp;            } else if (value instanceof String[]) {
&nbsp;                return of((String[])((String[])value));
&nbsp;            } else {
&nbsp;                throw new IllegalArgumentException(&quot;Not a constant annotation value: &quot; + value);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public State getState() {
&nbsp;            return AnnotationValue.State.RESOLVED;
&nbsp;        }
&nbsp;
&nbsp;        public Sort getSort() {
&nbsp;            return AnnotationValue.Sort.of(ForLoadedType.of(this.value.getClass()).asUnboxed());
&nbsp;        }
&nbsp;
&nbsp;        public AnnotationValue&lt;U, U&gt; filter(MethodDescription.InDefinedShape property, TypeDefinition typeDefinition) {
&nbsp;            if (typeDefinition.asErasure().asBoxed().represents(this.value.getClass())) {
&nbsp;                return this;
&nbsp;            } else if (this.value.getClass().isArray()) {
&nbsp;                return new ForMismatchedType(property, AnnotationValue.RenderingDispatcher.CURRENT.toArrayErrorString(AnnotationValue.Sort.of(ForLoadedType.of(this.value.getClass().getComponentType()))));
&nbsp;            } else {
&nbsp;                return this.value instanceof Enum ? new ForMismatchedType(property, this.value.getClass().getName() + &#39;.&#39; + ((Enum)this.value).name()) : new ForMismatchedType(property, AnnotationValue.RenderingDispatcher.CURRENT.toTypeErrorString(this.value.getClass()) + &#39;[&#39; + this.value + &#39;]&#39;);
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        public U resolve() {</b>
<b class="fc">&nbsp;            return this.value;</b>
&nbsp;        }
&nbsp;
&nbsp;        public Loaded&lt;U&gt; load(@Nonnull(when = When.MAYBE) ClassLoader classLoader) {
&nbsp;            return new Loaded(this.value, this.propertyDelegate);
&nbsp;        }
&nbsp;
&nbsp;        @Enhance(&quot;hashCode&quot;)
&nbsp;        public int hashCode() {
&nbsp;            int var1 = this.hashCode;
&nbsp;            int var2 = var1 != 0 ? 0 : this.propertyDelegate.hashCode(this.value);
&nbsp;            if (var2 == 0) {
&nbsp;                var2 = this.hashCode;
&nbsp;            } else {
<b class="fc">&nbsp;                this.hashCode = var2;</b>
&nbsp;            }
&nbsp;
&nbsp;            return var2;
&nbsp;        }
&nbsp;
&nbsp;        public boolean equals(@CheckForNull Object other) {
&nbsp;            return this == other || other instanceof AnnotationValue &amp;&amp; this.propertyDelegate.equals(this.value, ((AnnotationValue)other).resolve());
&nbsp;        }
&nbsp;
&nbsp;        public String toString() {
&nbsp;            return this.propertyDelegate.toString(this.value);
&nbsp;        }
<b class="fc">&nbsp;</b>
&nbsp;        protected static class Loaded&lt;V&gt; extends Loaded.AbstractBase&lt;V&gt; {
&nbsp;            private final V value;
&nbsp;            private final PropertyDelegate propertyDelegate;
&nbsp;
&nbsp;            protected Loaded(V value, PropertyDelegate propertyDelegate) {
&nbsp;                this.value = value;
&nbsp;                this.propertyDelegate = propertyDelegate;
&nbsp;            }
&nbsp;
&nbsp;            public State getState() {
&nbsp;                return AnnotationValue.State.RESOLVED;
&nbsp;            }
&nbsp;
&nbsp;            public V resolve() {
&nbsp;                return this.propertyDelegate.copy(this.value);
&nbsp;            }
&nbsp;
&nbsp;            public boolean represents(Object value) {
&nbsp;                return this.propertyDelegate.equals(this.value, value);
&nbsp;            }
&nbsp;
&nbsp;            @Enhance(&quot;hashCode&quot;)
&nbsp;            public int hashCode() {
&nbsp;                int var1 = this.hashCode;
&nbsp;                int var2 = var1 != 0 ? 0 : this.propertyDelegate.hashCode(this.value);
&nbsp;                if (var2 == 0) {
&nbsp;                    var2 = this.hashCode;
&nbsp;                } else {
&nbsp;                    this.hashCode = var2;
&nbsp;                }
&nbsp;
&nbsp;                return var2;
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(@CheckForNull Object other) {
&nbsp;                if (this == other) {
&nbsp;                    return true;
&nbsp;                } else if (!(other instanceof Loaded)) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    Loaded&lt;?&gt; annotationValue = (Loaded)other;
&nbsp;                    return annotationValue.getState().isResolved() &amp;&amp; this.propertyDelegate.equals(this.value, annotationValue.resolve());
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public String toString() {
&nbsp;                return this.propertyDelegate.toString(this.value);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        protected interface PropertyDelegate {
&nbsp;            &lt;S&gt; S copy(S var1);
&nbsp;
&nbsp;            int hashCode(Object var1);
<b class="fc">&nbsp;</b>
&nbsp;            boolean equals(Object var1, Object var2);
&nbsp;
&nbsp;            String toString(Object var1);
&nbsp;
<b class="fc">&nbsp;            public static enum ForArrayType implements PropertyDelegate {</b>
&nbsp;                BOOLEAN {
&nbsp;                    protected Object doCopy(Object value) {
&nbsp;                        return ((boolean[])((boolean[])value)).clone();
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode(Object value) {
&nbsp;                        return Arrays.hashCode((boolean[])((boolean[])value));
&nbsp;                    }
&nbsp;
<b class="fc">&nbsp;                    public boolean equals(Object self, Object other) {</b>
&nbsp;                        return other instanceof boolean[] &amp;&amp; Arrays.equals((boolean[])((boolean[])self), (boolean[])((boolean[])other));
&nbsp;                    }
&nbsp;
&nbsp;                    protected String toString(Object array, int index) {
&nbsp;                        return AnnotationValue.ForConstant.PropertyDelegate.ForNonArrayType.BOOLEAN.toString(Array.getBoolean(array, index));
&nbsp;                    }
&nbsp;                },
&nbsp;                BYTE {
&nbsp;                    protected Object doCopy(Object value) {
<b class="fc">&nbsp;                        return ((byte[])((byte[])value)).clone();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode(Object value) {
&nbsp;                        return Arrays.hashCode((byte[])((byte[])value));
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(Object self, Object other) {
&nbsp;                        return other instanceof byte[] &amp;&amp; Arrays.equals((byte[])((byte[])self), (byte[])((byte[])other));
&nbsp;                    }
<b class="fc">&nbsp;</b>
&nbsp;                    protected String toString(Object array, int index) {
&nbsp;                        return AnnotationValue.ForConstant.PropertyDelegate.ForNonArrayType.BYTE.toString(Array.getByte(array, index));
&nbsp;                    }
&nbsp;                },
&nbsp;                SHORT {
&nbsp;                    protected Object doCopy(Object value) {
&nbsp;                        return ((short[])((short[])value)).clone();
&nbsp;                    }
&nbsp;
<b class="fc">&nbsp;                    public int hashCode(Object value) {</b>
&nbsp;                        return Arrays.hashCode((short[])((short[])value));
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(Object self, Object other) {
&nbsp;                        return other instanceof short[] &amp;&amp; Arrays.equals((short[])((short[])self), (short[])((short[])other));
&nbsp;                    }
&nbsp;
&nbsp;                    protected String toString(Object array, int index) {
&nbsp;                        return AnnotationValue.ForConstant.PropertyDelegate.ForNonArrayType.SHORT.toString(Array.getShort(array, index));
<b class="fc">&nbsp;                    }</b>
&nbsp;                },
&nbsp;                CHARACTER {
&nbsp;                    protected Object doCopy(Object value) {
&nbsp;                        return ((char[])((char[])value)).clone();
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode(Object value) {
&nbsp;                        return Arrays.hashCode((char[])((char[])value));
&nbsp;                    }
<b class="fc">&nbsp;</b>
&nbsp;                    public boolean equals(Object self, Object other) {
&nbsp;                        return other instanceof char[] &amp;&amp; Arrays.equals((char[])((char[])self), (char[])((char[])other));
&nbsp;                    }
&nbsp;
&nbsp;                    protected String toString(Object array, int index) {
&nbsp;                        return AnnotationValue.ForConstant.PropertyDelegate.ForNonArrayType.CHARACTER.toString(Array.getChar(array, index));
&nbsp;                    }
&nbsp;                },
&nbsp;                INTEGER {
<b class="fc">&nbsp;                    protected Object doCopy(Object value) {</b>
&nbsp;                        return ((int[])((int[])value)).clone();
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode(Object value) {
&nbsp;                        return Arrays.hashCode((int[])((int[])value));
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(Object self, Object other) {
&nbsp;                        return other instanceof int[] &amp;&amp; Arrays.equals((int[])((int[])self), (int[])((int[])other));
<b class="fc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    protected String toString(Object array, int index) {
&nbsp;                        return AnnotationValue.ForConstant.PropertyDelegate.ForNonArrayType.INTEGER.toString(Array.getInt(array, index));
&nbsp;                    }
&nbsp;                },
&nbsp;                LONG {
&nbsp;                    protected Object doCopy(Object value) {
&nbsp;                        return ((long[])((long[])value)).clone();
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode(Object value) {
&nbsp;                        return Arrays.hashCode((long[])((long[])value));
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(Object self, Object other) {
&nbsp;                        return other instanceof long[] &amp;&amp; Arrays.equals((long[])((long[])self), (long[])((long[])other));
&nbsp;                    }
<b class="fc">&nbsp;</b>
&nbsp;                    protected String toString(Object array, int index) {
&nbsp;                        return AnnotationValue.ForConstant.PropertyDelegate.ForNonArrayType.LONG.toString(Array.getLong(array, index));
&nbsp;                    }
&nbsp;                },
&nbsp;                FLOAT {
&nbsp;                    protected Object doCopy(Object value) {
&nbsp;                        return ((float[])((float[])value)).clone();
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode(Object value) {
&nbsp;                        return Arrays.hashCode((float[])((float[])value));
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(Object self, Object other) {
&nbsp;                        return other instanceof float[] &amp;&amp; Arrays.equals((float[])((float[])self), (float[])((float[])other));
&nbsp;                    }
&nbsp;
&nbsp;                    protected String toString(Object array, int index) {
&nbsp;                        return AnnotationValue.ForConstant.PropertyDelegate.ForNonArrayType.FLOAT.toString(Array.getFloat(array, index));
&nbsp;                    }
&nbsp;                },
&nbsp;                DOUBLE {
&nbsp;                    protected Object doCopy(Object value) {
&nbsp;                        return ((double[])((double[])value)).clone();
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode(Object value) {
&nbsp;                        return Arrays.hashCode((double[])((double[])value));
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(Object self, Object other) {
&nbsp;                        return other instanceof double[] &amp;&amp; Arrays.equals((double[])((double[])self), (double[])((double[])other));
&nbsp;                    }
&nbsp;
&nbsp;                    protected String toString(Object array, int index) {
&nbsp;                        return AnnotationValue.ForConstant.PropertyDelegate.ForNonArrayType.DOUBLE.toString(Array.getDouble(array, index));
&nbsp;                    }
&nbsp;                },
&nbsp;                STRING {
&nbsp;                    protected Object doCopy(Object value) {
&nbsp;                        return ((String[])((String[])value)).clone();
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode(Object value) {
&nbsp;                        return Arrays.hashCode((String[])((String[])value));
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(Object self, Object other) {
&nbsp;                        return other instanceof String[] &amp;&amp; Arrays.equals((String[])((String[])self), (String[])((String[])other));
&nbsp;                    }
&nbsp;
&nbsp;                    protected String toString(Object array, int index) {
&nbsp;                        return AnnotationValue.ForConstant.PropertyDelegate.ForNonArrayType.STRING.toString(Array.get(array, index));
&nbsp;                    }
&nbsp;                };
&nbsp;
&nbsp;                private ForArrayType() {
&nbsp;                }
&nbsp;
&nbsp;                public &lt;S&gt; S copy(S value) {
&nbsp;                    return this.doCopy(value);
&nbsp;                }
&nbsp;
&nbsp;                protected abstract Object doCopy(Object var1);
&nbsp;
&nbsp;                public String toString(Object value) {
&nbsp;                    List&lt;String&gt; elements = new ArrayList(Array.getLength(value));
&nbsp;
&nbsp;                    for(int index = 0; index &lt; Array.getLength(value); ++index) {
&nbsp;                        elements.add(this.toString(value, index));
&nbsp;                    }
&nbsp;
&nbsp;                    return AnnotationValue.RenderingDispatcher.CURRENT.toSourceString((List)elements);
&nbsp;                }
&nbsp;
&nbsp;                protected abstract String toString(Object var1, int var2);
&nbsp;            }
&nbsp;
&nbsp;            public static enum ForNonArrayType implements PropertyDelegate {
&nbsp;                BOOLEAN {
&nbsp;                    public String toString(Object value) {
&nbsp;                        return AnnotationValue.RenderingDispatcher.CURRENT.toSourceString((Boolean)value);
&nbsp;                    }
&nbsp;                },
&nbsp;                BYTE {
&nbsp;                    public String toString(Object value) {
&nbsp;                        return AnnotationValue.RenderingDispatcher.CURRENT.toSourceString((Byte)value);
&nbsp;                    }
&nbsp;                },
&nbsp;                SHORT {
&nbsp;                    public String toString(Object value) {
&nbsp;                        return AnnotationValue.RenderingDispatcher.CURRENT.toSourceString((Short)value);
&nbsp;                    }
&nbsp;                },
&nbsp;                CHARACTER {
&nbsp;                    public String toString(Object value) {
&nbsp;                        return AnnotationValue.RenderingDispatcher.CURRENT.toSourceString((Character)value);
&nbsp;                    }
&nbsp;                },
&nbsp;                INTEGER {
&nbsp;                    public String toString(Object value) {
&nbsp;                        return AnnotationValue.RenderingDispatcher.CURRENT.toSourceString((Integer)value);
&nbsp;                    }
&nbsp;                },
&nbsp;                LONG {
&nbsp;                    public String toString(Object value) {
&nbsp;                        return AnnotationValue.RenderingDispatcher.CURRENT.toSourceString((Long)value);
&nbsp;                    }
&nbsp;                },
&nbsp;                FLOAT {
&nbsp;                    public String toString(Object value) {
&nbsp;                        return AnnotationValue.RenderingDispatcher.CURRENT.toSourceString((Float)value);
&nbsp;                    }
&nbsp;                },
&nbsp;                DOUBLE {
&nbsp;                    public String toString(Object value) {
&nbsp;                        return AnnotationValue.RenderingDispatcher.CURRENT.toSourceString((Double)value);
&nbsp;                    }
&nbsp;                },
&nbsp;                STRING {
&nbsp;                    public String toString(Object value) {
&nbsp;                        return AnnotationValue.RenderingDispatcher.CURRENT.toSourceString((String)value);
&nbsp;                    }
&nbsp;                };
&nbsp;
&nbsp;                private ForNonArrayType() {
&nbsp;                }
&nbsp;
&nbsp;                public &lt;S&gt; S copy(S value) {
&nbsp;                    return value;
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode(Object value) {
&nbsp;                    return value.hashCode();
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(Object self, Object other) {
&nbsp;                    return self.equals(other);
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public abstract static class AbstractBase&lt;U, V&gt; implements AnnotationValue&lt;U, V&gt; {
&nbsp;        public AbstractBase() {
&nbsp;        }
&nbsp;
&nbsp;        public &lt;W&gt; W resolve(Class&lt;? extends W&gt; type) {
&nbsp;            return type.cast(this.resolve());
&nbsp;        }
&nbsp;
&nbsp;        public AnnotationValue&lt;U, V&gt; filter(MethodDescription.InDefinedShape property) {
&nbsp;            return this.filter(property, property.getReturnType());
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static enum Sort {
&nbsp;        BOOLEAN(90),
&nbsp;        BYTE(66),
&nbsp;        SHORT(83),
&nbsp;        CHARACTER(67),
&nbsp;        INTEGER(73),
&nbsp;        LONG(74),
&nbsp;        FLOAT(70),
&nbsp;        DOUBLE(68),
&nbsp;        STRING(115),
&nbsp;        TYPE(99),
&nbsp;        ENUMERATION(101),
&nbsp;        ANNOTATION(64),
&nbsp;        ARRAY(91),
&nbsp;        NONE(0);
&nbsp;
&nbsp;        private final int tag;
&nbsp;
&nbsp;        private Sort(int tag) {
&nbsp;            this.tag = tag;
&nbsp;        }
&nbsp;
&nbsp;        public static Sort of(TypeDefinition typeDefinition) {
&nbsp;            if (typeDefinition.represents(Boolean.TYPE)) {
&nbsp;                return BOOLEAN;
&nbsp;            } else if (typeDefinition.represents(Byte.TYPE)) {
&nbsp;                return BYTE;
&nbsp;            } else if (typeDefinition.represents(Short.TYPE)) {
&nbsp;                return SHORT;
&nbsp;            } else if (typeDefinition.represents(Character.TYPE)) {
&nbsp;                return CHARACTER;
&nbsp;            } else if (typeDefinition.represents(Integer.TYPE)) {
&nbsp;                return INTEGER;
&nbsp;            } else if (typeDefinition.represents(Long.TYPE)) {
&nbsp;                return LONG;
&nbsp;            } else if (typeDefinition.represents(Float.TYPE)) {
&nbsp;                return FLOAT;
&nbsp;            } else if (typeDefinition.represents(Double.TYPE)) {
&nbsp;                return DOUBLE;
&nbsp;            } else if (typeDefinition.represents(String.class)) {
&nbsp;                return STRING;
&nbsp;            } else if (typeDefinition.represents(Class.class)) {
&nbsp;                return TYPE;
&nbsp;            } else if (typeDefinition.isEnum()) {
&nbsp;                return ENUMERATION;
&nbsp;            } else if (typeDefinition.isAnnotation()) {
&nbsp;                return ANNOTATION;
&nbsp;            } else {
&nbsp;                return typeDefinition.isArray() ? ARRAY : NONE;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        protected int getTag() {
&nbsp;            return this.tag;
&nbsp;        }
&nbsp;
&nbsp;        public boolean isDefined() {
&nbsp;            return this != NONE;
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static enum State {
&nbsp;        UNDEFINED,
&nbsp;        UNRESOLVED,
&nbsp;        RESOLVED;
&nbsp;
&nbsp;        private State() {
&nbsp;        }
&nbsp;
&nbsp;        public boolean isDefined() {
&nbsp;            return this != UNDEFINED;
&nbsp;        }
&nbsp;
&nbsp;        public boolean isResolved() {
&nbsp;            return this == RESOLVED;
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public interface Loaded&lt;U&gt; {
&nbsp;        State getState();
&nbsp;
&nbsp;        U resolve();
&nbsp;
&nbsp;        &lt;V&gt; V resolve(Class&lt;? extends V&gt; var1);
&nbsp;
&nbsp;        boolean represents(Object var1);
&nbsp;
&nbsp;        public abstract static class AbstractBase&lt;W&gt; implements Loaded&lt;W&gt; {
&nbsp;            public AbstractBase() {
&nbsp;            }
&nbsp;
&nbsp;            public &lt;X&gt; X resolve(Class&lt;? extends X&gt; type) {
&nbsp;                return type.cast(this.resolve());
&nbsp;            }
&nbsp;
&nbsp;            public abstract static class ForUnresolvedProperty&lt;Z&gt; extends AbstractBase&lt;Z&gt; {
&nbsp;                public ForUnresolvedProperty() {
&nbsp;                }
&nbsp;
&nbsp;                public State getState() {
&nbsp;                    return AnnotationValue.State.UNRESOLVED;
&nbsp;                }
&nbsp;
&nbsp;                public boolean represents(Object value) {
&nbsp;                    return false;
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static enum RenderingDispatcher {
&nbsp;        LEGACY_VM(&#39;[&#39;, &#39;]&#39;, true) {
&nbsp;            public String toSourceString(char value) {
&nbsp;                return Character.toString(value);
&nbsp;            }
&nbsp;
&nbsp;            public String toSourceString(long value) {
&nbsp;                return Long.toString(value);
&nbsp;            }
&nbsp;
&nbsp;            public String toSourceString(float value) {
&nbsp;                return Float.toString(value);
&nbsp;            }
&nbsp;
&nbsp;            public String toSourceString(double value) {
&nbsp;                return Double.toString(value);
&nbsp;            }
&nbsp;
&nbsp;            public String toSourceString(String value) {
&nbsp;                return value;
&nbsp;            }
&nbsp;
&nbsp;            public String toSourceString(TypeDescription value) {
&nbsp;                return value.toString();
&nbsp;            }
&nbsp;        },
&nbsp;        JAVA_9_CAPABLE_VM(&#39;{&#39;, &#39;}&#39;, true) {
&nbsp;            public String toSourceString(char value) {
&nbsp;                StringBuilder stringBuilder = (new StringBuilder()).append(&#39;\&#39;&#39;);
&nbsp;                if (value == &#39;\&#39;&#39;) {
&nbsp;                    stringBuilder.append(&quot;\\&#39;&quot;);
&nbsp;                } else {
&nbsp;                    stringBuilder.append(value);
&nbsp;                }
&nbsp;
&nbsp;                return stringBuilder.append(&#39;\&#39;&#39;).toString();
&nbsp;            }
&nbsp;
&nbsp;            public String toSourceString(long value) {
&nbsp;                return Math.abs(value) &lt;= 2147483647L ? String.valueOf(value) : value + &quot;L&quot;;
&nbsp;            }
&nbsp;
&nbsp;            public String toSourceString(float value) {
&nbsp;                return Math.abs(value) &lt;= Float.MAX_VALUE ? value + &quot;f&quot; : (Float.isInfinite(value) ? (value &lt; 0.0F ? &quot;-1.0f/0.0f&quot; : &quot;1.0f/0.0f&quot;) : &quot;0.0f/0.0f&quot;);
&nbsp;            }
&nbsp;
&nbsp;            public String toSourceString(double value) {
&nbsp;                return Math.abs(value) &lt;= Double.MAX_VALUE ? Double.toString(value) : (Double.isInfinite(value) ? (value &lt; 0.0 ? &quot;-1.0/0.0&quot; : &quot;1.0/0.0&quot;) : &quot;0.0/0.0&quot;);
&nbsp;            }
&nbsp;
&nbsp;            public String toSourceString(String value) {
&nbsp;                return &quot;\&quot;&quot; + (value.indexOf(34) == -1 ? value : value.replace(&quot;\&quot;&quot;, &quot;\\\&quot;&quot;)) + &quot;\&quot;&quot;;
&nbsp;            }
&nbsp;
&nbsp;            public String toSourceString(TypeDescription value) {
&nbsp;                return value.getActualName() + &quot;.class&quot;;
&nbsp;            }
&nbsp;        },
&nbsp;        JAVA_14_CAPABLE_VM(&#39;{&#39;, &#39;}&#39;, ClassFileVersion.ofThisVm(ClassFileVersion.JAVA_V5).isLessThan(ClassFileVersion.JAVA_V17)) {
&nbsp;            public String toSourceString(byte value) {
&nbsp;                return &quot;(byte)0x&quot; + Integer.toHexString(value &amp; 255);
&nbsp;            }
&nbsp;
&nbsp;            public String toSourceString(char value) {
&nbsp;                StringBuilder stringBuilder = (new StringBuilder()).append(&#39;\&#39;&#39;);
&nbsp;                if (value == &#39;\&#39;&#39;) {
&nbsp;                    stringBuilder.append(&quot;\\&#39;&quot;);
&nbsp;                } else {
&nbsp;                    stringBuilder.append(value);
&nbsp;                }
&nbsp;
&nbsp;                return stringBuilder.append(&#39;\&#39;&#39;).toString();
&nbsp;            }
&nbsp;
&nbsp;            public String toSourceString(long value) {
&nbsp;                return value + &quot;L&quot;;
&nbsp;            }
&nbsp;
&nbsp;            public String toSourceString(float value) {
&nbsp;                return Math.abs(value) &lt;= Float.MAX_VALUE ? value + &quot;f&quot; : (Float.isInfinite(value) ? (value &lt; 0.0F ? &quot;-1.0f/0.0f&quot; : &quot;1.0f/0.0f&quot;) : &quot;0.0f/0.0f&quot;);
&nbsp;            }
&nbsp;
&nbsp;            public String toSourceString(double value) {
&nbsp;                return Math.abs(value) &lt;= Double.MAX_VALUE ? Double.toString(value) : (Double.isInfinite(value) ? (value &lt; 0.0 ? &quot;-1.0/0.0&quot; : &quot;1.0/0.0&quot;) : &quot;0.0/0.0&quot;);
&nbsp;            }
&nbsp;
&nbsp;            public String toSourceString(String value) {
&nbsp;                return &quot;\&quot;&quot; + (value.indexOf(34) == -1 ? value : value.replace(&quot;\&quot;&quot;, &quot;\\\&quot;&quot;)) + &quot;\&quot;&quot;;
&nbsp;            }
&nbsp;
&nbsp;            public String toSourceString(TypeDescription value) {
&nbsp;                return value.getActualName() + &quot;.class&quot;;
&nbsp;            }
&nbsp;        },
&nbsp;        JAVA_17_CAPABLE_VM(&#39;{&#39;, &#39;}&#39;, ClassFileVersion.ofThisVm(ClassFileVersion.JAVA_V5).isLessThan(ClassFileVersion.JAVA_V17)) {
&nbsp;            public String toSourceString(byte value) {
&nbsp;                return &quot;(byte)0x&quot; + Integer.toHexString(value &amp; 255);
&nbsp;            }
&nbsp;
&nbsp;            public String toSourceString(char value) {
&nbsp;                StringBuilder stringBuilder = (new StringBuilder()).append(&#39;\&#39;&#39;);
&nbsp;                if (value == &#39;\&#39;&#39;) {
&nbsp;                    stringBuilder.append(&quot;\\&#39;&quot;);
&nbsp;                } else {
&nbsp;                    stringBuilder.append(value);
&nbsp;                }
&nbsp;
&nbsp;                return stringBuilder.append(&#39;\&#39;&#39;).toString();
&nbsp;            }
&nbsp;
&nbsp;            public String toSourceString(long value) {
&nbsp;                return value + &quot;L&quot;;
&nbsp;            }
&nbsp;
&nbsp;            public String toSourceString(float value) {
&nbsp;                return Math.abs(value) &lt;= Float.MAX_VALUE ? value + &quot;f&quot; : (Float.isInfinite(value) ? (value &lt; 0.0F ? &quot;-1.0f/0.0f&quot; : &quot;1.0f/0.0f&quot;) : &quot;0.0f/0.0f&quot;);
&nbsp;            }
&nbsp;
&nbsp;            public String toSourceString(double value) {
&nbsp;                return Math.abs(value) &lt;= Double.MAX_VALUE ? Double.toString(value) : (Double.isInfinite(value) ? (value &lt; 0.0 ? &quot;-1.0/0.0&quot; : &quot;1.0/0.0&quot;) : &quot;0.0/0.0&quot;);
&nbsp;            }
&nbsp;
&nbsp;            public String toSourceString(String value) {
&nbsp;                return &quot;\&quot;&quot; + (value.indexOf(34) == -1 ? value : value.replace(&quot;\&quot;&quot;, &quot;\\\&quot;&quot;)) + &quot;\&quot;&quot;;
&nbsp;            }
&nbsp;
&nbsp;            public String toSourceString(TypeDescription value) {
&nbsp;                return value.getActualName() + &quot;.class&quot;;
&nbsp;            }
&nbsp;
&nbsp;            public String toTypeErrorString(Class&lt;?&gt; type) {
&nbsp;                return type.getName();
&nbsp;            }
&nbsp;        };
&nbsp;
&nbsp;        private static final String ARRAY_PREFIX = &quot;Array with component tag: &quot;;
&nbsp;        public static final RenderingDispatcher CURRENT;
&nbsp;        private final char openingBrace;
&nbsp;        private final char closingBrace;
&nbsp;        private final boolean componentAsInteger;
&nbsp;
&nbsp;        private RenderingDispatcher(char openingBrace, char closingBrace, boolean componentAsInteger) {
&nbsp;            this.openingBrace = openingBrace;
&nbsp;            this.closingBrace = closingBrace;
&nbsp;            this.componentAsInteger = componentAsInteger;
&nbsp;        }
&nbsp;
&nbsp;        public String toSourceString(boolean value) {
&nbsp;            return Boolean.toString(value);
&nbsp;        }
&nbsp;
&nbsp;        public String toSourceString(byte value) {
&nbsp;            return Byte.toString(value);
&nbsp;        }
&nbsp;
&nbsp;        public String toSourceString(short value) {
&nbsp;            return Short.toString(value);
&nbsp;        }
&nbsp;
&nbsp;        public abstract String toSourceString(char var1);
&nbsp;
&nbsp;        public String toSourceString(int value) {
&nbsp;            return Integer.toString(value);
&nbsp;        }
&nbsp;
&nbsp;        public abstract String toSourceString(long var1);
&nbsp;
&nbsp;        public abstract String toSourceString(float var1);
&nbsp;
&nbsp;        public abstract String toSourceString(double var1);
&nbsp;
&nbsp;        public abstract String toSourceString(String var1);
&nbsp;
&nbsp;        public abstract String toSourceString(TypeDescription var1);
&nbsp;
&nbsp;        public String toSourceString(List&lt;?&gt; values) {
&nbsp;            StringBuilder stringBuilder = (new StringBuilder()).append(this.openingBrace);
&nbsp;            boolean first = true;
&nbsp;
&nbsp;            Object value;
&nbsp;            for(Iterator var4 = values.iterator(); var4.hasNext(); stringBuilder.append(value)) {
&nbsp;                value = var4.next();
&nbsp;                if (first) {
&nbsp;                    first = false;
&nbsp;                } else {
&nbsp;                    stringBuilder.append(&quot;, &quot;);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            return stringBuilder.append(this.closingBrace).toString();
&nbsp;        }
&nbsp;
&nbsp;        public String toArrayErrorString(Sort sort) {
&nbsp;            return &quot;Array with component tag: &quot; + (!this.componentAsInteger &amp;&amp; sort.isDefined() ? Character.toString((char)sort.getTag()) : Integer.toString(sort.getTag()));
&nbsp;        }
&nbsp;
&nbsp;        public String toTypeErrorString(Class&lt;?&gt; type) {
&nbsp;            return type.toString();
&nbsp;        }
&nbsp;
&nbsp;        static {
&nbsp;            ClassFileVersion classFileVersion = ClassFileVersion.ofThisVm(ClassFileVersion.JAVA_V5);
&nbsp;            if (classFileVersion.isAtLeast(ClassFileVersion.JAVA_V17)) {
&nbsp;                CURRENT = JAVA_17_CAPABLE_VM;
&nbsp;            } else if (classFileVersion.isAtLeast(ClassFileVersion.JAVA_V14)) {
&nbsp;                CURRENT = JAVA_14_CAPABLE_VM;
&nbsp;            } else if (classFileVersion.isAtLeast(ClassFileVersion.JAVA_V9)) {
&nbsp;                CURRENT = JAVA_9_CAPABLE_VM;
&nbsp;            } else {
&nbsp;                CURRENT = LEGACY_VM;
&nbsp;            }
&nbsp;
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-22 12:49</div>
</div>
</body>
</html>
